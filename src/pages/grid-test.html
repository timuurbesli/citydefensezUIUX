<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Defense Z - Grid Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: white;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            height: calc(100vh - 40px);
        }

        .game-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .grid-container {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #4a9eff;
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 2px;
            width: 400px;
            height: 400px;
            margin: 0 auto;
        }

        .grid-cell {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            position: relative;
            cursor: pointer;
        }

        .grid-cell:hover {
            background: rgba(74, 158, 255, 0.3);
            border-color: #4a9eff;
            transform: scale(1.05);
        }

        .grid-cell.snap-target {
            background: rgba(255, 215, 0, 0.4);
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
            transform: scale(1.1);
        }

        .building {
            width: 90%;
            height: 90%;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            position: relative;
            cursor: pointer;
        }

        .building.factory {
            background: linear-gradient(145deg, #ffd700, #ffb347);
            color: #333;
        }

        .building.house {
            background: linear-gradient(145deg, #808080, #a0a0a0);
            color: white;
        }

        .building.ammunition {
            background: linear-gradient(145deg, #32cd32, #228b22);
            color: white;
        }

        .building.laboratory {
            background: linear-gradient(145deg, #4169e1, #1e90ff);
            color: white;
        }

        .building.barracks {
            background: linear-gradient(145deg, #ffa500, #ff8c00);
            color: white;
        }

        .building-level {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ff4444;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
        }

        .dragging-building {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
            transform: scale(1.2);
        }

        .control-panel {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #4a9eff;
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .building-cards {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .building-card {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .building-card:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #4a9eff;
            transform: translateY(-2px);
        }

        .building-card.selected {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
        }

        .card-icon {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
        }

        .card-info {
            flex: 1;
        }

        .card-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .card-level {
            font-size: 12px;
            opacity: 0.8;
        }

        .sound-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 20px;
        }

        .sound-test-button {
            background: rgba(74, 158, 255, 0.3);
            border: 1px solid #4a9eff;
            color: white;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .sound-test-button:hover {
            background: rgba(74, 158, 255, 0.5);
            transform: translateY(-1px);
        }

        .sound-selector {
            margin-bottom: 15px;
        }

        .hover-sound-controls,
        .place-sound-controls,
        .first-pop-controls,
        .second-pop-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .arrow-button {
            background: rgba(255, 215, 0, 0.3);
            border: 1px solid #ffd700;
            color: #ffd700;
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .arrow-button:hover {
            background: rgba(255, 215, 0, 0.5);
            transform: scale(1.1);
        }

        .sound-dropdown {
            flex: 1;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .sound-dropdown:hover {
            border-color: #4a9eff;
            background: rgba(0, 0, 0, 0.8);
        }

        .sound-dropdown:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
        }

        .shuffle-toggle {
            margin-top: 8px;
        }

        .shuffle-button {
            background: rgba(255, 69, 0, 0.3);
            border: 1px solid #ff4500;
            color: #ff6b47;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
            justify-content: center;
        }

        .shuffle-button:hover {
            background: rgba(255, 69, 0, 0.5);
            transform: translateY(-1px);
        }

        .shuffle-button.active {
            background: rgba(255, 69, 0, 0.6);
            border-color: #ff6b47;
            color: #ffffff;
            box-shadow: 0 0 10px rgba(255, 69, 0, 0.4);
        }

        .shuffle-icon {
            font-size: 16px;
            font-style: normal;
        }

        .shuffle-text {
            font-weight: bold;
        }

        .merge-indicator {
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            border: 3px solid #ff6b6b;
            border-radius: 8px;
            animation: mergeGlow 1s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes mergeGlow {
            0%, 100% {
                border-color: #ff6b6b;
                box-shadow: 0 0 10px #ff6b6b;
            }
            50% {
                border-color: #ff9999;
                box-shadow: 0 0 20px #ff6b6b;
            }
        }

        @keyframes moveAndShrink {
            0% {
                transform: scale(1) translate(0, 0);
                opacity: 1;
            }
            70% {
                transform: scale(0.3) translate(var(--target-x), var(--target-y));
                opacity: 0.8;
            }
            100% {
                transform: scale(0) translate(var(--target-x), var(--target-y));
                opacity: 0;
            }
        }

        .moving-building {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            transition: all 0.8s ease-in-out;
        }

        @keyframes bounceUpgrade {
            0% {
                transform: scale(1);
            }
            25% {
                transform: scale(1.3);
            }
            50% {
                transform: scale(0.9);
            }
            75% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }



        .bounce-merge {
            animation: bounceUpgrade 0.6s ease-in-out;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 15px;
            font-size: 14px;
        }

        .info-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #ffd700;
        }

        .info-text {
            line-height: 1.4;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="game-area">
            <div class="grid-container">
                <h2 style="text-align: center; margin-bottom: 20px; color: #4a9eff;">5x5 Building Grid</h2>
                <div class="grid" id="gameGrid">
                    <!-- Grid cells will be generated by JavaScript -->
                </div>
            </div>
            
            <div class="info-panel">
                <div class="info-title">How to Play:</div>
                <div class="info-text">1. Select a building type from the right panel</div>
                <div class="info-text">2. Click on grid cells to place buildings</div>
                <div class="info-text">3. Get 3 same buildings in a line (horizontal/vertical/L-shape) to merge</div>
                <div class="info-text">4. Watch buildings animate into the merge position!</div>
                <div class="info-text">5. Use arrows/dropdown to select sounds, or enable shuffle mode</div>
            </div>
        </div>

        <div class="control-panel">
            <h3 style="color: #4a9eff; margin-bottom: 10px;">Building Cards</h3>
            <div class="building-cards" id="buildingCards">
                <!-- Building cards will be generated by JavaScript -->
            </div>

            <div class="sound-controls">
                <h4 style="color: #ffd700; margin-bottom: 10px;">Sound Tests</h4>
                
                <!-- Hover Sound Selector -->
                <div class="sound-selector">
                    <label style="color: #4a9eff; font-size: 14px; margin-bottom: 8px; display: block;">Hover Sound:</label>
                    <div class="hover-sound-controls">
                        <button class="arrow-button" onclick="previousHoverSound()">◀</button>
                        <select class="sound-dropdown" id="hoverSoundSelect" onchange="selectHoverSound()">
                            <option value="0">Hover Sound 1</option>
                            <option value="1">Hover Sound 2</option>
                            <option value="2">Hover Sound 3</option>
                            <option value="3">Hover Sound 4</option>
                            <option value="4">Hover Sound 5</option>
                            <option value="5">Hover Sound 6</option>
                        </select>
                        <button class="arrow-button" onclick="nextHoverSound()">▶</button>
                    </div>
                </div>
                
                <!-- Place Sound Selector -->
                <div class="sound-selector">
                    <label style="color: #32cd32; font-size: 14px; margin-bottom: 8px; display: block;">Place Sound:</label>
                    <div class="place-sound-controls">
                        <button class="arrow-button" onclick="previousPlaceSound()">◀</button>
                        <select class="sound-dropdown" id="placeSoundSelect" onchange="selectPlaceSound()">
                            <option value="0">Cush Dirt Thud 2</option>
                            <option value="1">Muffled Dirt 2</option>
                            <option value="2">Soft Dirt 2</option>
                            <option value="3">Muffled Dirt 3</option>
                            <option value="4">Soft Soil 2</option>
                            <option value="5">Soft Soil 3</option>
                            <option value="6">Gentle Dirt Thump 2</option>
                            <option value="7">Cush Dirt 3</option>
                        </select>
                        <button class="arrow-button" onclick="nextPlaceSound()">▶</button>
                    </div>
                    <div class="shuffle-toggle">
                        <button class="shuffle-button" id="shuffleToggle" onclick="toggleShuffle()">
                            <i class="shuffle-icon">🔀</i>
                            <span class="shuffle-text">Shuffle: OFF</span>
                        </button>
                    </div>
                </div>
                
                <!-- First Pop Sound Selector -->
                <div class="sound-selector">
                    <label style="color: #ff6b6b; font-size: 14px; margin-bottom: 8px; display: block;">First Pop Sound:</label>
                    <div class="first-pop-controls">
                        <button class="arrow-button" onclick="previousFirstPopSound()">◀</button>
                        <select class="sound-dropdown" id="firstPopSoundSelect" onchange="selectFirstPopSound()">
                            <!-- Options populated dynamically -->
                        </select>
                        <button class="arrow-button" onclick="nextFirstPopSound()">▶</button>
                    </div>
                </div>
                
                <!-- Second Pop Sound Selector -->
                <div class="sound-selector">
                    <label style="color: #ff9500; font-size: 14px; margin-bottom: 8px; display: block;">Second Pop Sound:</label>
                    <div class="second-pop-controls">
                        <button class="arrow-button" onclick="previousSecondPopSound()">◀</button>
                        <select class="sound-dropdown" id="secondPopSoundSelect" onchange="selectSecondPopSound()">
                            <!-- Options populated dynamically -->
                        </select>
                        <button class="arrow-button" onclick="nextSecondPopSound()">▶</button>
                    </div>
                </div>
                
                <button class="sound-test-button" onclick="testSelectedHoverSound()">Test Selected Hover Sound</button>
                <button class="sound-test-button" onclick="testPlaceSound()">Test Selected Place Sound</button>
                <button class="sound-test-button" onclick="testMergeSound()">Test Merge Sound</button>
                <button class="sound-test-button" onclick="testFirstPopSound()">Test First Pop Sound</button>
                <button class="sound-test-button" onclick="testSecondPopSound()">Test Second Pop Sound</button>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let selectedBuildingType = null;
        let grid = [];
        let draggedBuilding = null;
        
        // Building types configuration
        const buildingTypes = {
            factory: {
                name: 'Factory',
                color: '#ffd700',
                icon: 'F',
                description: 'Produces resources'
            },
            house: {
                name: 'House',
                color: '#808080',
                icon: 'H',
                description: 'Increases population'
            },
            ammunition: {
                name: 'Ammunition',
                color: '#32cd32',
                icon: 'A',
                description: 'Produces ammunition'
            },
            laboratory: {
                name: 'Laboratory',
                color: '#4169e1',
                icon: 'L',
                description: 'Produces research points'
            },
            barracks: {
                name: 'Barracks',
                color: '#ffa500',
                icon: 'B',
                description: 'Trains soldiers'
            }
        };

        // Sound system
        const hoverSounds = [
            'BuildingMoveGridHover (1).mp3',
            'BuildingMoveGridHover (2).mp3',
            'BuildingMoveGridHover (3).mp3',
            'BuildingMoveGridHover (4).mp3',
            'BuildingMoveGridHover (5).mp3',
            'BuildingMoveGridHover (6).mp3'
        ];

        const placeSounds = [
            '11L-cushioned_dirt_thud-1751461479209.mp3',      // cush dirt thud 2
            '11L-muffled_dirt_hit-1751461578547.mp3',         // muffled dirt 2
            '11L-soft_dirt_thump-1751458113598.mp3',          // soft dirt 2
            '11L-muffled_dirt_hit-1751461573708.mp3',         // muffled dirt 3
            '11L-soft_soil_thud-1751461297956.mp3',           // soft soil 2
            '11L-soft_soil_thud-1751461196165.mp3',           // soft soil 3
            '11L-gentle_dirt_thump-1751460915137.mp3',        // gentle dirt thump 2
            '11L-cushioned_dirt_thud-1751461465021.mp3'       // cush dirt 3
        ];

        // All merge pop sounds in one pool
        const mergePopSounds = [
            'SFX_Pop_Designed_Collect_Vacuum_1.wav',
            'SFX_Pop_Designed_Collect_Vacuum_2.wav',
            'SFX_Pop_Bottle_Tiny_1.wav',
            'SFX_Pop_Bottle_Tiny_2.wav'
        ];

        // Friendly names for the sounds
        const mergePopSoundNames = [
            'Vacuum Pop 1',
            'Vacuum Pop 2', 
            'Bottle Pop 1',
            'Bottle Pop 2'
        ];

        let selectedHoverSoundIndex = 5; // Default to Hover Sound 6
        let selectedPlaceSoundIndex = 0; // Default to first place sound
        let selectedFirstPopSoundIndex = 0; // Default to first sound for first pop
        let selectedSecondPopSoundIndex = 1; // Default to second sound for second pop
        let currentHoverSound = null; // Track currently playing sound
        let shuffleModeEnabled = false; // Shuffle mode toggle
        let lastPlayedPlaceSoundIndex = -1; // Track last played sound to avoid repeats

        function playHoverSound() {
            // Stop any currently playing hover sound immediately
            if (currentHoverSound) {
                currentHoverSound.pause();
                currentHoverSound.currentTime = 0;
            }
            
            // Create and play new sound immediately
            currentHoverSound = new Audio(`../../sounds/Hover/${hoverSounds[selectedHoverSoundIndex]}`);
            currentHoverSound.volume = 0.5;
            
            // Clear reference when sound ends
            currentHoverSound.addEventListener('ended', () => {
                currentHoverSound = null;
            });
            
            currentHoverSound.play().catch(e => console.log('Could not play hover sound:', e));
        }

        function playPlaceSound() {
            let soundIndexToPlay;
            
            if (shuffleModeEnabled) {
                // Generate random index, avoiding the last played sound
                do {
                    soundIndexToPlay = Math.floor(Math.random() * placeSounds.length);
                } while (soundIndexToPlay === lastPlayedPlaceSoundIndex && placeSounds.length > 1);
                
                lastPlayedPlaceSoundIndex = soundIndexToPlay;
            } else {
                soundIndexToPlay = selectedPlaceSoundIndex;
            }
            
            const sound = new Audio(`../../sounds/place/${placeSounds[soundIndexToPlay]}`);
            sound.volume = 0.7;
            sound.play().catch(e => console.log('Could not play place sound:', e));
        }

        function playMergeSound() {
            const sound = new Audio('../../sounds/merge/merge.mp3');
            sound.volume = 0.8;
            sound.play().catch(e => console.log('Could not play merge sound:', e));
        }

        function playFirstPopSound() {
            const soundFile = mergePopSounds[selectedFirstPopSoundIndex];
            const sound = new Audio(`../../sounds/mergepop/${soundFile}`);
            sound.volume = 0.5;
            sound.play().catch(e => console.log('Could not play first pop sound:', e));
        }

        function playSecondPopSound() {
            const soundFile = mergePopSounds[selectedSecondPopSoundIndex];
            const sound = new Audio(`../../sounds/mergepop/${soundFile}`);
            sound.volume = 0.5;
            sound.play().catch(e => console.log('Could not play second pop sound:', e));
        }

        // Legacy functions for backward compatibility (now use new system)
        function playVacuumSound1() {
            playFirstPopSound();
        }

        function playVacuumSound2() {
            playSecondPopSound();
        }

        // Sound test functions
        function testSelectedHoverSound() {
            playHoverSound();
        }

        function testPlaceSound() {
            playPlaceSound();
        }

        function testMergeSound() {
            playMergeSound();
        }

        function testFirstPopSound() {
            playFirstPopSound();
        }

        function testSecondPopSound() {
            playSecondPopSound();
        }

        // Hover sound selection functions
        function previousHoverSound() {
            selectedHoverSoundIndex = (selectedHoverSoundIndex - 1 + hoverSounds.length) % hoverSounds.length;
            updateHoverSoundDisplay();
            playHoverSound(); // Play the newly selected sound
        }

        function nextHoverSound() {
            selectedHoverSoundIndex = (selectedHoverSoundIndex + 1) % hoverSounds.length;
            updateHoverSoundDisplay();
            playHoverSound(); // Play the newly selected sound
        }

        function selectHoverSound() {
            const dropdown = document.getElementById('hoverSoundSelect');
            selectedHoverSoundIndex = parseInt(dropdown.value);
            playHoverSound(); // Play the newly selected sound
        }

        function updateHoverSoundDisplay() {
            const dropdown = document.getElementById('hoverSoundSelect');
            dropdown.value = selectedHoverSoundIndex;
        }

        // Place sound selection functions
        function previousPlaceSound() {
            selectedPlaceSoundIndex = (selectedPlaceSoundIndex - 1 + placeSounds.length) % placeSounds.length;
            updatePlaceSoundDisplay();
            playPlaceSound(); // Play the newly selected sound
        }

        function nextPlaceSound() {
            selectedPlaceSoundIndex = (selectedPlaceSoundIndex + 1) % placeSounds.length;
            updatePlaceSoundDisplay();
            playPlaceSound(); // Play the newly selected sound
        }

        function selectPlaceSound() {
            const dropdown = document.getElementById('placeSoundSelect');
            selectedPlaceSoundIndex = parseInt(dropdown.value);
            playPlaceSound(); // Play the newly selected sound
        }

        function updatePlaceSoundDisplay() {
            const dropdown = document.getElementById('placeSoundSelect');
            dropdown.value = selectedPlaceSoundIndex;
        }

        // Shuffle mode functions
        function toggleShuffle() {
            shuffleModeEnabled = !shuffleModeEnabled;
            updateShuffleDisplay();
            
            // Reset last played sound when toggling
            lastPlayedPlaceSoundIndex = -1;
            
            // Play a sound to demonstrate the new mode
            playPlaceSound();
        }

        function updateShuffleDisplay() {
            const shuffleButton = document.getElementById('shuffleToggle');
            const shuffleText = shuffleButton.querySelector('.shuffle-text');
            
            if (shuffleModeEnabled) {
                shuffleButton.classList.add('active');
                shuffleText.textContent = 'Shuffle: ON';
            } else {
                shuffleButton.classList.remove('active');
                shuffleText.textContent = 'Shuffle: OFF';
            }
        }

        // First pop sound selection functions
        function previousFirstPopSound() {
            selectedFirstPopSoundIndex = (selectedFirstPopSoundIndex - 1 + mergePopSounds.length) % mergePopSounds.length;
            updateFirstPopSoundDisplay();
            playFirstPopSound(); // Play the newly selected sound
        }

        function nextFirstPopSound() {
            selectedFirstPopSoundIndex = (selectedFirstPopSoundIndex + 1) % mergePopSounds.length;
            updateFirstPopSoundDisplay();
            playFirstPopSound(); // Play the newly selected sound
        }

        function selectFirstPopSound() {
            const dropdown = document.getElementById('firstPopSoundSelect');
            selectedFirstPopSoundIndex = parseInt(dropdown.value);
            playFirstPopSound(); // Play the newly selected sound
        }

        function updateFirstPopSoundDisplay() {
            const dropdown = document.getElementById('firstPopSoundSelect');
            if (dropdown) {
                // Clear and repopulate options
                dropdown.innerHTML = '';
                mergePopSoundNames.forEach((name, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = name;
                    dropdown.appendChild(option);
                });
                dropdown.value = selectedFirstPopSoundIndex;
            }
        }

        // Second pop sound selection functions
        function previousSecondPopSound() {
            selectedSecondPopSoundIndex = (selectedSecondPopSoundIndex - 1 + mergePopSounds.length) % mergePopSounds.length;
            updateSecondPopSoundDisplay();
            playSecondPopSound(); // Play the newly selected sound
        }

        function nextSecondPopSound() {
            selectedSecondPopSoundIndex = (selectedSecondPopSoundIndex + 1) % mergePopSounds.length;
            updateSecondPopSoundDisplay();
            playSecondPopSound(); // Play the newly selected sound
        }

        function selectSecondPopSound() {
            const dropdown = document.getElementById('secondPopSoundSelect');
            selectedSecondPopSoundIndex = parseInt(dropdown.value);
            playSecondPopSound(); // Play the newly selected sound
        }

        function updateSecondPopSoundDisplay() {
            const dropdown = document.getElementById('secondPopSoundSelect');
            if (dropdown) {
                // Clear and repopulate options
                dropdown.innerHTML = '';
                mergePopSoundNames.forEach((name, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = name;
                    dropdown.appendChild(option);
                });
                dropdown.value = selectedSecondPopSoundIndex;
            }
        }

        // Initialize grid
        function initializeGrid() {
            const gridElement = document.getElementById('gameGrid');
            grid = [];
            
            for (let i = 0; i < 25; i++) {
                const row = Math.floor(i / 5);
                const col = i % 5;
                
                if (!grid[row]) grid[row] = [];
                grid[row][col] = null;
                
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.row = row;
                cell.dataset.col = col;
                
                cell.addEventListener('mouseenter', handleCellHover);
                cell.addEventListener('mouseleave', handleCellLeave);
                cell.addEventListener('click', handleCellClick);
                
                gridElement.appendChild(cell);
            }
        }

        // Handle cell interactions
        function handleCellHover(event) {
            if (selectedBuildingType && !grid[event.target.dataset.row][event.target.dataset.col]) {
                event.target.classList.add('snap-target');
                playHoverSound();
            }
        }

        function handleCellLeave(event) {
            event.target.classList.remove('snap-target');
        }

        function handleCellClick(event) {
            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);
            
            if (selectedBuildingType && !grid[row][col]) {
                placeBuilding(row, col, selectedBuildingType, 1);
                playPlaceSound();
                checkForMerges(row, col);
            }
        }

        // Building placement
        function placeBuilding(row, col, type, level) {
            const building = {
                type: type,
                level: level,
                id: Date.now() + Math.random()
            };
            
            grid[row][col] = building;
            updateGridDisplay();
        }

        // Update grid visual display
        function updateGridDisplay() {
            const cells = document.querySelectorAll('.grid-cell');
            
            cells.forEach((cell, index) => {
                const row = Math.floor(index / 5);
                const col = index % 5;
                const building = grid[row][col];
                
                // Clear previous building
                const existingBuilding = cell.querySelector('.building');
                if (existingBuilding) {
                    // Clear any animation classes before removing
                    existingBuilding.classList.remove('moving-to-merge', 'bounce-merge');
                    existingBuilding.remove();
                }
                
                // Add new building if exists
                if (building) {
                    const buildingElement = document.createElement('div');
                    buildingElement.className = `building ${building.type}`;
                    buildingElement.innerHTML = `
                        ${buildingTypes[building.type].icon}
                        <div class="building-level">${building.level}</div>
                    `;
                    cell.appendChild(buildingElement);
                }
            });
        }

        // Merge detection and handling
        function checkForMerges(row, col) {
            const building = grid[row][col];
            if (!building) return;
            
            // Check for horizontal merges (3 in a row)
            const horizontalMerge = checkHorizontalMerge(row, col, building.type, building.level);
            if (horizontalMerge) {
                performMerge(horizontalMerge, building.type, building.level, row, col);
                return;
            }
            
            // Check for vertical merges (3 in a column)
            const verticalMerge = checkVerticalMerge(row, col, building.type, building.level);
            if (verticalMerge) {
                performMerge(verticalMerge, building.type, building.level, row, col);
                return;
            }
            
            // Check for L-shaped merges
            const lShapeMerge = checkLShapeMerge(row, col, building.type, building.level);
            if (lShapeMerge) {
                performMerge(lShapeMerge, building.type, building.level, row, col);
                return;
            }
        }

        function checkHorizontalMerge(row, col, type, level) {
            // Check all possible horizontal 3-in-a-row patterns that include this position
            for (let startCol = Math.max(0, col - 2); startCol <= Math.min(2, col); startCol++) {
                if (startCol + 2 >= 5) break; // Stay within grid bounds
                
                const positions = [
                    {row, col: startCol},
                    {row, col: startCol + 1},
                    {row, col: startCol + 2}
                ];
                
                // Check if all 3 positions have matching buildings
                const allMatch = positions.every(pos => {
                    const building = grid[pos.row][pos.col];
                    return building && building.type === type && building.level === level;
                });
                
                if (allMatch) {
                    return positions;
                }
            }
            return null;
        }

        function checkVerticalMerge(row, col, type, level) {
            // Check all possible vertical 3-in-a-row patterns that include this position
            for (let startRow = Math.max(0, row - 2); startRow <= Math.min(2, row); startRow++) {
                if (startRow + 2 >= 5) break; // Stay within grid bounds
                
                const positions = [
                    {row: startRow, col},
                    {row: startRow + 1, col},
                    {row: startRow + 2, col}
                ];
                
                // Check if all 3 positions have matching buildings
                const allMatch = positions.every(pos => {
                    const building = grid[pos.row][pos.col];
                    return building && building.type === type && building.level === level;
                });
                
                if (allMatch) {
                    return positions;
                }
            }
            return null;
        }

        function checkLShapeMerge(row, col, type, level) {
            // Define the 4 basic L-shape orientations
            // Each L-shape is defined by its corner position and two extensions
            const lShapeTemplates = [
                // L-shape: corner at (0,0), extends right and down
                [[0,0], [0,1], [1,0]],
                // L-shape: corner at (0,1), extends left and down  
                [[0,0], [0,1], [1,1]],
                // L-shape: corner at (1,0), extends right and up
                [[0,0], [1,0], [1,1]],
                // L-shape: corner at (1,1), extends left and up
                [[0,1], [1,0], [1,1]]
            ];
            
            // For each L-shape template, try placing it at different positions
            // so that the placed building (row, col) is part of the pattern
            for (const template of lShapeTemplates) {
                for (let i = 0; i < 3; i++) {
                    // Try making each position in the template be the placed building
                    const offsetRow = row - template[i][0];
                    const offsetCol = col - template[i][1];
                    
                    // Calculate actual positions for this L-shape
                    const positions = template.map(([r, c]) => ({
                        row: r + offsetRow,
                        col: c + offsetCol
                    }));
                    
                    // Check if all positions are within grid bounds
                    const inBounds = positions.every(pos => 
                        pos.row >= 0 && pos.row < 5 && pos.col >= 0 && pos.col < 5
                    );
                    
                    if (inBounds) {
                        // Check if all 3 positions have matching buildings
                        const allMatch = positions.every(pos => {
                            const building = grid[pos.row][pos.col];
                            return building && building.type === type && building.level === level;
                        });
                        
                        if (allMatch) {
                            return positions;
                        }
                    }
                }
            }
            return null;
        }



        function performMerge(positions, type, level, lastPlacedRow, lastPlacedCol) {
            // Show merge indicator
            showMergeIndicator(positions);
            
            setTimeout(() => {
                // Animate buildings moving to merge position
                animateMergeMovement(positions, lastPlacedRow, lastPlacedCol, type, level);
            }, 500);
        }

        function animateMergeMovement(positions, lastPlacedRow, lastPlacedCol, type, level) {
            // Find buildings that need to move (not the last placed one)
            const movingBuildings = positions.filter(pos => 
                pos.row !== lastPlacedRow || pos.col !== lastPlacedCol
            );
            
            // Sort by distance to target (closest first)
            movingBuildings.sort((a, b) => {
                const distA = Math.abs(a.row - lastPlacedRow) + Math.abs(a.col - lastPlacedCol);
                const distB = Math.abs(b.row - lastPlacedRow) + Math.abs(b.col - lastPlacedCol);
                return distA - distB;
            });
            
            // Get target cell position
            const targetCellIndex = lastPlacedRow * 5 + lastPlacedCol;
            const targetCell = document.querySelectorAll('.grid-cell')[targetCellIndex];
            const targetRect = targetCell.getBoundingClientRect();
            
            // Animate buildings sequentially
            let animationDelay = 0;
            const animationPromises = [];
            
            movingBuildings.forEach((pos, index) => {
                const promise = new Promise((resolve) => {
                    setTimeout(() => {
                        const cellIndex = pos.row * 5 + pos.col;
                        const cell = document.querySelectorAll('.grid-cell')[cellIndex];
                        const building = cell.querySelector('.building');
                        
                        if (building && cell) {
                            // Get current position
                            const currentRect = cell.getBoundingClientRect();
                            
                            // Create a clone for animation
                            const clone = building.cloneNode(true);
                            clone.classList.add('moving-building');
                            clone.classList.remove('moving-to-merge', 'bounce-merge'); // Clean up any existing classes
                            clone.style.left = currentRect.left + 'px';
                            clone.style.top = currentRect.top + 'px';
                            clone.style.width = currentRect.width + 'px';
                            clone.style.height = currentRect.height + 'px';
                            
                            document.body.appendChild(clone);
                            
                            // Hide original immediately
                            building.style.opacity = '0';
                            
                            // Animate to center of target cell
                            setTimeout(() => {
                                const targetCenterX = targetRect.left + targetRect.width / 2 - currentRect.width / 2;
                                const targetCenterY = targetRect.top + targetRect.height / 2 - currentRect.height / 2;
                                
                                clone.style.left = targetCenterX + 'px';
                                clone.style.top = targetCenterY + 'px';
                                clone.style.transform = 'scale(0.1)';
                                clone.style.opacity = '0';
                                
                                // Play vacuum sounds when animation starts moving
                                if (index === 0) {
                                    // First building (closest) - play vacuum sound 1
                                    playVacuumSound1();
                                } else if (index === 1) {
                                    // Second building - play vacuum sound 2
                                    playVacuumSound2();
                                }
                            }, 50);
                            
                            // Clean up after animation completes
                            setTimeout(() => {
                                if (document.body.contains(clone)) {
                                    document.body.removeChild(clone);
                                }
                                // Clear the original cell
                                cell.innerHTML = '';
                                resolve();
                            }, 750);
                        } else {
                            resolve();
                        }
                    }, animationDelay);
                });
                
                animationPromises.push(promise);
                animationDelay += 200; // Stagger animations by 200ms
            });
            
            // Wait for all animations to complete, then finish merge
            Promise.all(animationPromises).then(() => {
                completeMerge(positions, lastPlacedRow, lastPlacedCol, type, level);
                
            });
        }

        function completeMerge(positions, lastPlacedRow, lastPlacedCol, type, level) {
            // Clear all merged buildings from grid state (UI already cleared during animation)
            positions.forEach(pos => {
                grid[pos.row][pos.col] = null;
            });
            
            // Play merge sound immediately when merge completes
            playMergeSound();
            
            // Place new higher level building at the LAST-PLACED position
            placeBuilding(lastPlacedRow, lastPlacedCol, type, level + 1);
            
            // Add bounce animation to the merged building immediately
            const cellIndex = lastPlacedRow * 5 + lastPlacedCol;
            const cell = document.querySelectorAll('.grid-cell')[cellIndex];
            const mergedBuilding = cell.querySelector('.building');
            
            if (mergedBuilding) {
                mergedBuilding.classList.add('bounce-merge');
                
                // Remove bounce class after animation
                setTimeout(() => {
                    mergedBuilding.classList.remove('bounce-merge');
                }, 600);
            }
            
            // Check for chain merges at the last-placed position
            setTimeout(() => {
                checkForMerges(lastPlacedRow, lastPlacedCol);
            }, 800);
        }

        function showMergeIndicator(positions) {
            positions.forEach(pos => {
                const cellIndex = pos.row * 5 + pos.col;
                const cell = document.querySelectorAll('.grid-cell')[cellIndex];
                const indicator = document.createElement('div');
                indicator.className = 'merge-indicator';
                cell.appendChild(indicator);
                
                setTimeout(() => {
                    if (indicator.parentNode) {
                        indicator.remove();
                    }
                }, 1800); // Extended to cover the full animation sequence
            });
        }

        // Initialize building cards
        function initializeBuildingCards() {
            const cardsContainer = document.getElementById('buildingCards');
            
            Object.entries(buildingTypes).forEach(([type, config]) => {
                const card = document.createElement('div');
                card.className = 'building-card';
                card.dataset.type = type;
                
                card.innerHTML = `
                    <div class="card-icon ${type}" style="background: linear-gradient(145deg, ${config.color}, ${config.color}aa); color: ${type === 'factory' ? '#333' : 'white'};">
                        ${config.icon}
                    </div>
                    <div class="card-info">
                        <div class="card-name">${config.name}</div>
                        <div class="card-level">Level 1 • ${config.description}</div>
                    </div>
                `;
                
                card.addEventListener('click', () => selectBuildingType(type, card));
                cardsContainer.appendChild(card);
            });
        }

        function selectBuildingType(type, cardElement) {
            // Remove previous selection
            document.querySelectorAll('.building-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Set new selection
            selectedBuildingType = type;
            cardElement.classList.add('selected');
        }

        // Initialize the game
        function initialize() {
            initializeGrid();
            initializeBuildingCards();
            
            // Select first building type by default
            const firstCard = document.querySelector('.building-card');
            if (firstCard) {
                selectBuildingType(firstCard.dataset.type, firstCard);
            }
            
            // Initialize sound dropdown displays
            updateHoverSoundDisplay();
            updatePlaceSoundDisplay();
            updateFirstPopSoundDisplay();
            updateSecondPopSoundDisplay();
            updateShuffleDisplay();
            
            console.log('Grid test initialized!');
        }

        // Start the game when page loads
        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html> 
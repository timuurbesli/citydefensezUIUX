<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Defense Z - Grid Test</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: white;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
            height: calc(100vh - 40px);
        }

        .game-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .grid-container {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #4a9eff;
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 2px;
            width: 400px;
            height: 400px;
            margin: 0 auto;
        }

        .grid-cell {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            position: relative;
            cursor: pointer;
        }

        .grid-cell:hover {
            background: rgba(74, 158, 255, 0.3);
            border-color: #4a9eff;
            transform: scale(1.05);
        }

        .grid-cell.snap-target {
            background: rgba(255, 215, 0, 0.4);
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
            transform: scale(1.1);
        }

        .building {
            width: 90%;
            height: 90%;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            position: relative;
            cursor: pointer;
        }

        .building.factory {
            background: linear-gradient(145deg, #ffd700, #ffb347);
            color: #333;
        }

        .building.house {
            background: linear-gradient(145deg, #808080, #a0a0a0);
            color: white;
        }

        .building.ammunition {
            background: linear-gradient(145deg, #32cd32, #228b22);
            color: white;
        }

        .building.laboratory {
            background: linear-gradient(145deg, #4169e1, #1e90ff);
            color: white;
        }

        .building.barracks {
            background: linear-gradient(145deg, #ffa500, #ff8c00);
            color: white;
        }

        .building-level {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ff4444;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
        }

        .dragging-building {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
            transform: scale(1.2);
        }

        .control-panel {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #4a9eff;
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Building Cards Container - Game.html Style */
        .building-cards-container {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #4a9eff;
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
            margin-top: 20px;
        }

        .building-cards {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 280px;
            width: 100%;
            padding: 0 2rem;
        }

        .card-wrapper {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform-origin: center bottom;
            transition: transform 0.3s ease, z-index 0.3s;
            cursor: grab;
        }
        .card-wrapper:nth-child(1) { z-index:1; transform: translateX(-200px) rotate(-15deg); }
        .card-wrapper:nth-child(2) { z-index:2; transform: translateX(-100px) rotate(-7deg); }
        .card-wrapper:nth-child(3) { z-index:3; transform: translateX(0) rotate(0deg); }
        .card-wrapper:nth-child(4) { z-index:2; transform: translateX(100px) rotate(7deg); }
        .card-wrapper:nth-child(5) { z-index:1; transform: translateX(200px) rotate(15deg); }
        .card-wrapper:hover { z-index: 10; }
        .card-wrapper:nth-child(1):hover { transform: translateX(-200px) translateY(-30px) rotate(-5deg) scale(1.1); }
        .card-wrapper:nth-child(2):hover { transform: translateX(-100px) translateY(-30px) rotate(-2deg) scale(1.1); }
        .card-wrapper:nth-child(3):hover { transform: translateX(0) translateY(-30px) rotate(0deg) scale(1.1); }
        .card-wrapper:nth-child(4):hover { transform: translateX(100px) translateY(-30px) rotate(2deg) scale(1.1); }
        .card-wrapper:nth-child(5):hover { transform: translateX(200px) translateY(-30px) rotate(5deg) scale(1.1); }

        .building-card-img {
            width: 15rem;
            height: auto;
            object-fit: contain;
            cursor: grab;
            transition: filter 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: none;
            border-radius: 12px;
            padding: 0;
            margin: 0;
            position: static;
            filter: brightness(0.9);
        }
        .building-card-img:hover {
            filter: brightness(1.1);
            z-index: 100 !important;
        }

        .building-card-img.affordable {
            filter: brightness(0.9) drop-shadow(0 0 20px rgba(0, 255, 128, 0.4));
            animation: affordableGlow 2s ease-in-out infinite alternate;
        }

        .building-card-img.affordable:hover {
            filter: brightness(1.1) drop-shadow(0 0 30px rgba(0, 255, 128, 0.6)) !important;
        }

        .building-card-img.unaffordable {
            filter: brightness(0.5) drop-shadow(0 0 20px rgba(255, 68, 68, 0.4));
            opacity: 0.7;
            cursor: not-allowed;
            animation: unaffordableGlow 2s ease-in-out infinite alternate;
        }

        .building-card-img.unaffordable:hover {
            filter: brightness(0.6) drop-shadow(0 0 25px rgba(255, 68, 68, 0.5)) !important;
        }

        .building-card-img.selected {
            filter: brightness(1.1) drop-shadow(0 0 30px rgba(255, 215, 0, 0.8));
            animation: selectedGlow 1.5s ease-in-out infinite alternate;
        }

        .building-card-img.dragging {
            cursor: grabbing;
            transform: rotate(5deg) scale(1.1);
            opacity: 0.8;
            z-index: 1000;
        }

        .drag-preview {
            position: fixed;
            pointer-events: none;
            z-index: 1001;
            width: 80px;
            height: 80px;
            border-radius: 8px;
            opacity: 0.8;
            transform: rotate(5deg);
            transition: none;
        }

        .cards-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 0 10px;
        }

        .resource-display {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #ffd700;
            border-radius: 8px;
            padding: 10px 15px;
            text-align: center;
            backdrop-filter: blur(5px);
            flex: 1;
            margin-right: 20px;
        }

        .resource-display span {
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .refresh-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .refresh-cards-btn {
            width: 40px;
            height: 40px;
            background: linear-gradient(145deg, rgba(74, 158, 255, 0.3), rgba(74, 158, 255, 0.1));
            border: 2px solid #4a9eff;
            border-radius: 8px;
            color: #4a9eff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            font-size: 16px;
        }

        .refresh-cards-btn:hover {
            background: linear-gradient(145deg, rgba(74, 158, 255, 0.5), rgba(74, 158, 255, 0.2));
            border-color: #6bb8ff;
            color: #6bb8ff;
            transform: rotate(180deg) scale(1.1);
            box-shadow: 0 0 20px rgba(74, 158, 255, 0.4);
        }

        .refresh-count {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #4a9eff;
            border-radius: 6px;
            padding: 8px 12px;
            color: #4a9eff;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 0 0 8px rgba(74, 158, 255, 0.5);
            backdrop-filter: blur(5px);
        }

        /* Animations from game.html */
        @keyframes affordableGlow {
            0% {
                filter: brightness(0.9) drop-shadow(0 0 20px rgba(0, 255, 128, 0.4));
            }
            100% {
                filter: brightness(1.0) drop-shadow(0 0 30px rgba(0, 255, 128, 0.6));
            }
        }

        @keyframes unaffordableGlow {
            0% {
                filter: brightness(0.5) drop-shadow(0 0 20px rgba(255, 68, 68, 0.4));
            }
            100% {
                filter: brightness(0.6) drop-shadow(0 0 30px rgba(255, 68, 68, 0.6));
            }
        }

        @keyframes selectedGlow {
            0% {
                filter: brightness(1.1) drop-shadow(0 0 30px rgba(255, 215, 0, 0.8));
            }
            100% {
                filter: brightness(1.2) drop-shadow(0 0 40px rgba(255, 215, 0, 1));
            }
        }

        .sound-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 20px;
        }

        .sound-test-button {
            background: rgba(74, 158, 255, 0.3);
            border: 1px solid #4a9eff;
            color: white;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .sound-test-button:hover {
            background: rgba(74, 158, 255, 0.5);
            transform: translateY(-1px);
        }

        .sound-selector {
            margin-bottom: 15px;
        }

        .hover-sound-controls,
        .place-sound-controls,
        .first-pop-controls,
        .second-pop-controls,
        .merge-sound-controls,
        .reroll-sound-controls,
        .card-hover-cancel-sound-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            min-height: 32px;
        }

        .arrow-button {
            background: rgba(255, 215, 0, 0.3);
            border: 1px solid #ffd700;
            color: #ffd700;
            min-width: 32px; /* Ensure consistent width */
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0; /* Remove any padding that might affect alignment */
            margin: 0; /* Remove any margin that might affect alignment */
            line-height: 1; /* Ensure consistent text alignment */
        }

        .arrow-button:hover {
            background: rgba(255, 215, 0, 0.5);
            transform: scale(1.1);
        }

        .sound-dropdown {
            flex: 1;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            height: 32px; /* Ensure consistent height */
            line-height: 1; /* Ensure text alignment */
            display: flex;
            align-items: center;
        }

        .sound-dropdown:hover {
            border-color: #4a9eff;
            background: rgba(0, 0, 0, 0.8);
        }

        .sound-dropdown:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
        }

        .shuffle-toggle {
            margin-top: 8px;
        }

        .shuffle-button {
            background: rgba(255, 69, 0, 0.3);
            border: 1px solid #ff4500;
            color: #ff6b47;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
            justify-content: center;
        }

        .shuffle-button:hover {
            background: rgba(255, 69, 0, 0.5);
            transform: translateY(-1px);
        }

        .shuffle-button.active {
            background: rgba(255, 69, 0, 0.6);
            border-color: #ff6b47;
            color: #ffffff;
            box-shadow: 0 0 10px rgba(255, 69, 0, 0.4);
        }

        .shuffle-icon {
            font-size: 16px;
            font-style: normal;
        }

        .shuffle-text {
            font-weight: bold;
        }

        .merge-indicator {
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            border: 3px solid #ff6b6b;
            border-radius: 8px;
            animation: mergeGlow 1s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes mergeGlow {
            0%, 100% {
                border-color: #ff6b6b;
                box-shadow: 0 0 10px #ff6b6b;
            }
            50% {
                border-color: #ff9999;
                box-shadow: 0 0 20px #ff6b6b;
            }
        }

        @keyframes moveAndShrink {
            0% {
                transform: scale(1) translate(0, 0);
                opacity: 1;
            }
            70% {
                transform: scale(0.3) translate(var(--target-x), var(--target-y));
                opacity: 0.8;
            }
            100% {
                transform: scale(0) translate(var(--target-x), var(--target-y));
                opacity: 0;
            }
        }

        .moving-building {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            transition: all 0.8s ease-in-out;
        }

        @keyframes bounceUpgrade {
            0% {
                transform: scale(1);
            }
            25% {
                transform: scale(1.3);
            }
            50% {
                transform: scale(0.9);
            }
            75% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }

        .bounce-merge {
            animation: bounceUpgrade 0.6s ease-in-out;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 15px;
            font-size: 14px;
        }

        .info-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #ffd700;
        }

        .info-text {
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .snap-target .building-card-img {
            opacity: 0 !important;
            pointer-events: none !important;
            transition: opacity 0.15s cubic-bezier(0.4, 0.2, 0.2, 1);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="game-area">
            <div class="grid-container">
                <h2 style="text-align: center; margin-bottom: 20px; color: #4a9eff;">5x5 Building Grid</h2>
                <div class="grid" id="gameGrid">
                    <!-- Grid cells will be generated by JavaScript -->
                </div>
            </div>
            
            <!-- Building Cards Container -->
            <div class="building-cards-container">
                <div class="cards-header">
                    <div class="resource-display">
                        <span style="color: #ffd700; font-weight: bold;">Resources: </span>
                        <span id="resourceCount" style="color: #ffffff; font-weight: bold;">1000</span>
                    </div>
                    <div class="refresh-section">
                        <button class="refresh-cards-btn" id="refresh-cards-btn">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                        <div class="refresh-count" id="refresh-count">5/5</div>
                    </div>
                </div>
                <div class="building-cards" id="buildingCards">
                    <!-- Building cards will be generated by JavaScript -->
                </div>
            </div>
            
            <div class="info-panel">
                <div class="info-title">How to Play:</div>
                <div class="info-text">1. Drag building cards from above onto the grid</div>
                <div class="info-text">2. Or select a card and click on grid cells to place buildings</div>
                <div class="info-text">3. Get 3 same buildings in a line (horizontal/vertical/L-shape) to merge</div>
                <div class="info-text">4. Watch buildings animate into the merge position!</div>
                <div class="info-text">5. Use arrows/dropdown to select sounds, or enable shuffle mode</div>
                <div class="info-text">6. Green glow = affordable, Red glow = too expensive</div>
            </div>
        </div>

        <div class="control-panel">
            <h3 style="color: #4a9eff; margin-bottom: 20px; text-align: center;">Sound Controls</h3>
            <div class="sound-controls">
                <h4 style="color: #ffd700; margin-bottom: 10px;">Audio Settings</h4>
                
                <!-- Card Hover Sound -->
                <div class="sound-controls">
                    <span style="color: #4a9eff;">Card Hover Sound:</span>
                    <div class="hover-sound-controls">
                        <button class="arrow-button" onclick="previousCardHoverSound()">◀</button>
                        <select id="cardHoverSoundSelect" class="sound-dropdown" onchange="selectCardHoverSound()">
                            <!-- Options populated dynamically -->
                        </select>
                        <button class="arrow-button" onclick="nextCardHoverSound()">▶</button>
                    </div>
                </div>

                <!-- Grid Hover Sound -->
                <div class="sound-controls">
                    <span style="color: #4a9eff;">Grid Hover Sound:</span>
                    <div class="hover-sound-controls">
                        <button class="arrow-button" onclick="previousHoverSound()">◀</button>
                        <select id="hoverSoundSelect" class="sound-dropdown" onchange="selectHoverSound()">
                            <option value="0">Hover Sound 1</option>
                            <option value="1">Hover Sound 2</option>
                            <option value="2">Hover Sound 3</option>
                            <option value="3">Hover Sound 4</option>
                            <option value="4">Hover Sound 5</option>
                            <option value="5">Hover Sound 6</option>
                        </select>
                        <button class="arrow-button" onclick="nextHoverSound()">▶</button>
                    </div>
                </div>

                <!-- Place Sound -->
                <div class="sound-controls">
                    <span style="color: #4a9eff;">Place Sound:</span>
                    <div class="place-sound-controls">
                        <button class="arrow-button" onclick="previousPlaceSound()">◀</button>
                        <select id="placeSoundSelect" class="sound-dropdown" onchange="selectPlaceSound()">
                            <option value="0">Cush Dirt Thud 2</option>
                            <option value="1">Muffled Dirt 2</option>
                            <option value="2">Soft Dirt 2</option>
                            <option value="3">Muffled Dirt 3</option>
                            <option value="4">Soft Soil 2</option>
                            <option value="5">Soft Soil 3</option>
                            <option value="6">Gentle Dirt Thump 2</option>
                            <option value="7">Cush Dirt 3</option>
                        </select>
                        <button class="arrow-button" onclick="nextPlaceSound()">▶</button>
                    </div>
                </div>
                
                <!-- First Pop Sound Selector -->
                <div class="sound-selector">
                    <label style="color: #ff6b6b; font-size: 14px; margin-bottom: 8px; display: block;">First Pop Sound:</label>
                    <div class="first-pop-controls">
                        <button class="arrow-button" onclick="previousFirstPopSound()">◀</button>
                        <select class="sound-dropdown" id="firstPopSoundSelect" onchange="selectFirstPopSound()">
                            <!-- Options populated dynamically -->
                        </select>
                        <button class="arrow-button" onclick="nextFirstPopSound()">▶</button>
                    </div>
                </div>
                
                <!-- Second Pop Sound Selector -->
                <div class="sound-selector">
                    <label style="color: #ff9500; font-size: 14px; margin-bottom: 8px; display: block;">Second Pop Sound:</label>
                    <div class="second-pop-controls">
                        <button class="arrow-button" onclick="previousSecondPopSound()">◀</button>
                        <select class="sound-dropdown" id="secondPopSoundSelect" onchange="selectSecondPopSound()">
                            <!-- Options populated dynamically -->
                        </select>
                        <button class="arrow-button" onclick="nextSecondPopSound()">▶</button>
                    </div>
                </div>
                
                <!-- Merge Sound Selector -->
                <div class="sound-selector">
                    <label style="color: #ffaa00; font-size: 14px; margin-bottom: 8px; display: block;">Final Merge Sound:</label>
                    <div class="merge-sound-controls">
                        <button class="arrow-button" onclick="previousMergeSound()">◀</button>
                        <select class="sound-dropdown" id="mergeSoundSelect" onchange="selectMergeSound()">
                            <!-- Options populated dynamically -->
                        </select>
                        <button class="arrow-button" onclick="nextMergeSound()">▶</button>
                    </div>
                </div>

                <!-- Reroll Sound Selector -->
                <div class="sound-selector">
                    <label style="color: #4a9eff; font-size: 14px; margin-bottom: 8px; display: block;">Reroll Sound:</label>
                    <div class="reroll-sound-controls">
                        <button class="arrow-button" onclick="previousRerollSound()">◀</button>
                        <select class="sound-dropdown" id="rerollSoundSelect" onchange="selectRerollSound()">
                            <!-- Options populated dynamically -->
                        </select>
                        <button class="arrow-button" onclick="nextRerollSound()">▶</button>
                    </div>
                </div>

                <!-- Card Hover Cancel Sound Selector -->
                <div class="sound-selector">
                    <label style="color: #ff4444; font-size: 14px; margin-bottom: 8px; display: block;">Card Cancel Sound:</label>
                    <div class="card-hover-cancel-sound-controls">
                        <button class="arrow-button" onclick="previousCardHoverCancelSound()">◀</button>
                        <select class="sound-dropdown" id="cardHoverCancelSoundSelect" onchange="selectCardHoverCancelSound()">
                            <!-- Options populated dynamically -->
                        </select>
                        <button class="arrow-button" onclick="nextCardHoverCancelSound()">▶</button>
                    </div>
                </div>
                
                <!-- Test Buttons -->
                <button class="sound-test-button" onclick="testSelectedCardHoverSound()">Test Selected Card Hover Sound</button>
                <button class="sound-test-button" onclick="testSelectedHoverSound()">Test Selected Hover Sound</button>
                <button class="sound-test-button" onclick="testPlaceSound()">Test Selected Place Sound</button>
                <button class="sound-test-button" onclick="testFirstPopSound()">Test Selected First Pop Sound</button>
                <button class="sound-test-button" onclick="testSecondPopSound()">Test Selected Second Pop Sound</button>
                <button class="sound-test-button" onclick="testMergeSound()">Test Selected Merge Sound</button>
                <button class="sound-test-button" onclick="testRerollSound()">Test Selected Reroll Sound</button>
                <button class="sound-test-button" onclick="testCardHoverCancelSound()">Test Selected Cancel Sound</button>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let selectedBuildingType = null;
        let grid = [];
        let draggedBuilding = null;
        let isDragging = false;
        let dragPreview = null;
        let dragOffset = { x: 0, y: 0 };
        let currentResources = 1000; // Mock resource count
        let refreshCount = 5; // Number of refreshes available
        let maxRefreshCount = 5; // Maximum refreshes
        
        // Building types configuration
        const buildingTypes = {
            factory: {
                name: 'Factory',
                color: '#ffd700',
                icon: 'F',
                description: 'Produces resources',
                image: '../assets/cards/Factory.png',
                cost: 150
            },
            house: {
                name: 'House',
                color: '#808080',
                icon: 'H',
                description: 'Increases population',
                image: '../assets/cards/House.png',
                cost: 120
            },
            ammunition: {
                name: 'Ammunition',
                color: '#32cd32',
                icon: 'A',
                description: 'Produces ammunition',
                image: '../assets/cards/Ammo.png',
                cost: 400
            },
            laboratory: {
                name: 'Laboratory',
                color: '#4169e1',
                icon: 'L',
                description: 'Produces research points',
                image: '../assets/cards/Labotatory.png',
                cost: 300
            },
            barracks: {
                name: 'Barracks',
                color: '#ffa500',
                icon: 'B',
                description: 'Trains soldiers',
                image: '../assets/cards/movecardd.png',
                cost: 200
            }
        };

        // Sound system
        const hoverSounds = [
            'BuildingMoveGridHover (1).mp3',
            'BuildingMoveGridHover (2).mp3',
            'BuildingMoveGridHover (3).mp3',
            'BuildingMoveGridHover (4).mp3',
            'BuildingMoveGridHover (5).mp3',
            'BuildingMoveGridHover (6).mp3'
        ];

        const placeSounds = [
            '11L-cushioned_dirt_thud-1751461479209.mp3',      // cush dirt thud 2
            '11L-muffled_dirt_hit-1751461578547.mp3',         // muffled dirt 2
            '11L-soft_dirt_thump-1751458113598.mp3',          // soft dirt 2
            '11L-muffled_dirt_hit-1751461573708.mp3',         // muffled dirt 3
            '11L-soft_soil_thud-1751461297956.mp3',           // soft soil 2
            '11L-soft_soil_thud-1751461196165.mp3',           // soft soil 3
            '11L-gentle_dirt_thump-1751460915137.mp3',        // gentle dirt thump 2
            '11L-cushioned_dirt_thud-1751461465021.mp3'       // cush dirt 3
        ];

        // All merge pop sounds in one pool
        const mergePopSounds = [
            'SFX_Pop_Designed_Collect_Vacuum_1.wav',
            'SFX_Pop_Designed_Collect_Vacuum_2.wav',
            'SFX_Pop_Bottle_Tiny_1.wav',
            'SFX_Pop_Bottle_Tiny_2.wav',
            'SFX_Pop_Designed_Movement_1.wav',
            'SFX_Pop_Designed_Movement_2.wav',
            'SFX_Pop_Designed_Soft_2.wav',
            'SFX_Pop_Designed_Soft_3.wav',
            'SFX_Pop_Designed_Tube_Melodic_1.wav',
            'SFX_Pop_Designed_Tube_Melodic_2.wav',
            'SFX_Pop_Designed_Tube_Melodic_3.wav',
            'SFX_Pop_Designed_Tube_Melodic_4.wav',
            'SFX_Pop_Mouth_Soft_Muffled_1.wav',
            'SFX_Pop_Mouth_Soft_Muffled_2.wav',
            'SFX_Pop_Mouth_Soft_Muffled_3.wav',
            'SFX_Pop_Whistle_1.wav',
            'SFX_Pop_Whistle_2.wav',
            'SFX_Pop_Whistle_Juicy.wav'
        ];

        // Friendly names for the sounds
        const mergePopSoundNames = [
            'Vacuum Pop 1',
            'Vacuum Pop 2', 
            'Bottle Pop 1',
            'Bottle Pop 2',
            'Movement Pop 1',
            'Movement Pop 2',
            'Soft Pop 2',
            'Soft Pop 3',
            'Tube Melodic 1',
            'Tube Melodic 2',
            'Tube Melodic 3',
            'Tube Melodic 4',
            'Mouth Muffled 1',
            'Mouth Muffled 2',
            'Mouth Muffled 3',
            'Whistle Pop 1',
            'Whistle Pop 2',
            'Whistle Juicy'
        ];

        // All merge sounds in one pool
        const mergeSounds = [
            'merge.mp3',
            '11L-rolling_interlock_so-1751529288857.mp3',
            '11L-rolling_interlock_so-1751529274788.mp3',
            '11L-rolling_interlock_so-1751529224218.mp3',
            '11L-rolling_interlock_so-1751529221314.mp3',
            '11L-rolling_interlock_so-1751529157522.mp3',
            '11L-rolling_interlock_so-1751529055785.mp3',
            '11L-rolling_interlock_so-1751528981801.mp3',
            '11L-rolling_interlock_so-1751528978442.mp3',
            '11L-rolling_interlock_so-1751528966722.mp3',
            '11L-firm_3_card_shuffle-1751528951812.mp3',
            '11L-firm_3_card_shuffle-1751528937799.mp3',
            '11L-satisfying_plastic_r-1751528800539.mp3',
            '11L-tough_sequential_bri-1751528675540.mp3',
            '11L-firm_sequential_bric-1751528477098.mp3',
            '11L-firm_sequential_bric-1751528419421.mp3',
            '11L-firm_sequential_bric-1751528396882.mp3',
            '11L-soft_pop-1751551254997.mp3',
            '11L-soft_triple_pop-1751551249755.mp3',
            '11L-soft_triple_pop-1751551250227.mp3',
            '11L-soft_triple_pop-1751551250715.mp3',
            '11L-soft_triple_pop-1751551251127.mp3',
            '11L-soft_triple_pop-1751551259786.mp3',
            '11L-soft_triple_pop-1751551270768.mp3',
            '11L-soft_triple_pop-1751551282315.mp3',
            '11L-soft_triple_pop-1751551305215.mp3',
            '11L-soft_triple_pop-1751551315273.mp3',
            '11L-soft_triple_pop-1751551337433.mp3',
            '11L-soft_triple_pop-1751551359363.mp3',
            '11L-soft_triple_pop-1751551385612.mp3',
            '11L-soft_triple_pop-1751551429252.mp3',
            '11L-soft_triple_pop-1751551443533.mp3',
            '11L-soft_triple_pop-1751551456191.mp3'
        ];

        // Friendly names for merge sounds
        const mergeSoundNames = [
            'Original Merge',
            'Rolling Interlock 1',
            'Rolling Interlock 2',
            'Rolling Interlock 3',
            'Rolling Interlock 4',
            'Rolling Interlock 5',
            'Rolling Interlock 6',
            'Rolling Interlock 7',
            'Rolling Interlock 8',
            'Rolling Interlock 9',
            'Card Shuffle 1',
            'Card Shuffle 2',
            'Satisfying Plastic',
            'Tough Sequential',
            'Firm Sequential 1',
            'Firm Sequential 2',
            'Firm Sequential 3',
            'Soft Pop',
            'Soft Triple Pop 1',
            'Soft Triple Pop 2',
            'Soft Triple Pop 3',
            'Soft Triple Pop 4',
            'Soft Triple Pop 5',
            'Soft Triple Pop 6',
            'Soft Triple Pop 7',
            'Soft Triple Pop 8',
            'Soft Triple Pop 9',
            'Soft Triple Pop 10',
            'Soft Triple Pop 11',
            'Soft Triple Pop 12',
            'Soft Triple Pop 13',
            'Soft Triple Pop 14',
            'Soft Triple Pop 15'
        ];

        let selectedHoverSoundIndex = 5; // Default to Hover Sound 6
        let selectedPlaceSoundIndex = 2; // Default to first place sound
        let selectedFirstPopSoundIndex = 15; // Tube Melodic 1
        let selectedSecondPopSoundIndex = 16; // Tube Melodic 2
        let selectedMergeSoundIndex = 23; // Rolling Interlock 9 (index corrected)
        let currentHoverSound = null; // Track currently playing sound
        let shuffleModeEnabled = false; // Shuffle mode toggle
        let lastPlayedPlaceSoundIndex = -1; // Track last played sound to avoid repeats
        let draggingWrapper = null;

        // Card hover sound variables and functions
        const cardHoverSounds = [
            'BuildingMoveGridHover (1).mp3',
            'BuildingMoveGridHover (2).mp3',
            'BuildingMoveGridHover (3).mp3',
            'BuildingMoveGridHover (4).mp3',
            'BuildingMoveGridHover (5).mp3',
            'BuildingMoveGridHover (6).mp3',
            '11L-soft_card_sound-1751548317298.mp3',
            '11L-soft_card_sound-1751548320946.mp3',
            '11L-soft_card_sound-1751548322055.mp3',
            '11L-soft_card_sound-1751548326015.mp3',
            '11L-soft_card_sound-1751548337230.mp3',
            '11L-soft_card_sound-1751548348905.mp3',
            '11L-soft_short_card_soun-1751548366410.mp3',
            '11L-really_soft_card_sou-1751548415114.mp3',
            '11L-really_soft_card_sou-1751548424194.mp3',
            '11L-really_soft_card_sou-1751548431351.mp3',
            '11L-really_soft_card_sou-1751548444433.mp3',
            '11L-really_soft_card_sou-1751548455073.mp3',
            'SFX_Pop_Bottle_Tiny_1.wav',
            'SFX_Pop_Bottle_Tiny_2.wav',
            'SFX_Pop_Designed_Collect_Vacuum_1.wav',
            'SFX_Pop_Designed_Collect_Vacuum_2.wav',
            'SFX_Pop_Designed_Movement_1.wav',
            'SFX_Pop_Designed_Movement_2.wav',
            'SFX_Pop_Designed_Soft_2.wav',
            'SFX_Pop_Designed_Soft_3.wav',
            'SFX_Pop_Designed_Tube_Melodic_1.wav',
            'SFX_Pop_Designed_Tube_Melodic_2.wav',
            'SFX_Pop_Designed_Tube_Melodic_3.wav',
            'SFX_Pop_Designed_Tube_Melodic_4.wav',
            'SFX_Pop_Mouth_Soft_Muffled_1.wav',
            'SFX_Pop_Mouth_Soft_Muffled_2.wav',
            'SFX_Pop_Mouth_Soft_Muffled_3.wav',
            'SFX_Pop_Whistle_1.wav',
            'SFX_Pop_Whistle_2.wav',
            'SFX_Pop_Whistle_Juicy.wav'
        ];

        const cardHoverSoundNames = [
            'Grid Hover 1',
            'Grid Hover 2',
            'Grid Hover 3',
            'Grid Hover 4',
            'Grid Hover 5',
            'Grid Hover 6',
            'Soft Card 1',
            'Soft Card 2',
            'Soft Card 3',
            'Soft Card 4',
            'Soft Card 5',
            'Soft Card 6',
            'Soft Short Card',
            'Really Soft Card 1',
            'Really Soft Card 2',
            'Really Soft Card 3',
            'Really Soft Card 4',
            'Really Soft Card 5',
            'Bottle Pop 1',
            'Bottle Pop 2',
            'Vacuum Pop 1',
            'Vacuum Pop 2',
            'Movement Pop 1',
            'Movement Pop 2',
            'Soft Pop 2',
            'Soft Pop 3',
            'Tube Melodic 1',
            'Tube Melodic 2',
            'Tube Melodic 3',
            'Tube Melodic 4',
            'Muffled Pop 1',
            'Muffled Pop 2',
            'Muffled Pop 3',
            'Whistle Pop 1',
            'Whistle Pop 2',
            'Whistle Juicy'
        ];

        let selectedCardHoverSoundIndex = 15; // Grid Hover 2

        let currentCardHoverSound = null;

        function playCardHoverSound() {
            // Cancel any currently playing card hover sound
            if (currentCardHoverSound) {
                currentCardHoverSound.pause();
                currentCardHoverSound.currentTime = 0;
            }

            // Create and play new sound
            const soundPath = `../../sounds/cardhover/${cardHoverSounds[selectedCardHoverSoundIndex]}`;
            currentCardHoverSound = new Audio(soundPath);
            currentCardHoverSound.volume = 0.3;
            currentCardHoverSound.play().catch(e => console.error('Error playing card hover sound:', e));
        }

        // Update card hover event listeners
        function setupCardHoverListeners() {
            document.querySelectorAll('.card').forEach(card => {
                // Remove existing listeners to prevent duplicates
                card.removeEventListener('mouseenter', playCardHoverSound);
                card.removeEventListener('mouseleave', stopCardHoverSound);
                
                // Add new listeners
                card.addEventListener('mouseenter', playCardHoverSound);
                card.addEventListener('mouseleave', stopCardHoverSound);
            });
        }

        function stopCardHoverSound() {
            if (currentCardHoverSound) {
                currentCardHoverSound.pause();
                currentCardHoverSound.currentTime = 0;
            }
        }

        // Call setup when document is ready
        document.addEventListener('DOMContentLoaded', setupCardHoverListeners);

        // Also setup listeners for dynamically added cards
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.addedNodes.length) {
                    setupCardHoverListeners();
                }
            });
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        function testSelectedCardHoverSound() {
            playCardHoverSound();
        }

        function previousCardHoverSound() {
            selectedCardHoverSoundIndex = (selectedCardHoverSoundIndex - 1 + cardHoverSounds.length) % cardHoverSounds.length;
            updateCardHoverSoundDisplay();
            playCardHoverSound();
        }

        function nextCardHoverSound() {
            selectedCardHoverSoundIndex = (selectedCardHoverSoundIndex + 1) % cardHoverSounds.length;
            updateCardHoverSoundDisplay();
            playCardHoverSound();
        }

        function selectCardHoverSound() {
            const dropdown = document.getElementById('cardHoverSoundSelect');
            selectedCardHoverSoundIndex = parseInt(dropdown.value);
            playCardHoverSound();
        }

        function updateCardHoverSoundDisplay() {
            const dropdown = document.getElementById('cardHoverSoundSelect');
            if (dropdown) {
                dropdown.innerHTML = '';
                cardHoverSoundNames.forEach((name, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = name;
                    dropdown.appendChild(option);
                });
                dropdown.value = selectedCardHoverSoundIndex;
            }
        }

        function playHoverSound() {
            // Stop any currently playing hover sound immediately
            if (currentHoverSound) {
                currentHoverSound.pause();
                currentHoverSound.currentTime = 0;
            }
            
            // Create and play new sound immediately
            currentHoverSound = new Audio(`../../sounds/Hover/${hoverSounds[selectedHoverSoundIndex]}`);
            currentHoverSound.volume = 0.5;
            
            // Clear reference when sound ends
            currentHoverSound.addEventListener('ended', () => {
                currentHoverSound = null;
            });
            
            currentHoverSound.play().catch(e => console.log('Could not play hover sound:', e));
        }

        function playPlaceSound() {
            let soundIndexToPlay;
            
            if (shuffleModeEnabled) {
                // Generate random index, avoiding the last played sound
                do {
                    soundIndexToPlay = Math.floor(Math.random() * placeSounds.length);
                } while (soundIndexToPlay === lastPlayedPlaceSoundIndex && placeSounds.length > 1);
                
                lastPlayedPlaceSoundIndex = soundIndexToPlay;
            } else {
                soundIndexToPlay = selectedPlaceSoundIndex;
            }
            
            const sound = new Audio(`../../sounds/place/${placeSounds[soundIndexToPlay]}`);
            sound.volume = 0.7;
            sound.play().catch(e => console.log('Could not play place sound:', e));
        }

        function playMergeSound() {
            const soundFile = mergeSounds[selectedMergeSoundIndex];
            const sound = new Audio(`../../sounds/merge/${soundFile}`);
            sound.volume = 0.8;
            sound.play().catch(e => console.log('Could not play merge sound:', e));
        }

        function playFirstPopSound() {
            const soundFile = mergePopSounds[selectedFirstPopSoundIndex];
            const sound = new Audio(`../../sounds/mergepop/${soundFile}`);
            sound.volume = 0.5;
            sound.play().catch(e => console.log('Could not play first pop sound:', e));
        }

        function playSecondPopSound() {
            const soundFile = mergePopSounds[selectedSecondPopSoundIndex];
            const sound = new Audio(`../../sounds/mergepop/${soundFile}`);
            sound.volume = 0.5;
            sound.play().catch(e => console.log('Could not play second pop sound:', e));
        }

        // Legacy functions for backward compatibility (now use new system)
        function playVacuumSound1() {
            playFirstPopSound();
        }

        function playVacuumSound2() {
            playSecondPopSound();
        }

        // Sound test functions
        function testSelectedHoverSound() {
            playHoverSound();
        }

        function testPlaceSound() {
            playPlaceSound();
        }

        function testMergeSound() {
            playMergeSound();
        }

        function testFirstPopSound() {
            playFirstPopSound();
        }

        function testSecondPopSound() {
            playSecondPopSound();
        }

        // Hover sound selection functions
        function previousHoverSound() {
            selectedHoverSoundIndex = (selectedHoverSoundIndex - 1 + hoverSounds.length) % hoverSounds.length;
            updateHoverSoundDisplay();
            playHoverSound(); // Play the newly selected sound
        }

        function nextHoverSound() {
            selectedHoverSoundIndex = (selectedHoverSoundIndex + 1) % hoverSounds.length;
            updateHoverSoundDisplay();
            playHoverSound(); // Play the newly selected sound
        }

        function selectHoverSound() {
            const dropdown = document.getElementById('hoverSoundSelect');
            selectedHoverSoundIndex = parseInt(dropdown.value);
            playHoverSound(); // Play the newly selected sound
        }

        function updateHoverSoundDisplay() {
            const dropdown = document.getElementById('hoverSoundSelect');
            dropdown.value = selectedHoverSoundIndex;
        }

        // Place sound selection functions
        function previousPlaceSound() {
            selectedPlaceSoundIndex = (selectedPlaceSoundIndex - 1 + placeSounds.length) % placeSounds.length;
            updatePlaceSoundDisplay();
            playPlaceSound(); // Play the newly selected sound
        }

        function nextPlaceSound() {
            selectedPlaceSoundIndex = (selectedPlaceSoundIndex + 1) % placeSounds.length;
            updatePlaceSoundDisplay();
            playPlaceSound(); // Play the newly selected sound
        }

        function selectPlaceSound() {
            const dropdown = document.getElementById('placeSoundSelect');
            selectedPlaceSoundIndex = parseInt(dropdown.value);
            playPlaceSound(); // Play the newly selected sound
        }

        function updatePlaceSoundDisplay() {
            const dropdown = document.getElementById('placeSoundSelect');
            dropdown.value = selectedPlaceSoundIndex;
        }

        // Shuffle mode functions
        function toggleShuffle() {
            shuffleModeEnabled = !shuffleModeEnabled;
            updateShuffleDisplay();
            
            // Reset last played sound when toggling
            lastPlayedPlaceSoundIndex = -1;
            
            // Play a sound to demonstrate the new mode
            playPlaceSound();
        }

        function updateShuffleDisplay() {
            const shuffleButton = document.getElementById('shuffleToggle');
            const shuffleText = shuffleButton.querySelector('.shuffle-text');
            
            if (shuffleModeEnabled) {
                shuffleButton.classList.add('active');
                shuffleText.textContent = 'Shuffle: ON';
            } else {
                shuffleButton.classList.remove('active');
                shuffleText.textContent = 'Shuffle: OFF';
            }
        }

        // First pop sound selection functions
        function previousFirstPopSound() {
            selectedFirstPopSoundIndex = (selectedFirstPopSoundIndex - 1 + mergePopSounds.length) % mergePopSounds.length;
            updateFirstPopSoundDisplay();
            playFirstPopSound(); // Play the newly selected sound
        }

        function nextFirstPopSound() {
            selectedFirstPopSoundIndex = (selectedFirstPopSoundIndex + 1) % mergePopSounds.length;
            updateFirstPopSoundDisplay();
            playFirstPopSound(); // Play the newly selected sound
        }

        function selectFirstPopSound() {
            const dropdown = document.getElementById('firstPopSoundSelect');
            selectedFirstPopSoundIndex = parseInt(dropdown.value);
            playFirstPopSound(); // Play the newly selected sound
        }

        function updateFirstPopSoundDisplay() {
            const dropdown = document.getElementById('firstPopSoundSelect');
            if (dropdown) {
                // Clear and repopulate options
                dropdown.innerHTML = '';
                mergePopSoundNames.forEach((name, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = name;
                    dropdown.appendChild(option);
                });
                dropdown.value = selectedFirstPopSoundIndex;
            }
        }

        // Second pop sound selection functions
        function previousSecondPopSound() {
            selectedSecondPopSoundIndex = (selectedSecondPopSoundIndex - 1 + mergePopSounds.length) % mergePopSounds.length;
            updateSecondPopSoundDisplay();
            playSecondPopSound(); // Play the newly selected sound
        }

        function nextSecondPopSound() {
            selectedSecondPopSoundIndex = (selectedSecondPopSoundIndex + 1) % mergePopSounds.length;
            updateSecondPopSoundDisplay();
            playSecondPopSound(); // Play the newly selected sound
        }

        function selectSecondPopSound() {
            const dropdown = document.getElementById('secondPopSoundSelect');
            selectedSecondPopSoundIndex = parseInt(dropdown.value);
            playSecondPopSound(); // Play the newly selected sound
        }

        function updateSecondPopSoundDisplay() {
            const dropdown = document.getElementById('secondPopSoundSelect');
            if (dropdown) {
                // Clear and repopulate options
                dropdown.innerHTML = '';
                mergePopSoundNames.forEach((name, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = name;
                    dropdown.appendChild(option);
                });
                dropdown.value = selectedSecondPopSoundIndex;
            }
        }

        // Merge sound selection functions
        function previousMergeSound() {
            selectedMergeSoundIndex = (selectedMergeSoundIndex - 1 + mergeSounds.length) % mergeSounds.length;
            updateMergeSoundDisplay();
            playMergeSound(); // Play the newly selected sound
        }

        function nextMergeSound() {
            selectedMergeSoundIndex = (selectedMergeSoundIndex + 1) % mergeSounds.length;
            updateMergeSoundDisplay();
            playMergeSound(); // Play the newly selected sound
        }

        function selectMergeSound() {
            const dropdown = document.getElementById('mergeSoundSelect');
            selectedMergeSoundIndex = parseInt(dropdown.value);
            playMergeSound(); // Play the newly selected sound
        }

        function updateMergeSoundDisplay() {
            const dropdown = document.getElementById('mergeSoundSelect');
            if (dropdown) {
                // Clear and repopulate options
                dropdown.innerHTML = '';
                mergeSoundNames.forEach((name, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = name;
                    dropdown.appendChild(option);
                });
                dropdown.value = selectedMergeSoundIndex;
            }
        }

        // Reroll sound variables and functions
        const rerollSounds = [
            '11L-firm_3_card_shuffle-1751528937799.mp3',
            '11L-firm_3_card_shuffle-1751528951812.mp3',
            '11L-soft_card_sound-1751548317298.mp3',
            '11L-soft_card_sound-1751548320946.mp3',
            '11L-soft_card_sound-1751548322055.mp3',
            '11L-soft_card_sound-1751548326015.mp3',
            '11L-soft_card_sound-1751548337230.mp3',
            '11L-soft_card_sound-1751548348905.mp3',
            '11L-soft_short_card_soun-1751548366410.mp3',
            '11L-really_soft_card_sou-1751548415114.mp3',
            '11L-really_soft_card_sou-1751548424194.mp3',
            '11L-really_soft_card_sou-1751548431351.mp3',
            '11L-really_soft_card_sou-1751548444433.mp3',
            '11L-really_soft_card_sou-1751548455073.mp3'
        ];

        const rerollSoundNames = [
            'Firm Card Shuffle 1',
            'Firm Card Shuffle 2',
            'Soft Card Sound 1',
            'Soft Card Sound 2',
            'Soft Card Sound 3',
            'Soft Card Sound 4',
            'Soft Card Sound 5',
            'Soft Card Sound 6',
            'Soft Short Card',
            'Really Soft Card 1',
            'Really Soft Card 2',
            'Really Soft Card 3',
            'Really Soft Card 4',
            'Really Soft Card 5'
        ];

        let selectedRerollSoundIndex = 7; // Default to first firm card shuffle

        function playRerollSound() {
            const soundFile = rerollSounds[selectedRerollSoundIndex];
            const sound = new Audio(`../../sounds/reroll/${soundFile}`);
            sound.volume = 0.3;
            sound.play().catch(e => console.log('Could not play reroll sound:', e));
        }

        function testRerollSound() {
            playRerollSound();
        }

        function previousRerollSound() {
            selectedRerollSoundIndex = (selectedRerollSoundIndex - 1 + rerollSounds.length) % rerollSounds.length;
            updateRerollSoundDisplay();
            playRerollSound();
        }

        function nextRerollSound() {
            selectedRerollSoundIndex = (selectedRerollSoundIndex + 1) % rerollSounds.length;
            updateRerollSoundDisplay();
            playRerollSound();
        }

        function selectRerollSound() {
            const dropdown = document.getElementById('rerollSoundSelect');
            selectedRerollSoundIndex = parseInt(dropdown.value);
            playRerollSound();
        }

        function updateRerollSoundDisplay() {
            const dropdown = document.getElementById('rerollSoundSelect');
            if (dropdown) {
                dropdown.innerHTML = '';
                rerollSoundNames.forEach((name, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = name;
                    dropdown.appendChild(option);
                });
                dropdown.value = selectedRerollSoundIndex;
            }
        }

        // Card Hover Cancel sound variables and functions
        const cardHoverCancelSounds = [
            'BuildingMoveGridHover (1).mp3',
            'BuildingMoveGridHover (2).mp3',
            'BuildingMoveGridHover (3).mp3',
            'BuildingMoveGridHover (4).mp3',
            'BuildingMoveGridHover (5).mp3',
            'BuildingMoveGridHover (6).mp3'
        ];

        const cardHoverCancelSoundNames = [
            'Cancel Sound 1',
            'Cancel Sound 2',
            'Cancel Sound 3',
            'Cancel Sound 4',
            'Cancel Sound 5',
            'Cancel Sound 6'
        ];

        let selectedCardHoverCancelSoundIndex = 0;

        function playCardHoverCancelSound() {
            const soundFile = cardHoverCancelSounds[selectedCardHoverCancelSoundIndex];
            const sound = new Audio(`../../sounds/cardhovercancel/${soundFile}`);
            sound.volume = 0.3;
            sound.play().catch(e => console.log('Could not play card hover cancel sound:', e));
        }

        function testCardHoverCancelSound() {
            playCardHoverCancelSound();
        }

        function previousCardHoverCancelSound() {
            selectedCardHoverCancelSoundIndex = (selectedCardHoverCancelSoundIndex - 1 + cardHoverCancelSounds.length) % cardHoverCancelSounds.length;
            updateCardHoverCancelSoundDisplay();
            playCardHoverCancelSound();
        }

        function nextCardHoverCancelSound() {
            selectedCardHoverCancelSoundIndex = (selectedCardHoverCancelSoundIndex + 1) % cardHoverCancelSounds.length;
            updateCardHoverCancelSoundDisplay();
            playCardHoverCancelSound();
        }

        function selectCardHoverCancelSound() {
            const dropdown = document.getElementById('cardHoverCancelSoundSelect');
            selectedCardHoverCancelSoundIndex = parseInt(dropdown.value);
            playCardHoverCancelSound();
        }

        function updateCardHoverCancelSoundDisplay() {
            const dropdown = document.getElementById('cardHoverCancelSoundSelect');
            if (dropdown) {
                dropdown.innerHTML = '';
                cardHoverCancelSoundNames.forEach((name, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = name;
                    dropdown.appendChild(option);
                });
                dropdown.value = selectedCardHoverCancelSoundIndex;
            }
        }

        // Initialize grid
        function initializeGrid() {
            const gridElement = document.getElementById('gameGrid');
            grid = [];
            
            for (let i = 0; i < 25; i++) {
                const row = Math.floor(i / 5);
                const col = i % 5;
                
                if (!grid[row]) grid[row] = [];
                grid[row][col] = null;
                
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.row = row;
                cell.dataset.col = col;
                
                cell.addEventListener('mouseenter', handleCellHover);
                cell.addEventListener('mouseleave', handleCellLeave);
                cell.addEventListener('click', handleCellClick);
                
                gridElement.appendChild(cell);
            }
        }

        // Handle cell interactions
        function handleCellHover(event) {
            if (selectedBuildingType && !grid[event.target.dataset.row][event.target.dataset.col]) {
                event.target.classList.add('snap-target');
                playHoverSound();
            }
        }

        function handleCellLeave(event) {
            event.target.classList.remove('snap-target');
        }

        function handleCellClick(event) {
            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);
            
            if (selectedBuildingType && !grid[row][col]) {
                placeBuilding(row, col, selectedBuildingType, 1);
                playPlaceSound();
                checkForMerges(row, col);
            }
        }

        // Building placement
        function placeBuilding(row, col, type, level) {
            const building = {
                type: type,
                level: level,
                id: Date.now() + Math.random()
            };
            
            grid[row][col] = building;
            updateGridDisplay();
        }

        // Update grid visual display
        function updateGridDisplay() {
            const cells = document.querySelectorAll('.grid-cell');
            
            cells.forEach((cell, index) => {
                const row = Math.floor(index / 5);
                const col = index % 5;
                const building = grid[row][col];
                
                // Clear previous building
                const existingBuilding = cell.querySelector('.building');
                if (existingBuilding) {
                    // Clear any animation classes before removing
                    existingBuilding.classList.remove('moving-to-merge', 'bounce-merge');
                    existingBuilding.remove();
                }
                
                // Add new building if exists
                if (building) {
                    const buildingElement = document.createElement('div');
                    buildingElement.className = `building ${building.type}`;
                    buildingElement.innerHTML = `
                        ${buildingTypes[building.type].icon}
                        <div class="building-level">${building.level}</div>
                    `;
                    cell.appendChild(buildingElement);
                }
            });
        }

        // Merge detection and handling
        function checkForMerges(row, col) {
            const building = grid[row][col];
            if (!building) return;
            
            // Check for horizontal merges (3 in a row)
            const horizontalMerge = checkHorizontalMerge(row, col, building.type, building.level);
            if (horizontalMerge) {
                performMerge(horizontalMerge, building.type, building.level, row, col);
                return;
            }
            
            // Check for vertical merges (3 in a column)
            const verticalMerge = checkVerticalMerge(row, col, building.type, building.level);
            if (verticalMerge) {
                performMerge(verticalMerge, building.type, building.level, row, col);
                return;
            }
            
            // Check for L-shaped merges
            const lShapeMerge = checkLShapeMerge(row, col, building.type, building.level);
            if (lShapeMerge) {
                performMerge(lShapeMerge, building.type, building.level, row, col);
                return;
            }
        }

        function checkHorizontalMerge(row, col, type, level) {
            // Check all possible horizontal 3-in-a-row patterns that include this position
            for (let startCol = Math.max(0, col - 2); startCol <= Math.min(2, col); startCol++) {
                if (startCol + 2 >= 5) break; // Stay within grid bounds
                
                const positions = [
                    {row, col: startCol},
                    {row, col: startCol + 1},
                    {row, col: startCol + 2}
                ];
                
                // Check if all 3 positions have matching buildings
                const allMatch = positions.every(pos => {
                    const building = grid[pos.row][pos.col];
                    return building && building.type === type && building.level === level;
                });
                
                if (allMatch) {
                    return positions;
                }
            }
            return null;
        }

        function checkVerticalMerge(row, col, type, level) {
            // Check all possible vertical 3-in-a-row patterns that include this position
            for (let startRow = Math.max(0, row - 2); startRow <= Math.min(2, row); startRow++) {
                if (startRow + 2 >= 5) break; // Stay within grid bounds
                
                const positions = [
                    {row: startRow, col},
                    {row: startRow + 1, col},
                    {row: startRow + 2, col}
                ];
                
                // Check if all 3 positions have matching buildings
                const allMatch = positions.every(pos => {
                    const building = grid[pos.row][pos.col];
                    return building && building.type === type && building.level === level;
                });
                
                if (allMatch) {
                    return positions;
                }
            }
            return null;
        }

        function checkLShapeMerge(row, col, type, level) {
            // Define the 4 basic L-shape orientations
            // Each L-shape is defined by its corner position and two extensions
            const lShapeTemplates = [
                // L-shape: corner at (0,0), extends right and down
                [[0,0], [0,1], [1,0]],
                // L-shape: corner at (0,1), extends left and down  
                [[0,0], [0,1], [1,1]],
                // L-shape: corner at (1,0), extends right and up
                [[0,0], [1,0], [1,1]],
                // L-shape: corner at (1,1), extends left and up
                [[0,1], [1,0], [1,1]]
            ];
            
            // For each L-shape template, try placing it at different positions
            // so that the placed building (row, col) is part of the pattern
            for (const template of lShapeTemplates) {
                for (let i = 0; i < 3; i++) {
                    // Try making each position in the template be the placed building
                    const offsetRow = row - template[i][0];
                    const offsetCol = col - template[i][1];
                    
                    // Calculate actual positions for this L-shape
                    const positions = template.map(([r, c]) => ({
                        row: r + offsetRow,
                        col: c + offsetCol
                    }));
                    
                    // Check if all positions are within grid bounds
                    const inBounds = positions.every(pos => 
                        pos.row >= 0 && pos.row < 5 && pos.col >= 0 && pos.col < 5
                    );
                    
                    if (inBounds) {
                        // Check if all 3 positions have matching buildings
                        const allMatch = positions.every(pos => {
                            const building = grid[pos.row][pos.col];
                            return building && building.type === type && building.level === level;
                        });
                        
                        if (allMatch) {
                            return positions;
                        }
                    }
                }
            }
            return null;
        }

        function performMerge(positions, type, level, lastPlacedRow, lastPlacedCol) {
            // Show merge indicator
            showMergeIndicator(positions);
            
            setTimeout(() => {
                // Animate buildings moving to merge position
                animateMergeMovement(positions, lastPlacedRow, lastPlacedCol, type, level);
            }, 500);
        }

        function animateMergeMovement(positions, lastPlacedRow, lastPlacedCol, type, level) {
            // Find buildings that need to move (not the last placed one)
            const movingBuildings = positions.filter(pos => 
                pos.row !== lastPlacedRow || pos.col !== lastPlacedCol
            );
            
            // Sort by distance to target (closest first)
            movingBuildings.sort((a, b) => {
                const distA = Math.abs(a.row - lastPlacedRow) + Math.abs(a.col - lastPlacedCol);
                const distB = Math.abs(b.row - lastPlacedRow) + Math.abs(b.col - lastPlacedCol);
                return distA - distB;
            });
            
            // Get target cell position
            const targetCellIndex = lastPlacedRow * 5 + lastPlacedCol;
            const targetCell = document.querySelectorAll('.grid-cell')[targetCellIndex];
            const targetRect = targetCell.getBoundingClientRect();
            
            // Animate buildings sequentially
            let animationDelay = 0;
            const animationPromises = [];
            
            movingBuildings.forEach((pos, index) => {
                const promise = new Promise((resolve) => {
                    setTimeout(() => {
                        const cellIndex = pos.row * 5 + pos.col;
                        const cell = document.querySelectorAll('.grid-cell')[cellIndex];
                        const building = cell.querySelector('.building');
                        
                        if (building && cell) {
                            // Get current position
                            const currentRect = cell.getBoundingClientRect();
                            
                            // Create a clone for animation
                            const clone = building.cloneNode(true);
                            clone.classList.add('moving-building');
                            clone.classList.remove('moving-to-merge', 'bounce-merge'); // Clean up any existing classes
                            clone.style.left = currentRect.left + 'px';
                            clone.style.top = currentRect.top + 'px';
                            clone.style.width = currentRect.width + 'px';
                            clone.style.height = currentRect.height + 'px';
                            
                            document.body.appendChild(clone);
                            
                            // Hide original immediately
                            building.style.opacity = '0';
                            
                            // Animate to center of target cell
                            setTimeout(() => {
                                const targetCenterX = targetRect.left + targetRect.width / 2 - currentRect.width / 2;
                                const targetCenterY = targetRect.top + targetRect.height / 2 - currentRect.height / 2;
                                
                                clone.style.left = targetCenterX + 'px';
                                clone.style.top = targetCenterY + 'px';
                                clone.style.transform = 'scale(0.1)';
                                clone.style.opacity = '0';
                                
                                // Play vacuum sounds when animation starts moving
                                if (index === 0) {
                                    // First building (closest) - play vacuum sound 1
                                    playVacuumSound1();
                                } else if (index === 1) {
                                    // Second building - play vacuum sound 2
                                    playVacuumSound2();
                                }
                            }, 50);
                            
                            // Clean up after animation completes
                            setTimeout(() => {
                                if (document.body.contains(clone)) {
                                    document.body.removeChild(clone);
                                }
                                // Clear the original cell
                                cell.innerHTML = '';
                                resolve();
                            }, 750);
                        } else {
                            resolve();
                        }
                    }, animationDelay);
                });
                
                animationPromises.push(promise);
                animationDelay += 200; // Stagger animations by 200ms
            });
            
            // Wait for all animations to complete, then finish merge
            Promise.all(animationPromises).then(() => {
                completeMerge(positions, lastPlacedRow, lastPlacedCol, type, level);
                
            });
        }

        function completeMerge(positions, lastPlacedRow, lastPlacedCol, type, level) {
            // Clear all merged buildings from grid state (UI already cleared during animation)
            positions.forEach(pos => {
                grid[pos.row][pos.col] = null;
            });
            
            // Play merge sound immediately when merge completes
            playMergeSound();
            
            // Place new higher level building at the LAST-PLACED position
            placeBuilding(lastPlacedRow, lastPlacedCol, type, level + 1);
            
            // Add bounce animation to the merged building immediately
            const cellIndex = lastPlacedRow * 5 + lastPlacedCol;
            const cell = document.querySelectorAll('.grid-cell')[cellIndex];
            const mergedBuilding = cell.querySelector('.building');
            
            if (mergedBuilding) {
                mergedBuilding.classList.add('bounce-merge');
                
                // Remove bounce class after animation
                setTimeout(() => {
                    mergedBuilding.classList.remove('bounce-merge');
                }, 600);
            }
            
            // Check for chain merges at the last-placed position
            setTimeout(() => {
                checkForMerges(lastPlacedRow, lastPlacedCol);
            }, 800);
        }

        function showMergeIndicator(positions) {
            positions.forEach(pos => {
                const cellIndex = pos.row * 5 + pos.col;
                const cell = document.querySelectorAll('.grid-cell')[cellIndex];
                const indicator = document.createElement('div');
                indicator.className = 'merge-indicator';
                cell.appendChild(indicator);
                
                setTimeout(() => {
                    if (indicator.parentNode) {
                        indicator.remove();
                    }
                }, 1800); // Extended to cover the full animation sequence
            });
        }

        // Initialize building cards
        function initializeBuildingCards() {
            // Initial load without decrementing refresh count
            loadRandomBuildingCards();
        }

        function loadRandomBuildingCards() {
            // Re-initialize building cards with new random selection
            const cardsContainer = document.getElementById('buildingCards');
            cardsContainer.innerHTML = '';
            
            // Get random building types
            const buildingTypeKeys = Object.keys(buildingTypes);
            const numberOfCards = 3; // Show 3 cards instead of 5
            
            for (let i = 0; i < numberOfCards; i++) {
                const randomType = buildingTypeKeys[Math.floor(Math.random() * buildingTypeKeys.length)];
                const config = buildingTypes[randomType];
                
                const cardWrapper = document.createElement('div');
                cardWrapper.className = 'card-wrapper';
                cardWrapper.style.setProperty('--index', i);
                cardWrapper.style.setProperty('--total', numberOfCards);

                // Add hover sound to wrapper
                cardWrapper.addEventListener('mouseenter', playCardHoverSound);

                const card = document.createElement('img');
                card.className = 'building-card-img';
                card.src = config.image;
                card.alt = config.name;
                card.dataset.type = randomType;
                card.dataset.cost = config.cost;
                
                // Check affordability
                const affordable = currentResources >= config.cost;
                card.classList.add(affordable ? 'affordable' : 'unaffordable');
                
                cardWrapper.appendChild(card);
                
                // Add event listeners
                if (affordable) {
                    card.addEventListener('mousedown', (e) => startDrag(e, randomType, config));
                    card.addEventListener('dragstart', (e) => e.preventDefault());
                }
                
                card.addEventListener('click', () => {
                    if (affordable) {
                        selectBuildingType(randomType, card);
                    }
                });
                
                cardsContainer.appendChild(cardWrapper);
            }
        }

        function selectBuildingType(type, cardElement) {
            // Remove previous selection
            document.querySelectorAll('.building-card-img').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Set new selection
            selectedBuildingType = type;
            cardElement.classList.add('selected');
        }

        // Drag and Drop Functions
        function startDrag(e, type, config) {
            if (e.button !== 0) return;
            isDragging = true;
            draggedBuilding = { type, config };

            const card = e.target;
            const wrapper = card.parentElement;
            draggingWrapper = wrapper;

            // Hide the original immediately
            wrapper.style.visibility = 'hidden';

            const rect = card.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;

            card.classList.add('dragging');
            createDragPreview(card, e.clientX - dragOffset.x, e.clientY - dragOffset.y);

            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);
            e.preventDefault();
        }

        function handleDragMove(e) {
            if (!isDragging || !dragPreview) return;

            dragPreview.style.left = (e.clientX - dragOffset.x) + 'px';
            dragPreview.style.top = (e.clientY - dragOffset.y) + 'px';

            const el = document.elementFromPoint(e.clientX, e.clientY);
            const overCell = el && el.classList.contains('grid-cell');

            // Scale preview when over grid instead of hiding
            dragPreview.style.transform = overCell ? 'scale(0.7)' : 'scale(1)';

            document.querySelectorAll('.grid-cell').forEach(cell => cell.classList.remove('snap-target'));
            if (overCell) {
                const r = +el.dataset.row, c = +el.dataset.col;
                if (!grid[r][c]) {
                    el.classList.add('snap-target');
                    playHoverSound();
                }
            }
        }

        function handleDragEnd(e) {
            if (!isDragging) return;
            isDragging = false;

            if (dragPreview) {
                dragPreview.remove();
                dragPreview = null;
            }

            const card = document.querySelector('.building-card-img.dragging');
            if (card) card.classList.remove('dragging');

            if (draggingWrapper) {
                draggingWrapper.style.visibility = '';
                draggingWrapper = null;
            }

            document.querySelectorAll('.grid-cell').forEach(cell => cell.classList.remove('snap-target'));

            const el = document.elementFromPoint(e.clientX, e.clientY);
            if (el && el.classList.contains('grid-cell')) {
                const r = +el.dataset.row, c = +el.dataset.col;
                if (!grid[r][c] && draggedBuilding) {
                    placeBuilding(r, c, draggedBuilding.type, 1);
                    playPlaceSound();
                    checkForMerges(r, c);
                } else {
                    // Play cancel sound when dropping on an occupied cell
                    playCardHoverCancelSound();
                }
            } else {
                // Play cancel sound when dropping outside the grid
                playCardHoverCancelSound();
            }

            draggedBuilding = null;
            document.removeEventListener('mousemove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd);
        }

        function createDragPreview(card, x, y) {
            dragPreview = document.createElement('img');
            dragPreview.className = 'drag-preview';
            dragPreview.src = card.src;
            dragPreview.style.left = x + 'px';
            dragPreview.style.top = y + 'px';
            dragPreview.style.width = card.offsetWidth + 'px';
            dragPreview.style.height = card.offsetHeight + 'px';
            dragPreview.style.transform = 'scale(1)';  // Initialize at full scale
            dragPreview.style.transition = 'transform 0.1s ease';  // Smooth transition
            document.body.appendChild(dragPreview);
        }

        function updateResourceDisplay() {
            // Update resource counter
            const resourceCounter = document.getElementById('resourceCount');
            if (resourceCounter) {
                resourceCounter.textContent = currentResources;
            }
            
            // Update refresh count
            const refreshCounter = document.getElementById('refresh-count');
            if (refreshCounter) {
                refreshCounter.textContent = `${refreshCount}/${maxRefreshCount}`;
            }
            
            // Update affordability of cards
            document.querySelectorAll('.building-card-img').forEach(card => {
                const cost = parseInt(card.dataset.cost);
                const affordable = currentResources >= cost;
                
                card.classList.remove('affordable', 'unaffordable');
                card.classList.add(affordable ? 'affordable' : 'unaffordable');
            });
        }

        // Refresh Cards Functionality
        function refreshBuildingCards() {
            if (refreshCount <= 0) {
                console.log('No refreshes remaining');
                return;
            }
            
            refreshCount--;
            updateResourceDisplay();
            
            // Play reroll sound
            playRerollSound();
            
            // Load new random cards
            loadRandomBuildingCards();
            
            // Animate refresh button
            const refreshBtn = document.getElementById('refresh-cards-btn');
            if (refreshBtn) {
                refreshBtn.style.transform = 'rotate(360deg) scale(1.2)';
                setTimeout(() => {
                    refreshBtn.style.transform = '';
                }, 500);
                
                // Disable button if no refreshes left
                if (refreshCount <= 0) {
                    refreshBtn.style.opacity = '0.5';
                    refreshBtn.style.cursor = 'not-allowed';
                    refreshBtn.disabled = true;
                }
            }
        }

        // Initialize the game
        function initialize() {
            initializeGrid();
            initializeBuildingCards();
            updateCardHoverSoundDisplay(); // Initialize card hover sound display
            
            // Select first building type by default
            const firstCard = document.querySelector('.building-card-img');
            if (firstCard) {
                selectBuildingType(firstCard.dataset.type, firstCard);
            }
            
            // Initialize resource display
            updateResourceDisplay();
            
            // Add refresh button event listener
            const refreshBtn = document.getElementById('refresh-cards-btn');
            if (refreshBtn) {
                refreshBtn.addEventListener('click', refreshBuildingCards);
            }
            
            // Initialize sound dropdown displays
            updateHoverSoundDisplay();
            updatePlaceSoundDisplay();
            updateFirstPopSoundDisplay();
            updateSecondPopSoundDisplay();
            updateMergeSoundDisplay();
            updateRerollSoundDisplay();
            updateCardHoverCancelSoundDisplay();
            updateShuffleDisplay();
            
            console.log('Grid test initialized!');
        }

        // Start the game when page loads
        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html> 
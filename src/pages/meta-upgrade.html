<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Defense Z - Meta Upgrade System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        /* Background Game View */
        .game-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('../assets/images/bg-cdz.jpg') center/cover no-repeat;
            filter: blur(2px);
            z-index: 1;
        }

        /* Modal Overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Main Modal Container */
        .meta-upgrade-modal {
            width: 90%;
            height: 85%;
            background: #2C2C2C;
            border: 2px solid #FF8C00;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 140, 0, 0.3);
            display: flex;
            flex-direction: column;
            position: relative;
            animation: slideIn 0.4s ease-out;
            padding: 20px;
        }

        @keyframes slideIn {
            from { transform: scale(0.8) translateY(-50px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        /* Close Button */
        .close-button {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #FF8C00;
            font-size: 28px;
            cursor: pointer;
            z-index: 10;
            transition: color 0.2s;
        }

        .close-button:hover {
            color: #FFA500;
            transform: scale(1.1);
        }

        /* Top Section with RP Display Only */
        .top-section {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            padding: 0 20px;
        }

        /* Research Points Display */
        .rp-display {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            background: rgba(65, 105, 225, 0.15);
            border: 1px solid rgba(65, 105, 225, 0.3);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .rp-display:hover {
            background: rgba(65, 105, 225, 0.2);
            border-color: rgba(65, 105, 225, 0.5);
        }

        .rp-icon {
            font-size: 24px;
            color: #4169E1;
            filter: drop-shadow(0 0 8px rgba(65, 105, 225, 0.6));
        }

        .rp-content {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .rp-amount {
            font-size: 24px;
            font-weight: bold;
            color: #4169E1;
            text-shadow: 0 0 10px rgba(65, 105, 225, 0.5);
            line-height: 1;
        }

        .rp-label {
            font-size: 12px;
            color: #888;
            font-weight: normal;
            line-height: 1;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* All Trees Container */
        .all-trees-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }

        .all-trees-container:active {
            cursor: grabbing;
        }

        .all-trees-container.panning {
            cursor: grabbing;
        }

        /* Trees Content Wrapper */
        .trees-content-wrapper {
            position: absolute;
            width: 2000px;
            height: 2000px;
            transition: transform 0.1s ease-out;
            transform-origin: center center;
            user-select: none;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        /* Horizontal Layout Styles */
        .trees-content-wrapper.horizontal {
            position: relative;
            width: auto;
            height: auto;
            left: auto;
            top: auto;
            transform: none;
            display: flex;
            gap: 30px;
            padding: 20px;
            transform-origin: 0 0;
        }

        .horizontal .main-category-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 250px;
            flex-shrink: 0;
            margin-right: 40px;
            transition: all 0.3s ease;
        }

        .horizontal .main-category-header {
            font-size: 20px;
            font-weight: bold;
            color: #FFA500;
            margin-bottom: 20px;
            text-align: center;
            border-bottom: 3px solid #FFA500;
            padding-bottom: 8px;
            width: 100%;
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .horizontal .sub-categories-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .horizontal .sub-tree-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 180px;
            flex-shrink: 0;
            transition: all 0.3s ease;
        }

        .horizontal .sub-tree-header {
            font-size: 14px;
            font-weight: bold;
            color: #FF8C00;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid #FF8C00;
            padding-bottom: 5px;
            width: 100%;
            white-space: nowrap;
        }

        .horizontal .upgrade-path {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 50px;
            position: relative;
        }

        .horizontal .upgrade-node {
            position: relative;
            width: 60px;
            height: 60px;
        }

        .horizontal .connection-line {
            position: absolute;
            width: 4px;
            background: #666;
            left: 50%;
            transform: translateX(-50%);
            transition: background 0.3s;
            z-index: 1;
            border-radius: 2px;
        }

        /* Hide radial elements in horizontal mode */
        .horizontal .central-hub,
        .horizontal .radial-branch,
        .horizontal .main-category-node,
        .horizontal .sub-category-node,
        .horizontal .radial-connection {
            display: none;
        }

        /* Central Hub */
        .central-hub {
            position: absolute;
            width: 120px;
            height: 120px;
            background: linear-gradient(135deg, #FF8C00, #FFA500);
            border: 4px solid #FFB347;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 30px rgba(255, 140, 0, 0.6);
            z-index: 20;
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-align: center;
        }

        .central-hub-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        /* Layout Toggle */
        .layout-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #FF8C00;
            border-radius: 8px;
            overflow: hidden;
            z-index: 10;
        }

        .toggle-option {
            padding: 10px 15px;
            background: transparent;
            border: none;
            color: #FF8C00;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .toggle-option:hover {
            background: rgba(255, 140, 0, 0.2);
        }

        .toggle-option.active {
            background: #FF8C00;
            color: white;
        }

        .toggle-icon {
            font-size: 14px;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }

        .zoom-button {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #FF8C00;
            border-radius: 8px;
            color: #FF8C00;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .zoom-button:hover {
            background: rgba(255, 140, 0, 0.2);
            transform: scale(1.1);
        }

        .zoom-indicator {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #FF8C00;
            border-radius: 4px;
            color: #FF8C00;
            font-size: 12px;
            padding: 5px 8px;
            text-align: center;
            margin-top: 5px;
        }

        /* Radial Branch Container */
        .radial-branch {
            position: absolute;
            transform-origin: center center;
        }

        /* Main Category Node */
        .main-category-node {
            position: absolute;
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #FF8C00, #FFA500);
            border: 3px solid #FFB347;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.4);
            z-index: 15;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .main-category-node:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(255, 140, 0, 0.6);
        }

        .main-category-icon {
            font-size: 18px;
            margin-bottom: 3px;
        }

        .main-category-title {
            font-size: 9px;
            line-height: 1;
        }

        /* Sub-Category Node */
        .sub-category-node {
            position: absolute;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #4169E1, #6495ED);
            border: 2px solid #87CEEB;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(65, 105, 225, 0.4);
            z-index: 12;
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .sub-category-node:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(65, 105, 225, 0.6);
        }

        /* Radial Connection Lines */
        .radial-connection {
            position: absolute;
            background: linear-gradient(to right, #FF8C00, #666);
            height: 3px;
            transform-origin: left center;
            z-index: 5;
            border-radius: 2px;
        }

        .radial-connection.main-to-sub {
            background: linear-gradient(to right, #FF8C00, #4169E1);
        }

        .radial-connection.sub-to-upgrade {
            background: linear-gradient(to right, #4169E1, #666);
            height: 2px;
        }

        /* Upgrade Path */
        .upgrade-path {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 50px;
            position: relative;
        }

        /* Connection Lines */
        .connection-line {
            position: absolute;
            width: 4px;
            background: #666;
            left: 50%;
            transform: translateX(-50%);
            transition: background 0.3s;
            z-index: 1;
            border-radius: 2px;
        }

        .connection-line.unlocked {
            background: linear-gradient(to bottom, #FF8C00, #FFA500);
            box-shadow: 0 0 8px rgba(255, 140, 0, 0.4);
        }

        .connection-line.available {
            background: linear-gradient(to bottom, #FF8C00, #666);
            animation: pulse 2s infinite;
        }

        .connection-line.locked {
            background: #444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Upgrade Nodes */
        .upgrade-node {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #666;
            background: #404040;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: absolute;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .upgrade-node:hover {
            transform: scale(1.1);
        }

        .upgrade-node.unlocked {
            background: #FF8C00;
            border-color: #FFA500;
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.4);
        }

        .upgrade-node.available {
            background: #F5F5F5;
            border-color: white;
            color: #333;
            animation: availablePulse 2s infinite;
        }

        .upgrade-node.selected {
            border-color: #FFA500;
            box-shadow: 0 0 25px rgba(255, 165, 0, 0.6);
        }

        .upgrade-node.locked {
            background: #404040;
            border-color: #666;
            opacity: 0.6;
        }

        @keyframes availablePulse {
            0%, 100% { border-color: white; }
            50% { border-color: #FF8C00; }
        }

        .upgrade-node .node-icon {
            font-size: 14px;
            margin-bottom: 1px;
        }

        .upgrade-node .node-level {
            font-size: 7px;
            font-weight: bold;
        }

        .upgrade-node .node-cost {
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #4169E1;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 4px;
            border-radius: 3px;
            white-space: nowrap;
        }

        .upgrade-node .lock-icon {
            position: absolute;
            top: -6px;
            right: -6px;
            background: #666;
            border-radius: 50%;
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7px;
        }

        /* Upgrade Details Panel */
        .upgrade-details {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 15px 25px;
            border-radius: 8px;
            border: 1px solid #FF8C00;
            min-width: 300px;
            text-align: center;
            z-index: 101;
        }

        .upgrade-name {
            font-size: 16px;
            font-weight: bold;
            color: #FF8C00;
            margin-bottom: 8px;
        }

        .upgrade-effect {
            font-size: 14px;
            color: #CCC;
            margin-bottom: 10px;
        }

        /* Unlock Button */
        .unlock-button {
            position: absolute;
            bottom: 20px;
            right: 30px;
            padding: 12px 25px;
            font-size: 14px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .unlock-button.can-afford {
            background: #32CD32;
            color: white;
        }

        .unlock-button.can-afford:hover {
            background: #228B22;
            transform: scale(1.05);
        }

        .unlock-button.cannot-afford {
            background: #DC143C;
            color: white;
            cursor: not-allowed;
        }

        .unlock-button.no-selection {
            background: #666;
            color: #CCC;
            cursor: not-allowed;
        }

        /* Unlock Animation */
        @keyframes unlockSuccess {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); background: #32CD32; }
            100% { transform: scale(1); }
        }

        .upgrade-node.unlock-animation {
            animation: unlockSuccess 0.6s ease-out;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: #2C2C2C;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #FF8C00;
            font-size: 13px;
            color: white;
            z-index: 1000;
            pointer-events: none;
            width: 250px;
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.3);
        }

        .tooltip-icon {
            text-align: center;
            font-size: 32px;
            margin-bottom: 10px;
        }

        .tooltip-title {
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            color: #FF8C00;
            margin-bottom: 8px;
        }

        .tooltip-effect {
            text-align: center;
            font-size: 14px;
            color: #FFA500;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .tooltip-description {
            text-align: center;
            font-size: 12px;
            color: #CCC;
            margin-bottom: 10px;
            line-height: 1.3;
        }

        .tooltip-status {
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .tooltip-status.unlocked {
            background: #228B22;
            color: white;
        }

        .tooltip-status.locked {
            background: #666;
            color: #CCC;
        }

        .tooltip-status.available {
            background: #FF8C00;
            color: white;
        }

        /* Responsive Design */
        @media (max-width: 1366px) {
            .meta-upgrade-modal {
                width: 95%;
                height: 90%;
            }
            
            .trees-content-wrapper {
                gap: 15px;
                padding: 15px;
            }
            
            .main-category-container {
                min-width: 200px;
                margin-right: 30px;
            }
            
            .sub-tree-container {
                min-width: 150px;
            }
            
            .upgrade-node {
                width: 50px;
                height: 50px;
            }
            
            .main-category-header {
                font-size: 16px;
            }
            
            .sub-tree-header {
                font-size: 12px;
            }
            
            .zoom-controls {
                top: 10px;
                right: 10px;
            }
            
            .zoom-button {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
        }

        @media (max-width: 768px) {
            .layout-toggle {
                top: 5px;
                left: 5px;
            }
            
            .toggle-option {
                padding: 8px 10px;
                font-size: 10px;
            }
            
            .toggle-icon {
                font-size: 12px;
            }
            
            .zoom-controls {
                top: 5px;
                right: 5px;
            }
            
            .zoom-button {
                width: 30px;
                height: 30px;
                font-size: 14px;
            }
            
            .zoom-indicator {
                font-size: 10px;
                padding: 3px 5px;
            }
            
            .trees-content-wrapper {
                gap: 10px;
                padding: 10px;
            }
            
            .horizontal .main-category-container {
                min-width: 150px;
                margin-right: 20px;
            }
            
            .horizontal .sub-tree-container {
                min-width: 120px;
            }
            
            .horizontal .upgrade-path {
                gap: 40px;
            }
            
            .horizontal .upgrade-node {
                width: 50px;
                height: 50px;
            }
            
            .horizontal .connection-line {
                width: 3px;
            }
        }
    </style>
</head>
<body>
    <!-- Game Background -->
    <div class="game-background"></div>

    <!-- Meta Upgrade Modal -->
    <div class="modal-overlay">
        <div class="meta-upgrade-modal">
            <!-- Close Button -->
            <button class="close-button" onclick="closeModal()">&times;</button>

            <!-- Top Section with RP Display Only -->
            <div class="top-section">
                <div class="rp-display">
                    <div class="rp-icon">
                        <i class="fas fa-flask"></i>
                    </div>
                    <div class="rp-content">
                        <div class="rp-amount" id="rpAmount">300</div>
                        <div class="rp-label">Research Points</div>
                    </div>
                </div>
            </div>

            <!-- Main Content Area -->
            <div class="main-content">
                <!-- All Trees Container -->
                <div class="all-trees-container" id="allTreesContainer">
                    <!-- Layout Toggle -->
                    <div class="layout-toggle">
                        <button class="toggle-option active" id="radialToggle" data-layout="radial">
                            <span class="toggle-icon">ðŸ”˜</span>
                            <span>Radial</span>
                        </button>
                        <button class="toggle-option" id="horizontalToggle" data-layout="horizontal">
                            <span class="toggle-icon">ðŸ“‹</span>
                            <span>Horizontal</span>
                        </button>
                    </div>
                    
                    <!-- Zoom Controls -->
                    <div class="zoom-controls">
                        <button class="zoom-button" id="zoomInBtn">+</button>
                        <button class="zoom-button" id="zoomOutBtn">âˆ’</button>
                        <button class="zoom-button" id="resetZoomBtn" style="font-size: 14px;">âŒ‚</button>
                        <div class="zoom-indicator" id="zoomIndicator">100%</div>
                    </div>
                    
                    <!-- Trees Content Wrapper -->
                    <div class="trees-content-wrapper" id="treesContentWrapper">
                        <!-- Dynamic content will be populated here -->
                    </div>
                </div>
            </div>

            <!-- Unlock Button -->
            <button class="unlock-button no-selection" id="unlockButton" onclick="unlockUpgrade()">
                SELECT UPGRADE
            </button>
        </div>
    </div>

    <script>
        // Game State
        let currentRP = 300;
        let selectedUpgrade = null;
        let currentCategory = 'buildings';

        // Zoom and Pan State
        let currentZoom = 1;
        let currentPanX = 0;
        let currentPanY = 0;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let minZoom = 0.3;
        let maxZoom = 3;
        let zoomStep = 0.2;

        // Layout State
        let currentLayout = 'radial'; // 'radial' or 'horizontal'

        // Upgrade Data with Sub-Categories
        const upgradeData = {
            buildings: {
                title: "Buildings",
                subCategories: {
                    levels: {
                        title: "Building Levels",
                        description: "Increases the default level of all building cards.",
                        upgrades: [
                            { id: 1, name: "Basic Buildings", cost: 50, effect: "+1 Default Building Level", unlocked: true, icon: "ðŸ " },
                            { id: 2, name: "Improved Buildings", cost: 100, effect: "+1 Default Building Level", unlocked: true, icon: "ðŸ¢" },
                            { id: 3, name: "Advanced Buildings", cost: 150, effect: "+1 Default Building Level", unlocked: false, icon: "ðŸ­" },
                            { id: 4, name: "Superior Buildings", cost: 200, effect: "+1 Default Building Level", unlocked: false, icon: "ðŸ—ï¸" },
                            { id: 5, name: "Master Buildings", cost: 300, effect: "+1 Default Building Level", unlocked: false, icon: "ðŸ›ï¸" }
                        ]
                    }
                }
            },
            soldiers: {
                title: "Soldiers",
                subCategories: {
                    training: {
                        title: "Training",
                        description: "Enhances the default effectiveness and level of all trained soldiers.",
                        upgrades: [
                            { id: 1, name: "Basic Training", cost: 75, effect: "+1 Default Soldier Level", unlocked: true, icon: "ðŸ¥‰" },
                            { id: 2, name: "Advanced Training", cost: 125, effect: "+1 Default Soldier Level", unlocked: false, icon: "ðŸ¥ˆ" },
                            { id: 3, name: "Elite Training", cost: 175, effect: "+1 Default Soldier Level", unlocked: false, icon: "ðŸ¥‡" },
                            { id: 4, name: "Special Forces", cost: 250, effect: "+1 Default Soldier Level", unlocked: false, icon: "ðŸŽ–ï¸" },
                            { id: 5, name: "Legendary Warriors", cost: 350, effect: "+1 Default Soldier Level", unlocked: false, icon: "â­" }
                        ]
                    }
                }
            },
            walls: {
                title: "Walls",
                subCategories: {
                    defense: {
                        title: "Defense",
                        description: "Enhances the capacity, durability, and special abilities of defensive walls.",
                        upgrades: [
                            { id: 1, name: "Extended Walls", cost: 80, effect: "Wall capacity +20", unlocked: false, icon: "ðŸ§±" },
                            { id: 2, name: "Reinforced Walls", cost: 160, effect: "Capacity +20, +HP", unlocked: false, icon: "ðŸ›¡ï¸" },
                            { id: 3, name: "Fortified Walls", cost: 240, effect: "Wall capacity +20", unlocked: false, icon: "â›©ï¸" },
                            { id: 4, name: "Electrified Walls", cost: 400, effect: "Electric damage to attackers", unlocked: false, icon: "âš¡" }
                        ]
                    }
                }
            },
            farm: {
                title: "Farm",
                subCategories: {
                    speed: {
                        title: "Harvest Speed",
                        description: "Reduces the time needed for crop harvests.",
                        upgrades: [
                            { id: 1, name: "Quick Harvest", cost: 60, effect: "Crops grow 1 day faster", unlocked: false, icon: "â°" },
                            { id: 2, name: "Rapid Growth", cost: 120, effect: "Crops grow 1 day faster", unlocked: false, icon: "ðŸ’¨" },
                            { id: 3, name: "Super Growth", cost: 180, effect: "Crops grow 1 day faster", unlocked: false, icon: "âš¡" },
                            { id: 4, name: "Instant Harvest", cost: 240, effect: "Crops grow 1 day faster", unlocked: false, icon: "ðŸŒŸ" }
                        ]
                    },
                    grid: {
                        title: "Grid Expansion",
                        description: "Adds more grid spaces to the farm for additional crops.",
                        upgrades: [
                            { id: 1, name: "Small Expansion", cost: 80, effect: "+1 crop grid expansion", unlocked: false, icon: "ðŸšœ" },
                            { id: 2, name: "Medium Expansion", cost: 160, effect: "+2 crop grid expansion", unlocked: false, icon: "ðŸžï¸" },
                            { id: 3, name: "Large Expansion", cost: 240, effect: "+3 crop grid expansion", unlocked: false, icon: "ðŸŒ¾" },
                            { id: 4, name: "Massive Expansion", cost: 320, effect: "+4 crop grid expansion", unlocked: false, icon: "ðŸŒ¿" }
                        ]
                    },
                    yield: {
                        title: "Harvest Yield",
                        description: "Increases the amount of crops harvested from each plot.",
                        upgrades: [
                            { id: 1, name: "Better Harvest", cost: 70, effect: "+25% crop harvest", unlocked: false, icon: "ðŸŒ¾" },
                            { id: 2, name: "Rich Harvest", cost: 140, effect: "+50% crop harvest", unlocked: false, icon: "ðŸŒ»" },
                            { id: 3, name: "Abundant Harvest", cost: 210, effect: "+75% crop harvest", unlocked: false, icon: "ðŸŒ½" },
                            { id: 4, name: "Golden Harvest", cost: 280, effect: "+100% crop harvest", unlocked: false, icon: "ðŸŒ¼" }
                        ]
                    }
                }
            },
            laboratory: {
                title: "Laboratory",
                subCategories: {
                    research: {
                        title: "Research",
                        description: "Boosts research point generation and research completion speed.",
                        upgrades: [
                            { id: 1, name: "Efficient Research", cost: 100, effect: "+50% RP generation", unlocked: false, icon: "ðŸ”¬" },
                            { id: 2, name: "Rapid Research", cost: 200, effect: "Research 1 day faster", unlocked: false, icon: "âš¡" },
                            { id: 3, name: "Advanced Research", cost: 300, effect: "+100% RP generation", unlocked: false, icon: "ðŸ§¬" }
                        ]
                    }
                }
            },
            expeditions: {
                title: "Expeditions",
                subCategories: {
                    missions: {
                        title: "Missions",
                        description: "Improves expedition success rates, rewards, and completion time.",
                        upgrades: [
                            { id: 1, name: "Safe Expeditions", cost: 120, effect: "+20% survival rate", unlocked: false, icon: "ðŸ›¡ï¸" },
                            { id: 2, name: "Rich Rewards", cost: 180, effect: "+50% expedition rewards", unlocked: false, icon: "ðŸ’°" },
                            { id: 3, name: "Swift Expeditions", cost: 250, effect: "Expeditions 1 day faster", unlocked: false, icon: "ðŸ’¨" }
                        ]
                    }
                }
            },
            npc: {
                title: "NPC Buffs",
                subCategories: {
                    effects: {
                        title: "Buff Effects",
                        description: "Amplifies the beneficial effects provided by recruited NPCs.",
                        upgrades: [
                            { id: 1, name: "Enhanced NPCs", cost: 150, effect: "+50% NPC buff effects", unlocked: false, icon: "ðŸ‘¤" },
                            { id: 2, name: "Empowered NPCs", cost: 250, effect: "+75% NPC buff effects", unlocked: false, icon: "âœ¨" },
                            { id: 3, name: "Legendary NPCs", cost: 400, effect: "+100% NPC buff effects", unlocked: false, icon: "â­" }
                        ]
                    }
                }
            },
            revive: {
                title: "Revive",
                subCategories: {
                    phoenix: {
                        title: "Phoenix",
                        description: "Provides multiple chances to recover from defeat.",
                        upgrades: [
                            { id: 1, name: "Phoenix Rising", cost: 500, effect: "Revive ability (1 use per run)", unlocked: false, icon: "â¤ï¸" },
                            { id: 2, name: "Double Phoenix", cost: 750, effect: "Revive ability (2 uses per run)", unlocked: false, icon: "ðŸ’–" },
                            { id: 3, name: "Eternal Phoenix", cost: 1000, effect: "Revive ability (3 uses per run)", unlocked: false, icon: "ðŸ’" }
                        ]
                    }
                }
            },
            weapons: {
                title: "Weapons",
                subCategories: {
                    combat: {
                        title: "Combat",
                        description: "Enhances combat effectiveness through improved fire rate, reload speed, and damage.",
                        upgrades: [
                            { id: 1, name: "Rapid Fire", cost: 100, effect: "Soldiers attack faster", unlocked: false, icon: "ðŸ”«" },
                            { id: 2, name: "Quick Reload", cost: 175, effect: "-50% reload time", unlocked: false, icon: "ðŸ”„" },
                            { id: 3, name: "High Damage", cost: 250, effect: "+50% soldier damage", unlocked: false, icon: "ðŸ’¥" }
                        ]
                    }
                }
            },
            airstrike: {
                title: "Airstrike",
                subCategories: {
                    bombing: {
                        title: "Bombing",
                        description: "Improves aerial support through cost reduction, new weapons, and increased effectiveness.",
                        upgrades: [
                            { id: 1, name: "Cheap Strikes", cost: 125, effect: "Airstrikes 50% cheaper", unlocked: false, icon: "ðŸ’°" },
                            { id: 2, name: "Triple Bomber", cost: 200, effect: "3-bomb launcher plane", unlocked: false, icon: "ðŸ’£" },
                            { id: 3, name: "Wide Bombardment", cost: 300, effect: "+50% airstrike radius", unlocked: false, icon: "ðŸ’¥" }
                        ]
                    }
                }
            },
            reroll: {
                title: "Reroll Cards",
                subCategories: {
                    cards: {
                        title: "Cards",
                        description: "Adds flexibility to building selection with reroll functionality.",
                        upgrades: [
                            { id: 1, name: "Basic Reroll", cost: 75, effect: "Unlocks reroll function", unlocked: false, icon: "ðŸ”„" },
                            { id: 2, name: "Extra Reroll", cost: 125, effect: "+1 reroll count", unlocked: false, icon: "ðŸ”„" },
                            { id: 3, name: "More Rerolls", cost: 175, effect: "+1 reroll count", unlocked: false, icon: "ðŸ”„" },
                            { id: 4, name: "Maximum Rerolls", cost: 250, effect: "+1 reroll count", unlocked: false, icon: "ðŸ”„" }
                        ]
                    }
                }
            }
        };

        // Initialize the interface
        function init() {
            updateRPDisplay();
            renderUpgradeTrees();
            initializeView();
            setupEventListeners();
        }

        // Setup event listeners
        function setupEventListeners() {
            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeModal();
                } else if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    zoomIn();
                } else if (e.key === '-' || e.key === '_') {
                    e.preventDefault();
                    zoomOut();
                } else if (e.key === '0' || e.key === 'Home') {
                    e.preventDefault();
                    resetZoom();
                }
            });

            // Zoom and Pan Event Listeners
            setupZoomAndPanListeners();

            // Layout Toggle Event Listeners
            setupLayoutToggle();
        }

        // Setup zoom and pan functionality
        function setupZoomAndPanListeners() {
            const container = document.getElementById('allTreesContainer');
            const wrapper = document.getElementById('treesContentWrapper');
            
            // Zoom Controls
            document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
            document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
            document.getElementById('resetZoomBtn').addEventListener('click', resetZoom);
            
            // Mouse wheel zoom
            container.addEventListener('wheel', function(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -zoomStep : zoomStep;
                zoom(delta, e.clientX, e.clientY);
            });
            
            // Mouse panning
            container.addEventListener('mousedown', startPanning);
            document.addEventListener('mousemove', updatePanning);
            document.addEventListener('mouseup', stopPanning);
            
            // Touch events for mobile
            container.addEventListener('touchstart', handleTouchStart, { passive: false });
            container.addEventListener('touchmove', handleTouchMove, { passive: false });
            container.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            // Prevent context menu on right click
            container.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });
        }

        // Zoom Functions
        function zoomIn() {
            zoom(zoomStep);
        }

        function zoomOut() {
            zoom(-zoomStep);
        }

        function resetZoom() {
            currentZoom = 1;
            currentPanX = 0;
            currentPanY = 0;
            updateTransform();
        }

        function zoom(delta, clientX, clientY) {
            const newZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom + delta));
            
            if (newZoom !== currentZoom) {
                // If mouse position is provided, zoom towards that point
                if (clientX !== undefined && clientY !== undefined) {
                    const container = document.getElementById('allTreesContainer');
                    const rect = container.getBoundingClientRect();
                    const mouseX = clientX - rect.left;
                    const mouseY = clientY - rect.top;
                    
                    // Calculate the zoom center relative to the wrapper
                    const zoomCenterX = (mouseX - currentPanX) / currentZoom;
                    const zoomCenterY = (mouseY - currentPanY) / currentZoom;
                    
                    // Update zoom
                    currentZoom = newZoom;
                    
                    // Adjust pan to keep the zoom center in place
                    currentPanX = mouseX - zoomCenterX * currentZoom;
                    currentPanY = mouseY - zoomCenterY * currentZoom;
                } else {
                    currentZoom = newZoom;
                }
                
                updateTransform();
            }
        }

        // Panning Functions
        function startPanning(e) {
            if (e.button !== 0) return; // Only left mouse button
            isPanning = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            document.getElementById('allTreesContainer').classList.add('panning');
            e.preventDefault();
        }

        function updatePanning(e) {
            if (!isPanning) return;
            
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            
            currentPanX += deltaX;
            currentPanY += deltaY;
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            updateTransform();
        }

        function stopPanning() {
            isPanning = false;
            document.getElementById('allTreesContainer').classList.remove('panning');
        }

        // Touch Events for Mobile
        let touchStartX = 0;
        let touchStartY = 0;
        let initialDistance = 0;
        let initialZoom = 1;

        function handleTouchStart(e) {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                // Single touch - start panning
                isPanning = true;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                lastMouseX = touchStartX;
                lastMouseY = touchStartY;
            } else if (e.touches.length === 2) {
                // Two touches - start zooming
                isPanning = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                initialDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                initialZoom = currentZoom;
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 1 && isPanning) {
                // Single touch - panning
                const deltaX = e.touches[0].clientX - lastMouseX;
                const deltaY = e.touches[0].clientY - lastMouseY;
                
                currentPanX += deltaX;
                currentPanY += deltaY;
                
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
                
                updateTransform();
            } else if (e.touches.length === 2) {
                // Two touches - zooming
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                const zoomRatio = currentDistance / initialDistance;
                const newZoom = Math.max(minZoom, Math.min(maxZoom, initialZoom * zoomRatio));
                
                if (newZoom !== currentZoom) {
                    currentZoom = newZoom;
                    updateTransform();
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            isPanning = false;
        }

        // Update the transform of the wrapper
        function updateTransform() {
            const wrapper = document.getElementById('treesContentWrapper');
            
            if (currentLayout === 'radial') {
                const baseTransform = 'translate(-50%, -50%)';
                const zoomTransform = `translate(${currentPanX}px, ${currentPanY}px) scale(${currentZoom})`;
                wrapper.style.transform = `${baseTransform} ${zoomTransform}`;
            } else {
                // For horizontal layout, use simpler transform
                wrapper.style.transform = `translate(${currentPanX}px, ${currentPanY}px) scale(${currentZoom})`;
            }
            
            // Update zoom indicator
            document.getElementById('zoomIndicator').textContent = Math.round(currentZoom * 100) + '%';
        }

        // Initialize view to center on hub
        function initializeView() {
            if (currentLayout === 'radial') {
                currentZoom = 0.6; // Start zoomed out to see more of the tree
                currentPanX = 0;
                currentPanY = 0;
            } else {
                currentZoom = 1;
                currentPanX = 0;
                currentPanY = 0;
            }
            updateTransform();
        }

        // Setup layout toggle functionality
        function setupLayoutToggle() {
            document.getElementById('radialToggle').addEventListener('click', () => switchLayout('radial'));
            document.getElementById('horizontalToggle').addEventListener('click', () => switchLayout('horizontal'));
        }

        // Switch between layouts
        function switchLayout(layout) {
            if (currentLayout === layout) return;
            
            currentLayout = layout;
            
            // Update toggle buttons
            document.querySelectorAll('.toggle-option').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(layout + 'Toggle').classList.add('active');
            
            // Re-render with new layout
            if (layout === 'radial') {
                renderRadialTrees();
            } else {
                renderHorizontalTrees();
            }
            
            // Reset view
            initializeView();
        }

        // Main render function - delegates to layout-specific functions
        function renderUpgradeTrees() {
            if (currentLayout === 'radial') {
                renderRadialTrees();
            } else {
                renderHorizontalTrees();
            }
        }

        // Render radial skill tree
        function renderRadialTrees() {
            const treesContentWrapper = document.getElementById('treesContentWrapper');
            treesContentWrapper.innerHTML = '';
            treesContentWrapper.className = 'trees-content-wrapper'; // Remove horizontal class
            
            // Create central hub
            const centralHub = document.createElement('div');
            centralHub.className = 'central-hub';
            centralHub.innerHTML = `
                <div class="central-hub-icon">âš¡</div>
                <div>META<br>UPGRADES</div>
            `;
            treesContentWrapper.appendChild(centralHub);
            
            // Get category keys and calculate positions
            const categoryKeys = Object.keys(upgradeData);
            const centerX = 1000; // Center of the 2000px container
            const centerY = 1000;
            const mainRadius = 300; // Distance from center to main categories
            
                         // Render main categories in a circle
             categoryKeys.forEach((categoryKey, categoryIndex) => {
                 const categoryData = upgradeData[categoryKey];
                 // Start at top (90 degrees offset) and distribute evenly
                 const angle = (categoryIndex / categoryKeys.length) * 2 * Math.PI - Math.PI / 2;
                 
                 // Calculate main category position
                 const mainCategoryX = centerX + Math.cos(angle) * mainRadius;
                 const mainCategoryY = centerY + Math.sin(angle) * mainRadius;
                
                // Create connection from center to main category
                const centerConnection = document.createElement('div');
                centerConnection.className = 'radial-connection';
                centerConnection.style.left = centerX + 'px';
                centerConnection.style.top = centerY + 'px';
                centerConnection.style.width = mainRadius + 'px';
                centerConnection.style.transform = `rotate(${angle}rad)`;
                treesContentWrapper.appendChild(centerConnection);
                
                // Create main category node
                const mainCategoryNode = document.createElement('div');
                mainCategoryNode.className = 'main-category-node';
                mainCategoryNode.style.left = (mainCategoryX - 40) + 'px';
                mainCategoryNode.style.top = (mainCategoryY - 40) + 'px';
                
                // Get first sub-category for icon
                const firstSubKey = Object.keys(categoryData.subCategories)[0];
                const icon = getIconForCategory(categoryKey);
                
                mainCategoryNode.innerHTML = `
                    <div class="main-category-icon">${icon}</div>
                    <div class="main-category-title">${categoryData.title.toUpperCase()}</div>
                `;
                treesContentWrapper.appendChild(mainCategoryNode);
                
                                 // Render sub-categories around main category
                 const subCategoryKeys = Object.keys(categoryData.subCategories);
                 const subRadius = 150; // Distance from main category to sub-categories
                 
                 subCategoryKeys.forEach((subCategoryKey, subIndex) => {
                     const subCategoryData = categoryData.subCategories[subCategoryKey];
                     // For single sub-category, place it on the same angle as main category
                     // For multiple sub-categories, distribute them symmetrically around the main category
                     let subAngle;
                     if (subCategoryKeys.length === 1) {
                         subAngle = angle;
                     } else {
                         // Distribute sub-categories in an arc around the main category
                         const arcSpan = Math.PI / 3; // 60 degree arc
                         const angleStep = arcSpan / (subCategoryKeys.length - 1);
                         subAngle = angle + (subIndex * angleStep) - (arcSpan / 2);
                     }
                    
                    // Calculate sub-category position
                    const subCategoryX = mainCategoryX + Math.cos(subAngle) * subRadius;
                    const subCategoryY = mainCategoryY + Math.sin(subAngle) * subRadius;
                    
                    // Create connection from main to sub-category
                    const subConnection = document.createElement('div');
                    subConnection.className = 'radial-connection main-to-sub';
                    subConnection.style.left = mainCategoryX + 'px';
                    subConnection.style.top = mainCategoryY + 'px';
                    subConnection.style.width = subRadius + 'px';
                    subConnection.style.transform = `rotate(${subAngle}rad)`;
                    treesContentWrapper.appendChild(subConnection);
                    
                    // Create sub-category node
                    const subCategoryNode = document.createElement('div');
                    subCategoryNode.className = 'sub-category-node';
                    subCategoryNode.style.left = (subCategoryX - 30) + 'px';
                    subCategoryNode.style.top = (subCategoryY - 30) + 'px';
                    subCategoryNode.innerHTML = `
                        <div>${subCategoryData.title.charAt(0)}</div>
                    `;
                    treesContentWrapper.appendChild(subCategoryNode);
                    
                    // Render upgrade nodes extending from sub-category
                    const upgradeRadius = 80; // Distance between upgrade levels
                    
                    subCategoryData.upgrades.forEach((upgrade, upgradeIndex) => {
                        const upgradeDistance = upgradeRadius * (upgradeIndex + 1);
                        const upgradeX = subCategoryX + Math.cos(subAngle) * upgradeDistance;
                        const upgradeY = subCategoryY + Math.sin(subAngle) * upgradeDistance;
                        
                        // Create connection line for upgrade
                        if (upgradeIndex === 0) {
                            // Connection from sub-category to first upgrade
                            const upgradeConnection = document.createElement('div');
                            upgradeConnection.className = 'radial-connection sub-to-upgrade';
                            upgradeConnection.style.left = subCategoryX + 'px';
                            upgradeConnection.style.top = subCategoryY + 'px';
                            upgradeConnection.style.width = (upgradeRadius * subCategoryData.upgrades.length) + 'px';
                            upgradeConnection.style.transform = `rotate(${subAngle}rad)`;
                            treesContentWrapper.appendChild(upgradeConnection);
                        }
                        
                        // Create upgrade node
                        const upgradeNode = document.createElement('div');
                        upgradeNode.className = 'upgrade-node';
                        upgradeNode.dataset.upgradeId = upgrade.id;
                        upgradeNode.dataset.category = categoryKey;
                        upgradeNode.dataset.subCategory = subCategoryKey;
                        upgradeNode.style.left = (upgradeX - 25) + 'px';
                        upgradeNode.style.top = (upgradeY - 25) + 'px';
                        
                        // Determine node state
                        if (upgrade.unlocked) {
                            upgradeNode.classList.add('unlocked');
                        } else if (upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked) {
                            upgradeNode.classList.add('available');
                        } else {
                            upgradeNode.classList.add('locked');
                        }
                        
                        // Add selection state
                        if (selectedUpgrade && selectedUpgrade.id === upgrade.id && 
                            selectedUpgrade.category === categoryKey && 
                            selectedUpgrade.subCategory === subCategoryKey) {
                            upgradeNode.classList.add('selected');
                        }
                        
                        // Node content
                        upgradeNode.innerHTML = `
                            <div class="node-icon">${upgrade.icon}</div>
                            <div class="node-level">Lv.${upgrade.id}</div>
                            ${!upgrade.unlocked ? `<div class="node-cost">${upgrade.cost} RP</div>` : ''}
                            ${upgradeNode.classList.contains('locked') ? '<div class="lock-icon">ðŸ”’</div>' : ''}
                        `;
                        
                        // Add click event
                        if (!upgrade.unlocked && (upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked)) {
                            upgradeNode.addEventListener('click', () => selectUpgrade(upgrade, categoryKey, subCategoryKey));
                        }
                        
                        // Add hover tooltip
                        upgradeNode.addEventListener('mouseenter', (e) => showTooltip(e, upgrade));
                        upgradeNode.addEventListener('mouseleave', hideTooltip);
                        
                        treesContentWrapper.appendChild(upgradeNode);
                    });
                });
            });
        }

        // Render horizontal skill tree
        function renderHorizontalTrees() {
            const treesContentWrapper = document.getElementById('treesContentWrapper');
            treesContentWrapper.innerHTML = '';
            treesContentWrapper.className = 'trees-content-wrapper horizontal'; // Add horizontal class
            
            // Render all main categories
            Object.keys(upgradeData).forEach(categoryKey => {
                const categoryData = upgradeData[categoryKey];
                
                // Create main category container
                const mainCategoryContainer = document.createElement('div');
                mainCategoryContainer.className = 'main-category-container';
                mainCategoryContainer.dataset.category = categoryKey;
                
                // Main category header
                const mainCategoryHeader = document.createElement('div');
                mainCategoryHeader.className = 'main-category-header';
                mainCategoryHeader.textContent = categoryData.title;
                mainCategoryContainer.appendChild(mainCategoryHeader);
                
                // Sub-categories container
                const subCategoriesContainer = document.createElement('div');
                subCategoriesContainer.className = 'sub-categories-container';
                
                // Render all sub-categories
                Object.keys(categoryData.subCategories).forEach(subCategoryKey => {
                    const subCategoryData = categoryData.subCategories[subCategoryKey];
                    
                    // Create sub-tree container
                    const subTreeContainer = document.createElement('div');
                    subTreeContainer.className = 'sub-tree-container';
                    subTreeContainer.dataset.category = categoryKey;
                    subTreeContainer.dataset.subCategory = subCategoryKey;
                    
                    // Sub-tree header
                    const subTreeHeader = document.createElement('div');
                    subTreeHeader.className = 'sub-tree-header';
                    subTreeHeader.textContent = subCategoryData.title;
                    subTreeContainer.appendChild(subTreeHeader);
                    
                    // Upgrade path
                    const upgradePath = document.createElement('div');
                    upgradePath.className = 'upgrade-path';
                    
                    subCategoryData.upgrades.forEach((upgrade, index) => {
                        // Create connection line (except for first upgrade)
                        if (index > 0) {
                            const connectionLine = document.createElement('div');
                            connectionLine.className = 'connection-line';
                            
                            // Calculate positioning based on screen size
                            const isMobile = window.innerWidth <= 768;
                            const nodeSize = isMobile ? 50 : 60;
                            const gapSize = isMobile ? 40 : 50;
                            const lineHeight = gapSize;
                            
                            connectionLine.style.top = `${(index - 1) * (nodeSize + gapSize) + nodeSize}px`;
                            connectionLine.style.height = `${lineHeight}px`;
                            
                            // Determine line state
                            const prevUpgrade = subCategoryData.upgrades[index - 1];
                            if (prevUpgrade.unlocked && upgrade.unlocked) {
                                connectionLine.classList.add('unlocked');
                            } else if (prevUpgrade.unlocked && !upgrade.unlocked) {
                                connectionLine.classList.add('available');
                            } else {
                                connectionLine.classList.add('locked');
                            }
                            
                            upgradePath.appendChild(connectionLine);
                        }
                        
                        // Create upgrade node
                        const upgradeNode = document.createElement('div');
                        upgradeNode.className = 'upgrade-node';
                        upgradeNode.dataset.upgradeId = upgrade.id;
                        upgradeNode.dataset.category = categoryKey;
                        upgradeNode.dataset.subCategory = subCategoryKey;
                        
                        // Determine node state
                        if (upgrade.unlocked) {
                            upgradeNode.classList.add('unlocked');
                        } else if (index === 0 || subCategoryData.upgrades[index - 1].unlocked) {
                            upgradeNode.classList.add('available');
                        } else {
                            upgradeNode.classList.add('locked');
                        }
                        
                        // Add selection state
                        if (selectedUpgrade && selectedUpgrade.id === upgrade.id && 
                            selectedUpgrade.category === categoryKey && 
                            selectedUpgrade.subCategory === subCategoryKey) {
                            upgradeNode.classList.add('selected');
                        }
                        
                        // Node content
                        upgradeNode.innerHTML = `
                            <div class="node-icon">${upgrade.icon}</div>
                            <div class="node-level">Lv.${upgrade.id}</div>
                            ${!upgrade.unlocked ? `<div class="node-cost">${upgrade.cost} RP</div>` : ''}
                            ${upgradeNode.classList.contains('locked') ? '<div class="lock-icon">ðŸ”’</div>' : ''}
                        `;
                        
                        // Add click event
                        if (!upgrade.unlocked && (index === 0 || subCategoryData.upgrades[index - 1].unlocked)) {
                            upgradeNode.addEventListener('click', () => selectUpgrade(upgrade, categoryKey, subCategoryKey));
                        }
                        
                        // Add hover tooltip
                        upgradeNode.addEventListener('mouseenter', (e) => showTooltip(e, upgrade));
                        upgradeNode.addEventListener('mouseleave', hideTooltip);
                        
                        upgradePath.appendChild(upgradeNode);
                    });
                    
                    subTreeContainer.appendChild(upgradePath);
                    subCategoriesContainer.appendChild(subTreeContainer);
                });
                
                mainCategoryContainer.appendChild(subCategoriesContainer);
                treesContentWrapper.appendChild(mainCategoryContainer);
            });
        }

        // Get icon for category
        function getIconForCategory(categoryKey) {
            const icons = {
                buildings: 'ðŸ—ï¸',
                soldiers: 'ðŸ‘¥',
                walls: 'ðŸ§±',
                farm: 'ðŸŒ¾',
                laboratory: 'ðŸ§ª',
                expeditions: 'ðŸ—ºï¸',
                npc: 'ðŸ‘¤',
                revive: 'â¤ï¸',
                weapons: 'ðŸ”«',
                airstrike: 'âœˆï¸',
                reroll: 'ðŸ”„'
            };
            return icons[categoryKey] || 'â­';
        }

        // Select an upgrade
        function selectUpgrade(upgrade, category, subCategory) {
            selectedUpgrade = upgrade;
            selectedUpgrade.category = category;
            selectedUpgrade.subCategory = subCategory;
            
            // Update visual selection
            document.querySelectorAll('.upgrade-node').forEach(node => {
                node.classList.remove('selected');
            });
            document.querySelector(`[data-upgrade-id="${upgrade.id}"][data-category="${category}"][data-sub-category="${subCategory}"]`).classList.add('selected');
            
            // Show upgrade details
            showUpgradeDetails(upgrade);
            
            // Update unlock button
            updateUnlockButton();
        }

        // Show upgrade details
        function showUpgradeDetails(upgrade) {
            // Remove existing details panel
            const existingPanel = document.querySelector('.upgrade-details');
            if (existingPanel) {
                existingPanel.remove();
            }
            
            const detailsPanel = document.createElement('div');
            detailsPanel.className = 'upgrade-details';
            detailsPanel.innerHTML = `
                <div class="upgrade-name">${upgrade.name}</div>
                <div class="upgrade-effect">${upgrade.effect}</div>
            `;
            
            document.querySelector('.meta-upgrade-modal').appendChild(detailsPanel);
        }

        // Update unlock button
        function updateUnlockButton() {
            const button = document.getElementById('unlockButton');
            
            if (!selectedUpgrade) {
                button.className = 'unlock-button no-selection';
                button.textContent = 'SELECT UPGRADE';
                return;
            }
            
            if (currentRP >= selectedUpgrade.cost) {
                button.className = 'unlock-button can-afford';
                button.textContent = `UNLOCK (${selectedUpgrade.cost} RP)`;
            } else {
                button.className = 'unlock-button cannot-afford';
                button.textContent = `INSUFFICIENT RP (${selectedUpgrade.cost} RP)`;
            }
        }

        // Unlock selected upgrade
        function unlockUpgrade() {
            if (!selectedUpgrade || currentRP < selectedUpgrade.cost) {
                return;
            }
            
            // Deduct RP
            currentRP -= selectedUpgrade.cost;
            updateRPDisplay();
            
            // Mark upgrade as unlocked
            selectedUpgrade.unlocked = true;
            
            // Play unlock animation
            const nodeElement = document.querySelector(`[data-upgrade-id="${selectedUpgrade.id}"][data-category="${selectedUpgrade.category}"][data-sub-category="${selectedUpgrade.subCategory}"]`);
            nodeElement.classList.add('unlock-animation');
            
            setTimeout(() => {
                nodeElement.classList.remove('unlock-animation');
                // Re-render all trees to update visuals
                renderUpgradeTrees();
            }, 600);
            
            // Clear selection
            selectedUpgrade = null;
            
            // Remove details panel
            const detailsPanel = document.querySelector('.upgrade-details');
            if (detailsPanel) {
                detailsPanel.remove();
            }
        }

        // Update RP display
        function updateRPDisplay() {
            document.getElementById('rpAmount').textContent = currentRP;
        }

        // Show tooltip
        function showTooltip(event, upgrade) {
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            
            // Find the category and sub-category this upgrade belongs to
            const upgradeNode = event.target.closest('.upgrade-node');
            const upgradeCategory = upgradeNode.dataset.category;
            const upgradeSubCategory = upgradeNode.dataset.subCategory;
            const categoryData = upgradeData[upgradeCategory];
            const subCategoryData = categoryData.subCategories[upgradeSubCategory];
            
            // Determine status
            let status = '';
            let statusClass = '';
            if (upgrade.unlocked) {
                status = 'UNLOCKED';
                statusClass = 'unlocked';
            } else {
                const upgradeIndex = subCategoryData.upgrades.findIndex(u => u.id === upgrade.id);
                const canUnlock = upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked;
                
                if (canUnlock) {
                    status = `COST: ${upgrade.cost} RP`;
                    statusClass = 'available';
                } else {
                    status = 'LOCKED';
                    statusClass = 'locked';
                }
            }
            
            tooltip.innerHTML = `
                <div class="tooltip-icon">${upgrade.icon}</div>
                <div class="tooltip-title">${upgrade.name}</div>
                <div class="tooltip-effect">${upgrade.effect}</div>
                <div class="tooltip-description">Level ${upgrade.id} upgrade for ${categoryData.title} - ${subCategoryData.title}</div>
                <div class="tooltip-status ${statusClass}">${status}</div>
            `;
            
            document.querySelector('.meta-upgrade-modal').appendChild(tooltip);
            
            // Position tooltip relative to modal
            const rect = event.target.getBoundingClientRect();
            const modalRect = document.querySelector('.meta-upgrade-modal').getBoundingClientRect();
            
            // Position to the right of the node, but check if it would overflow
            let leftPos = rect.right - modalRect.left + 15;
            if (leftPos + 250 > modalRect.width) {
                // Position to the left instead
                leftPos = rect.left - modalRect.left - 265;
            }
            
            tooltip.style.left = leftPos + 'px';
            tooltip.style.top = (rect.top - modalRect.top - 20) + 'px';
        }

        // Hide tooltip
        function hideTooltip() {
            const tooltip = document.querySelector('.tooltip');
            if (tooltip) {
                tooltip.remove();
            }
        }

        // Close modal
        function closeModal() {
            document.body.style.overflow = 'auto';
            window.location.href = 'game.html'; // Return to game
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html> 
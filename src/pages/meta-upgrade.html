<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Defense Z - Meta Upgrade System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        /* Background Game View */
        .game-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('../assets/images/bg-cdz.jpg') center/cover no-repeat;
            filter: blur(2px);
            z-index: 1;
        }

        /* Modal Overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Main Modal Container */
        .meta-upgrade-modal {
            width: 100%;
            height: 100%;
            background: #2C2C2C;
            border: none;
            border-radius: 0;
            box-shadow: 0 0 30px rgba(255, 140, 0, 0.3);
            display: flex;
            flex-direction: column;
            position: relative;
            animation: slideIn 0.4s ease-out;
            padding: 20px;
        }

        @keyframes slideIn {
            from { transform: scale(0.8) translateY(-50px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        /* Close Button */
        .close-button {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #FF8C00;
            font-size: 28px;
            cursor: pointer;
            z-index: 10;
            transition: color 0.2s;
        }

        .close-button:hover {
            color: #FFA500;
            transform: scale(1.1);
        }

        /* Top Section with RP Display Only */
        .top-section {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            padding: 0 20px;
        }

        /* Research Points Display */
        .rp-display {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            background: rgba(65, 105, 225, 0.15);
            border: 1px solid rgba(65, 105, 225, 0.3);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .rp-display:hover {
            background: rgba(65, 105, 225, 0.2);
            border-color: rgba(65, 105, 225, 0.5);
        }

        .rp-icon {
            font-size: 24px;
            color: #4169E1;
            filter: drop-shadow(0 0 8px rgba(65, 105, 225, 0.6));
        }

        .rp-content {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .rp-amount {
            font-size: 24px;
            font-weight: bold;
            color: #4169E1;
            text-shadow: 0 0 10px rgba(65, 105, 225, 0.5);
            line-height: 1;
        }

        .rp-label {
            font-size: 12px;
            color: #888;
            font-weight: normal;
            line-height: 1;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* All Trees Container */
        .all-trees-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }

        .all-trees-container:active {
            cursor: grabbing;
        }

        .all-trees-container.panning {
            cursor: grabbing;
        }

        /* Trees Content Wrapper */
        .trees-content-wrapper {
            position: absolute;
            width: 2000px;
            height: 2000px;
            transition: transform 0.1s ease-out;
            transform-origin: center center;
            user-select: none;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        /* Horizontal Layout Styles */
        .trees-content-wrapper.horizontal {
            position: relative;
            width: auto;
            height: auto;
            left: auto;
            top: auto;
            transform: none;
            display: flex;
            gap: 30px;
            padding: 20px;
            transform-origin: 0 0;
        }

        .horizontal .main-category-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 250px;
            flex-shrink: 0;
            margin-right: 40px;
            transition: all 0.3s ease;
        }

        .horizontal .main-category-header {
            font-size: 20px;
            font-weight: bold;
            color: #FFA500;
            margin-bottom: 20px;
            text-align: center;
            border-bottom: 3px solid #FFA500;
            padding-bottom: 8px;
            width: 100%;
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .horizontal .sub-categories-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .horizontal .sub-tree-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 180px;
            flex-shrink: 0;
            transition: all 0.3s ease;
        }

        .horizontal .sub-tree-header {
            font-size: 14px;
            font-weight: bold;
            color: #FF8C00;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid #FF8C00;
            padding-bottom: 5px;
            width: 100%;
            white-space: nowrap;
        }

        .horizontal .upgrade-path {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 50px;
            position: relative;
        }

        .horizontal .upgrade-node {
            position: relative;
            width: 60px;
            height: 60px;
        }

        .horizontal .connection-line {
            position: absolute;
            width: 4px;
            background: #666;
            left: 50%;
            transform: translateX(-50%);
            transition: background 0.3s;
            z-index: 1;
            border-radius: 2px;
        }

        /* Hide radial elements in horizontal mode */
        .horizontal .central-hub,
        .horizontal .radial-branch,
        .horizontal .main-category-node,
        .horizontal .sub-category-node,
        .horizontal .radial-connection {
            display: none;
        }

        /* Central Hub */
        .central-hub {
            position: absolute;
            width: 120px;
            height: 120px;
            background: linear-gradient(135deg, #FF8C00, #FFA500);
            border: 4px solid #FFB347;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 30px rgba(255, 140, 0, 0.6);
            z-index: 20;
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-align: center;
        }

        .central-hub-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        /* Layout Toggle */
        .layout-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #FF8C00;
            border-radius: 8px;
            overflow: hidden;
            z-index: 10;
        }

        .toggle-option {
            padding: 10px 15px;
            background: transparent;
            border: none;
            color: #FF8C00;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .toggle-option:hover {
            background: rgba(255, 140, 0, 0.2);
        }

        .toggle-option.active {
            background: #FF8C00;
            color: white;
        }

        .toggle-icon {
            font-size: 14px;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }

        .zoom-button {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #FF8C00;
            border-radius: 8px;
            color: #FF8C00;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .zoom-button:hover {
            background: rgba(255, 140, 0, 0.2);
            transform: scale(1.1);
        }

        .zoom-indicator {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #FF8C00;
            border-radius: 4px;
            color: #FF8C00;
            font-size: 12px;
            padding: 5px 8px;
            text-align: center;
            margin-top: 5px;
        }

        /* Radial Branch Container */
        .radial-branch {
            position: absolute;
            transform-origin: center center;
        }

        /* Main Category Node */
        .main-category-node {
            position: absolute;
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #FF8C00, #FFA500);
            border: 3px solid #FFB347;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.4);
            z-index: 15;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .main-category-node:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(255, 140, 0, 0.6);
        }
        
        .main-category-node.collapsed {
            background: linear-gradient(135deg, #666, #888);
            border-color: #999;
            box-shadow: 0 0 10px rgba(150, 150, 150, 0.3);
        }
        
        .main-category-node.expanded {
            background: linear-gradient(135deg, #FF8C00, #FFA500);
            border-color: #FFB347;
            box-shadow: 0 0 25px rgba(255, 140, 0, 0.6);
        }
        
        /* Sub-Category Node (intermediate nodes) */
        .sub-category-node {
            position: absolute;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border: 3px solid #66BB6A;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.4);
            z-index: 12;
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .sub-category-node:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
        }
        
        .sub-category-node.collapsed {
            background: linear-gradient(135deg, #666, #888);
            border-color: #999;
            box-shadow: 0 0 10px rgba(150, 150, 150, 0.3);
        }
        
        .sub-category-node.expanded {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border-color: #66BB6A;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
        }
        
        /* Horizontal Sub-Category Node */
        .sub-category-node-horizontal {
            width: 120px;
            height: 50px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border: 2px solid #66BB6A;
            border-radius: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.4);
            margin: 10px 0;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            gap: 8px;
        }

        .sub-category-node-horizontal:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
        }
        
        .sub-category-node-horizontal.collapsed {
            background: linear-gradient(135deg, #666, #888);
            border-color: #999;
            box-shadow: 0 0 10px rgba(150, 150, 150, 0.3);
        }
        
        .sub-category-node-horizontal.expanded {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border-color: #66BB6A;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
        }
        
        /* Horizontal layout toggle styles */
        .horizontal .main-category-header {
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 10px 15px;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        
        .horizontal .main-category-header.collapsed {
            background: linear-gradient(135deg, #666, #888);
            color: #ccc;
            border: 2px solid #999;
        }
        
        .horizontal .main-category-header.expanded {
            background: linear-gradient(135deg, #FF8C00, #FFA500);
            color: white;
            border: 2px solid #FFB347;
            box-shadow: 0 0 15px rgba(255, 140, 0, 0.4);
        }
        
        .horizontal .main-category-header:hover {
            transform: scale(1.05);
        }
        
        /* Animation styles for skill nodes */
        .skill-node-animate {
            opacity: 1;
            transform: scale(1) translateY(0);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .skill-node-animate.animate-in {
            opacity: 0;
            transform: scale(0) translateY(-20px);
        }
        
        .skill-node-animate.animate-in.show {
            opacity: 1;
            transform: scale(1) translateY(0);
        }
        
        .skill-node-animate.prepare-opening {
            opacity: 0 !important;
            transform: scale(0) !important;
            pointer-events: none;
        }
        
        .skill-node-animate.animate-out {
            opacity: 0;
            transform: scale(0.1) translateY(20px);
        }
        
        .skill-node-animate.completely-hidden {
            opacity: 0 !important;
            transform: scale(0) !important;
            pointer-events: none;
        }
        
        /* Connection line animations */
        .connection-animate {
            opacity: 1;
            transform: scaleX(1);
            transform-origin: left center;
            transition: all 0.3s ease-out;
        }
        
        .connection-animate.animate-in {
            opacity: 0;
            transform: scaleX(0);
        }
        
        .connection-animate.animate-in.show {
            opacity: 1;
            transform: scaleX(1);
        }
        
        .connection-animate.prepare-opening {
            opacity: 0 !important;
            transform: scaleX(0) !important;
            pointer-events: none;
        }
        
        .connection-animate.animate-out {
            opacity: 0;
            transform: scaleX(0);
        }
        
        .connection-animate.completely-hidden {
            opacity: 0 !important;
            transform: scaleX(0) !important;
            pointer-events: none;
        }
        
        /* Radial connection animations */
        .radial-connection-animate {
            opacity: 1;
            transform-origin: left center;
            transition: all 0.3s ease-out;
            transform: scaleX(1) rotate(var(--rotation, 0deg));
        }
        
        .radial-connection-animate.animate-in {
            opacity: 0;
            transform: scaleX(0) rotate(var(--rotation, 0deg));
        }
        
        .radial-connection-animate.animate-in.show {
            opacity: 1;
            transform: scaleX(1) rotate(var(--rotation, 0deg));
        }
        
        .radial-connection-animate.prepare-opening {
            opacity: 0 !important;
            transform: scaleX(0) rotate(var(--rotation, 0deg)) !important;
            pointer-events: none;
        }
        
        .radial-connection-animate.animate-out {
            opacity: 0;
            transform: scaleX(0) rotate(var(--rotation, 0deg));
        }
        
        .radial-connection-animate.completely-hidden {
            opacity: 0 !important;
            transform: scaleX(0) rotate(var(--rotation, 0deg)) !important;
            pointer-events: none;
        }

        .main-category-icon {
            font-size: 18px;
            margin-bottom: 3px;
        }

        .main-category-title {
            font-size: 9px;
            line-height: 1;
        }

        /* Sub-Category Node */
        .sub-category-node {
            position: absolute;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #4169E1, #6495ED);
            border: 2px solid #87CEEB;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(65, 105, 225, 0.4);
            z-index: 12;
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .sub-category-node:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(65, 105, 225, 0.6);
        }

        /* Radial Connection Lines */
        .radial-connection {
            position: absolute;
            background: linear-gradient(to right, #FF8C00, #666);
            height: 3px;
            transform-origin: left center;
            z-index: 5;
            border-radius: 2px;
        }

        .radial-connection.main-to-sub {
            background: linear-gradient(to right, #FF8C00, #4169E1);
        }

        .radial-connection.sub-to-upgrade {
            background: linear-gradient(to right, #4169E1, #666);
            height: 2px;
        }

        /* Upgrade Path */
        .upgrade-path {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 50px;
            position: relative;
        }

        /* Connection Lines */
        .connection-line {
            position: absolute;
            width: 4px;
            background: #666;
            left: 50%;
            transform: translateX(-50%);
            transition: background 0.3s;
            z-index: 1;
            border-radius: 2px;
        }

        .connection-line.unlocked {
            background: linear-gradient(to bottom, #FF8C00, #FFA500);
            box-shadow: 0 0 8px rgba(255, 140, 0, 0.4);
        }

        .connection-line.available {
            background: linear-gradient(to bottom, #FF8C00, #666);
            animation: pulse 2s infinite;
        }

        .connection-line.locked {
            background: #444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Upgrade Nodes */
        .upgrade-node {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #666;
            background: #404040;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: absolute;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* New Upgrade Styles */
        .upgrade-node.new-upgrade {
            border: 3px solid #32CD32;
            box-shadow: 0 0 20px rgba(50, 205, 50, 0.6);
            background: linear-gradient(135deg, #228B22, #32CD32);
        }

        .upgrade-node.new-upgrade.available {
            background: linear-gradient(135deg, #90EE90, #98FB98);
            border-color: #32CD32;
            color: #333;
            animation: newUpgradePulse 2s infinite;
        }

        .upgrade-node.new-upgrade.unlocked {
            background: linear-gradient(135deg, #32CD32, #90EE90);
            border-color: #228B22;
        }

        @keyframes newUpgradePulse {
            0%, 100% { 
                border-color: #32CD32;
                box-shadow: 0 0 20px rgba(50, 205, 50, 0.6);
            }
            50% { 
                border-color: #90EE90;
                box-shadow: 0 0 30px rgba(50, 205, 50, 0.8);
            }
        }

        /* New Upgrade Badge */
        .new-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: linear-gradient(135deg, #FF4500, #FF6347);
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 8px;
            font-weight: bold;
            z-index: 15;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            animation: badgePulse 3s infinite;
        }

        @keyframes badgePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* New Category Styles */
        .main-category-node.new-category {
            border: 4px solid #32CD32;
            box-shadow: 0 0 30px rgba(50, 205, 50, 0.8);
        }

        .main-category-node.new-category.expanded {
            background: linear-gradient(135deg, #32CD32, #90EE90);
            border-color: #228B22;
        }

        .sub-category-node.new-subcategory,
        .sub-category-node-horizontal.new-subcategory {
            border: 3px solid #32CD32;
            box-shadow: 0 0 20px rgba(50, 205, 50, 0.6);
        }

        .sub-category-node.new-subcategory.expanded,
        .sub-category-node-horizontal.new-subcategory.expanded {
            background: linear-gradient(135deg, #32CD32, #90EE90);
            border-color: #228B22;
        }

        /* New Category Header Styles */
        .horizontal .main-category-header.new-category {
            background: linear-gradient(135deg, #32CD32, #90EE90) !important;
            border: 3px solid #228B22 !important;
            box-shadow: 0 0 20px rgba(50, 205, 50, 0.6) !important;
        }

        .upgrade-node:hover {
            transform: scale(1.1);
        }

        .upgrade-node.unlocked {
            background: #FF8C00;
            border-color: #FFA500;
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.4);
        }

        .upgrade-node.available {
            background: #F5F5F5;
            border-color: white;
            color: #333;
            animation: availablePulse 2s infinite;
        }

        .upgrade-node.selected {
            border-color: #FFA500;
            box-shadow: 0 0 25px rgba(255, 165, 0, 0.6);
        }

        .upgrade-node.locked {
            background: #404040;
            border-color: #666;
            opacity: 0.6;
        }

        @keyframes availablePulse {
            0%, 100% { border-color: white; }
            50% { border-color: #FF8C00; }
        }

        .upgrade-node .node-icon {
            font-size: 14px;
            margin-bottom: 1px;
        }

        .upgrade-node .node-level {
            font-size: 7px;
            font-weight: bold;
        }

        .upgrade-node .node-cost {
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #4169E1;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 4px;
            border-radius: 3px;
            white-space: nowrap;
        }

        .upgrade-node .lock-icon {
            position: absolute;
            top: -6px;
            right: -6px;
            background: #666;
            border-radius: 50%;
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7px;
        }

        /* Upgrade Details Panel */
        .upgrade-details {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 15px 25px;
            border-radius: 8px;
            border: 1px solid #FF8C00;
            min-width: 300px;
            text-align: center;
            z-index: 101;
        }

        .upgrade-name {
            font-size: 16px;
            font-weight: bold;
            color: #FF8C00;
            margin-bottom: 8px;
        }

        .upgrade-effect {
            font-size: 14px;
            color: #CCC;
            margin-bottom: 10px;
        }

        /* Unlock Interface */
        .unlock-interface {
            position: absolute;
            background: #2C2C2C;
            border: 2px solid #FF8C00;
            border-radius: 12px;
            padding: 20px;
            width: 300px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 140, 0, 0.4);
            z-index: 2000;
            display: none;
            animation: slideIn 0.3s ease-out;
        }

        .unlock-interface::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid #FF8C00;
        }

        .unlock-interface-icon {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .unlock-interface-title {
            font-size: 16px;
            font-weight: bold;
            color: #FF8C00;
            margin-bottom: 8px;
        }

        .unlock-interface-effect {
            font-size: 14px;
            color: #FFA500;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .unlock-interface-cost {
            font-size: 16px;
            font-weight: bold;
            color: #4169E1;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .unlock-interface-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .unlock-interface-button {
            padding: 8px 16px;
            font-size: 12px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 80px;
        }

        .unlock-interface-button.confirm {
            background: #32CD32;
            color: white;
        }

        .unlock-interface-button.confirm:hover {
            background: #228B22;
            transform: scale(1.05);
        }

        .unlock-interface-button.confirm:disabled {
            background: #DC143C;
            cursor: not-allowed;
            transform: none;
        }

        .unlock-interface-button.cancel {
            background: #666;
            color: white;
        }

        .unlock-interface-button.cancel:hover {
            background: #555;
            transform: scale(1.05);
        }

        /* Unlock Animation */
        @keyframes unlockSuccess {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); background: #32CD32; }
            100% { transform: scale(1); }
        }

        .upgrade-node.unlock-animation {
            animation: unlockSuccess 0.6s ease-out;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: #2C2C2C;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #FF8C00;
            font-size: 13px;
            color: white;
            z-index: 1000;
            pointer-events: none;
            width: 250px;
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.3);
        }

        .tooltip-icon {
            text-align: center;
            font-size: 32px;
            margin-bottom: 10px;
        }

        .tooltip-title {
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            color: #FF8C00;
            margin-bottom: 8px;
        }

        .tooltip-effect {
            text-align: center;
            font-size: 14px;
            color: #FFA500;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .tooltip-description {
            text-align: center;
            font-size: 12px;
            color: #CCC;
            margin-bottom: 10px;
            line-height: 1.3;
        }

        .tooltip-status {
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .tooltip-status.unlocked {
            background: #228B22;
            color: white;
        }

        .tooltip-status.locked {
            background: #666;
            color: #CCC;
        }

        .tooltip-status.available {
            background: #FF8C00;
            color: white;
        }

        /* Building Upgrade Comparison Table */
        .building-comparison-table {
            margin: 10px 0;
            border-collapse: collapse;
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: hidden;
        }

        .building-comparison-table th {
            background: linear-gradient(135deg, #FF8C00, #FFA500);
            color: white;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            border-bottom: 2px solid #FFB347;
        }

        .building-comparison-table td {
            padding: 6px 12px;
            font-size: 11px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 140, 0, 0.2);
        }

        .building-comparison-table tr:last-child td {
            border-bottom: none;
        }

        .building-comparison-table .level-cell {
            font-weight: bold;
            color: #FFA500;
            background: rgba(255, 140, 0, 0.1);
            width: 15%;
        }

        .building-comparison-table .before-cell {
            color: #CCC;
            background: rgba(100, 100, 100, 0.2);
            width: 30%;
        }

        .building-comparison-table .after-cell {
            color: #90EE90;
            background: rgba(144, 238, 144, 0.1);
            font-weight: bold;
            width: 30%;
        }

        .building-comparison-table .change-cell {
            width: 25%;
            font-weight: bold;
        }

        .building-comparison-table .change-up {
            color: #90EE90;
        }

        .building-comparison-table .change-down {
            color: #FFB347;
        }

        .building-comparison-table .change-new {
            color: #FFD700;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 5px #FFD700; }
            to { text-shadow: 0 0 15px #FFD700, 0 0 20px #FFD700; }
        }

        /* Responsive Design */
        @media (max-width: 1366px) {
            .meta-upgrade-modal {
                width: 95%;
                height: 90%;
            }
            
            .trees-content-wrapper {
                gap: 15px;
                padding: 15px;
            }
            
            .main-category-container {
                min-width: 200px;
                margin-right: 30px;
            }
            
            .sub-tree-container {
                min-width: 150px;
            }
            
            .upgrade-node {
                width: 50px;
                height: 50px;
            }
            
            .main-category-header {
                font-size: 16px;
            }
            
            .sub-tree-header {
                font-size: 12px;
            }
            
            .zoom-controls {
                top: 10px;
                right: 10px;
            }
            
            .zoom-button {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
        }

        @media (max-width: 768px) {
            .layout-toggle {
                top: 5px;
                left: 5px;
            }
            
            .toggle-option {
                padding: 8px 10px;
                font-size: 10px;
            }
            
            .toggle-icon {
                font-size: 12px;
            }
            
            .zoom-controls {
                top: 5px;
                right: 5px;
            }
            
            .zoom-button {
                width: 30px;
                height: 30px;
                font-size: 14px;
            }
            
            .zoom-indicator {
                font-size: 10px;
                padding: 3px 5px;
            }
            
            .trees-content-wrapper {
                gap: 10px;
                padding: 10px;
            }
            
            .horizontal .main-category-container {
                min-width: 150px;
                margin-right: 20px;
            }
            
            .horizontal .sub-tree-container {
                min-width: 120px;
            }
            
            .horizontal .upgrade-path {
                gap: 40px;
            }
            
            .horizontal .upgrade-node {
                width: 50px;
                height: 50px;
            }
            
            .horizontal .connection-line {
                width: 3px;
            }
        }
    </style>
</head>
<body>
    <!-- Game Background -->
    <div class="game-background"></div>

    <!-- Meta Upgrade Modal -->
    <div class="modal-overlay">
        <div class="meta-upgrade-modal">
            <!-- Close Button -->
            <button class="close-button" onclick="closeModal()">&times;</button>

            <!-- Top Section with RP Display Only -->
            <div class="top-section">
                <div class="rp-display">
                    <div class="rp-icon">
                        <i class="fas fa-flask"></i>
                    </div>
                    <div class="rp-content">
                        <div class="rp-amount" id="rpAmount">1000</div>
                        <div class="rp-label">Research Points</div>
                    </div>
                </div>
            </div>

            <!-- Main Content Area -->
            <div class="main-content">
                <!-- All Trees Container -->
                <div class="all-trees-container" id="allTreesContainer">
                    <!-- Layout Toggle -->
                    <div class="layout-toggle">
                        <button class="toggle-option active" id="radialToggle" data-layout="radial">
                            <span class="toggle-icon">üîò</span>
                            <span>Radial</span>
                        </button>
                        <button class="toggle-option" id="horizontalToggle" data-layout="horizontal">
                            <span class="toggle-icon">üìã</span>
                            <span>Horizontal</span>
                        </button>
                    </div>
                    
                    <!-- Zoom Controls -->
                    <div class="zoom-controls">
                        <button class="zoom-button" id="zoomInBtn">+</button>
                        <button class="zoom-button" id="zoomOutBtn">‚àí</button>
                        <button class="zoom-button" id="resetZoomBtn" style="font-size: 14px;">‚åÇ</button>
                        <div class="zoom-indicator" id="zoomIndicator">100%</div>
                    </div>
                    
                    <!-- Trees Content Wrapper -->
                    <div class="trees-content-wrapper" id="treesContentWrapper">
                        <!-- Dynamic content will be populated here -->
                    </div>
                </div>
            </div>

            <!-- Unlock Interface -->
            <div class="unlock-interface" id="unlockInterface">
                <div class="unlock-interface-icon" id="unlockInterfaceIcon">üî´</div>
                <div class="unlock-interface-title" id="unlockInterfaceTitle">Upgrade Name</div>
                <div class="unlock-interface-effect" id="unlockInterfaceEffect">Upgrade Effect</div>
                <div class="unlock-interface-cost" id="unlockInterfaceCost">
                    <i class="fas fa-flask"></i>
                    <span id="unlockInterfaceCostAmount">0 RP</span>
                </div>
                <div class="unlock-interface-buttons">
                    <button class="unlock-interface-button confirm" id="unlockInterfaceConfirm" onclick="confirmUnlock()">
                        UNLOCK
                    </button>
                    <button class="unlock-interface-button cancel" onclick="closeUnlockInterface()">
                        CANCEL
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game State
        let currentRP = 1000;
        let selectedUpgrade = null;
        let currentCategory = 'buildings';

        // Zoom and Pan State
        let currentZoom = 1;
        let currentPanX = 0;
        let currentPanY = 0;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let minZoom = 0.3;
        let maxZoom = 3;
        let zoomStep = 0.2;

        // Layout State
        let currentLayout = 'radial'; // 'radial' or 'horizontal'
        
        // Category Toggle State
        let expandedCategories = new Set(); // Track which categories are expanded
        let expandedSubCategories = new Set(); // Track which sub-categories are expanded

        // Upgrade Data with Sub-Categories - Updated to match Wiki Research System
        const upgradeData = {
           
            airstrike: {
                title: "Airstrike",
                subCategories: {
                    costReduction: {
                        title: "Cost Reduction",
                        description: "Reduces the resource cost of airstrike operations.",
                        upgrades: [
                            { id: 1, name: "Cheap Strikes", cost: 100, effect: "Airstrikes 10% cheaper", unlocked: false, icon: "üí∞" },
                            { id: 2, name: "Budget Operations", cost: 300, effect: "Airstrikes 20% cheaper", unlocked: false, icon: "üíé" },
                            { id: 3, name: "Efficient Bombing", cost: 900, effect: "Airstrikes 30% cheaper", unlocked: false, icon: "‚ö°" },
                            { id: 4, name: "Mass Production", cost: 1800, effect: "Airstrikes 50% cheaper", unlocked: false, icon: "üè≠" }
                        ]
                    },
                    usageCapacity: {
                        title: "Usage Capacity",
                        description: "Increases the maximum number of airstrikes available per night.",
                        upgrades: [
                            { id: 1, name: "Extra Sortie", cost: 100, effect: "+1 max airstrike per night", unlocked: false, icon: "‚úàÔ∏è" },
                            { id: 2, name: "Double Sortie", cost: 300, effect: "+1 max airstrike per night", unlocked: false, icon: "‚úàÔ∏è" },
                            { id: 3, name: "Triple Sortie", cost: 900, effect: "+1 max airstrike per night", unlocked: false, icon: "‚úàÔ∏è" },
                            { id: 4, name: "Maximum Sortie", cost: 1800, effect: "+1 max airstrike per night", unlocked: false, icon: "‚úàÔ∏è" }
                        ]
                    },
                    damageEnhancement: {
                        title: "Damage Enhancement",
                        description: "Dramatically increases the destructive power of airstrikes.",
                        upgrades: [
                            { id: 1, name: "Enhanced Ordinance", cost: 100, effect: "+50% airstrike damage", unlocked: false, icon: "üí£" },
                            { id: 2, name: "Devastating Strikes", cost: 300, effect: "+100% airstrike damage", unlocked: false, icon: "üí•" },
                            { id: 3, name: "One Shot", cost: 900, effect: "Airstrikes instantly destroy all enemies in target area", unlocked: false, icon: "üéØ" }
                        ]
                    },
                    tier2Plane: {
                        title: "Tier-2 Plane",
                        description: "Unlocks advanced aircraft with devastating multi-bomb capabilities.",
                        upgrades: [
                            { id: 1, name: "Tier-2 Bomber", cost: 1800, effect: "Unlocks tier-2 plane that launches 5 bombs at 1 strike!", unlocked: false, icon: "üöÅ" }
                        ]
                    }
                }
            },
            soldiers: {
                title: "Soldiers",
                subCategories: {
                    training: {
                        title: "Training",
                        description: "Enhances soldier level probabilities through RNG improvement when placing soldiers into combat positions.",
                        upgrades: [
                            { id: 1, name: "Basic Training", cost: 100, effect: "Increase chance of spawning higher level soldier", unlocked: false, icon: "ü•â" },
                            { id: 2, name: "Advanced Training", cost: 300, effect: "Increase chance of spawning higher level soldier", unlocked: false, icon: "ü•à" },
                            { id: 3, name: "Elite Training", cost: 900, effect: "Increase chance of spawning higher level soldier", unlocked: false, icon: "ü•á" },
                            { id: 4, name: "Special Forces", cost: 1800, effect: "Increase chance of spawning higher level soldier", unlocked: false, icon: "üéñÔ∏è" },
                            { id: 5, name: "Legendary Warriors", cost: 3600, effect: "Increase chance of spawning higher level soldier", unlocked: false, icon: "‚≠ê" }
                        ]
                    },
                    rangeEnhancement: {
                        title: "Range Enhancement",
                        description: "Extends the effective firing range of all soldiers.",
                        upgrades: [
                            { id: 1, name: "Extended Range", cost: 100, effect: "+10% soldier range", unlocked: false, icon: "üéØ" },
                            { id: 2, name: "Long Range", cost: 300, effect: "+20% soldier range", unlocked: false, icon: "üèπ" },
                            { id: 3, name: "Maximum Range", cost: 900, effect: "+30% soldier range", unlocked: false, icon: "üî≠" },
                            { id: 4, name: "Sniper Training", cost: 1800, effect: "+50% soldier range", unlocked: false, icon: "üéØ" }
                        ]
                    },
                    damageEnhancement: {
                        title: "Damage Enhancement",
                        description: "Increases the offensive power of all soldiers.",
                        upgrades: [
                            { id: 1, name: "High Damage", cost: 100, effect: "+25% soldier damage", unlocked: false, icon: "üí•" },
                            { id: 2, name: "Enhanced Firepower", cost: 300, effect: "+50% soldier damage", unlocked: false, icon: "üî•" },
                            { id: 3, name: "Devastating Force", cost: 900, effect: "+75% soldier damage", unlocked: false, icon: "üíÄ" },
                            { id: 4, name: "Lethal Precision", cost: 1800, effect: "+100% soldier damage", unlocked: false, icon: "‚ö°" }
                        ]
                    },
                    magazineCapacity: {
                        title: "Magazine Capacity",
                        description: "Improves ammunition efficiency and sustained fire capability.",
                        upgrades: [
                            { id: 1, name: "Extended Magazines", cost: 100, effect: "+20% magazine capacity", unlocked: false, icon: "üì¶" },
                            { id: 2, name: "Large Capacity", cost: 300, effect: "+40% magazine capacity", unlocked: false, icon: "üì¶" },
                            { id: 3, name: "High Capacity", cost: 900, effect: "+60% magazine capacity", unlocked: false, icon: "üì¶" },
                            { id: 4, name: "Maximum Capacity", cost: 1800, effect: "+100% magazine capacity", unlocked: false, icon: "üì¶" }
                        ]
                    }
                }
            },
            laboratory: {
                title: "Laboratory",
                subCategories: {
                    speed: {
                        title: "Research Speed",
                        description: "Reduces research completion time and accelerates discoveries.",
                        upgrades: [
                            { id: 1, name: "Rapid Research", cost: 100, effect: "Research 1 day faster", unlocked: false, icon: "‚ö°" },
                            { id: 2, name: "Accelerated Research", cost: 300, effect: "Research 2 days faster", unlocked: false, icon: "üöÄ" },
                            { id: 3, name: "Lightning Research", cost: 900, effect: "Research 3 days faster", unlocked: false, icon: "‚ö°" },
                            { id: 4, name: "Instant Research", cost: 1800, effect: "Research 4 days faster", unlocked: false, icon: "üí´" }
                        ]
                    },
                    efficiency: {
                        title: "Research Efficiency",
                        description: "Increases research point generation and resource efficiency.",
                        upgrades: [
                            { id: 1, name: "Efficient Research", cost: 100, effect: "+2% RP generation", unlocked: false, icon: "üî¨" },
                            { id: 2, name: "Optimized Research", cost: 300, effect: "+3% RP generation", unlocked: false, icon: "‚öóÔ∏è" },
                            { id: 3, name: "Advanced Research", cost: 900, effect: "+4% RP generation", unlocked: false, icon: "üß¨" },
                            { id: 4, name: "Quantum Research", cost: 1800, effect: "+5% RP generation", unlocked: false, icon: "üîÆ" }
                        ]
                    },
                    costReduction: {
                        title: "Cost Reduction",
                        description: "Reduces the research point cost of all meta upgrades.",
                        upgrades: [
                            { id: 1, name: "Cost Efficiency", cost: 100, effect: "5% reduction in all meta upgrade costs", unlocked: false, icon: "üí∞" },
                            { id: 2, name: "Optimized Studies", cost: 300, effect: "10% reduction in all meta upgrade costs", unlocked: false, icon: "üìä" },
                            { id: 3, name: "Advanced Methods", cost: 900, effect: "15% reduction in all meta upgrade costs", unlocked: false, icon: "üß™" },
                            { id: 4, name: "Research Mastery", cost: 1800, effect: "20% reduction in all meta upgrade costs", unlocked: false, icon: "üéì" },
                            { id: 5, name: "Ultimate Efficiency", cost: 3600, effect: "25% reduction in all meta upgrade costs", unlocked: false, icon: "‚ö°" }
                        ]
                    }
                }
            },
            walls: {
                title: "Walls",
                subCategories: {
                    offense: {
                        title: "Wall Offense",
                        description: "Adds damage and special effects to walls when attacked.",
                        upgrades: [
                            { id: 1, name: "Spiked Walls", cost: 100, effect: "Walls deal damage when attacked", unlocked: false, icon: "üî∫" },
                            { id: 2, name: "Enhanced Electric Walls", cost: 300, effect: "Increases electrical damage to attackers by +20%", unlocked: false, icon: "‚ö°" },
                            { id: 3, name: "Extended Electric Walls", cost: 900, effect: "+30% electrical damage", unlocked: false, icon: "‚ö°" },
                            { id: 4, name: "Maximum Electric Walls", cost: 1800, effect: "Increases electrical damage to attackers by +40%", unlocked: false, icon: "‚ö°" }
                        ]
                    },
                    durability: {
                        title: "Wall Durability",
                        description: "Increases the health and resilience of all wall segments.",
                        upgrades: [
                            { id: 1, name: "Reinforced Walls", cost: 100, effect: "+20% wall HP", unlocked: false, icon: "üõ°Ô∏è" },
                            { id: 2, name: "Hardened Walls", cost: 300, effect: "+25% wall HP", unlocked: false, icon: "üîí" },
                            { id: 3, name: "Armored Walls", cost: 900, effect: "+30% wall HP", unlocked: false, icon: "‚öîÔ∏è" },
                            { id: 4, name: "Impenetrable Walls", cost: 1800, effect: "+50% wall HP", unlocked: false, icon: "üõ°Ô∏è" }
                        ]
                    }
                }
            },
            support: {
                title: "Support",
                subCategories: {
                    phoenix: {
                        title: "Phoenix",
                        description: "Provides multiple chances to recover from defeat.",
                        upgrades: [
                            { id: 1, name: "Phoenix Rising", cost: 100, effect: "Revive ability (1 use per run)", unlocked: false, icon: "‚ù§Ô∏è" },
                            { id: 2, name: "Double Phoenix", cost: 300, effect: "Revive ability (2 uses per run)", unlocked: false, icon: "üíñ" },
                            { id: 3, name: "Eternal Phoenix", cost: 900, effect: "Revive ability (3 uses per run)", unlocked: false, icon: "üíù" }
                        ]
                    },
                    expeditions: {
                        title: "Expeditions",
                        description: "Improves expedition success rates, rewards, and completion time.",
                        upgrades: [
                            { id: 1, name: "Safe Expeditions", cost: 100, effect: "+20% survival rate", unlocked: false, icon: "üõ°Ô∏è" },
                            { id: 2, name: "Rich Rewards", cost: 300, effect: "+50% expedition rewards", unlocked: false, icon: "üí∞" },
                            { id: 3, name: "Swift Expeditions", cost: 900, effect: "Expeditions 1 day faster", unlocked: false, icon: "üí®" }
                        ]
                    },
                    specialists: {
                        title: "Specialists",
                        description: "Amplifies the beneficial effects provided by recruited specialists.",
                        upgrades: [
                            { id: 1, name: "Enhanced Specialists", cost: 100, effect: "Specialists buff effects +20%", unlocked: false, icon: "üë§" },
                            { id: 2, name: "Empowered Specialists", cost: 300, effect: "Specialist buff effects +25%", unlocked: false, icon: "‚ú®" },
                            { id: 3, name: "Legendary Specialists", cost: 900, effect: "Specialists buff effects +30%", unlocked: false, icon: "‚≠ê" }
                        ]
                    },
                    wallRegeneration: {
                        title: "Wall Regeneration",
                        description: "Provides automatic healing for defensive structures.",
                        upgrades: [
                            { id: 1, name: "Self Repair I", cost: 100, effect: "Main wall regenerates 1% HP each day", unlocked: false, icon: "üîß" },
                            { id: 2, name: "Self Repair II", cost: 300, effect: "Main wall regenerates 2% HP each day", unlocked: false, icon: "üîß" },
                            { id: 3, name: "Self Repair III", cost: 900, effect: "Main wall regenerates 3% HP each day", unlocked: false, icon: "üîß" },
                            { id: 4, name: "Rapid Recovery", cost: 1800, effect: "Main wall regenerates 5% HP each day", unlocked: false, icon: "üíö" }
                        ]
                    }
                }
            },
            farm: {
                title: "Farm",
                subCategories: {
                    harvestSpeed: {
                        title: "Harvest Speed",
                        description: "Reduces the time needed for crop harvests.",
                        upgrades: [
                            { id: 1, name: "Quick Harvest", cost: 100, effect: "Crops grow 1 day faster", unlocked: false, icon: "‚è∞" },
                            { id: 2, name: "Rapid Growth", cost: 300, effect: "Crops grow 1 day faster", unlocked: false, icon: "üí®" },
                            { id: 3, name: "Super Growth", cost: 900, effect: "Crops grow 1 day faster", unlocked: false, icon: "‚ö°" },
                            { id: 4, name: "Instant Harvest", cost: 1800, effect: "Crops grow 1 day faster", unlocked: false, icon: "üåü" }
                        ]
                    },
                    gridExpansion: {
                        title: "Grid Expansion",
                        description: "Adds more grid spaces to the farm for additional crops.",
                        upgrades: [
                            { id: 1, name: "Small Expansion", cost: 100, effect: "+1 crop grid expansion", unlocked: false, icon: "üöú" },
                            { id: 2, name: "Medium Expansion", cost: 300, effect: "+2 crop grid expansion", unlocked: false, icon: "üèûÔ∏è" },
                            { id: 3, name: "Large Expansion", cost: 900, effect: "+3 crop grid expansion", unlocked: false, icon: "üåæ" },
                            { id: 4, name: "Massive Expansion", cost: 1800, effect: "+4 crop grid expansion", unlocked: false, icon: "üåø" }
                        ]
                    },
                    harvestYield: {
                        title: "Harvest Yield",
                        description: "Increases the amount of crops harvested from each plot.",
                        upgrades: [
                            { id: 1, name: "Better Harvest", cost: 100, effect: "+10% crop harvest", unlocked: false, icon: "üåæ" },
                            { id: 2, name: "Rich Harvest", cost: 300, effect: "+15% crop harvest", unlocked: false, icon: "üåª" },
                            { id: 3, name: "Abundant Harvest", cost: 900, effect: "+20% crop harvest", unlocked: false, icon: "üåΩ" },
                            { id: 4, name: "Golden Harvest", cost: 1800, effect: "+25% crop harvest", unlocked: false, icon: "üåº" }
                        ]
                    }
                }
            },
            deck: {
                title: "Deck",
                subCategories: {
                    buildings: {
                        title: "Enhanced Buildings",
                        description: "Improves building card level probabilities through RNG enhancement.",
                        upgrades: [
                            { id: 1, name: "Enhanced Buildings", cost: 100, effect: "Chance to come to higher level building", unlocked: false, icon: "üè†" },
                            { id: 2, name: "Improved Buildings", cost: 300, effect: "Chance to come to higher level building", unlocked: false, icon: "üè¢" },
                            { id: 3, name: "Advanced Buildings", cost: 900, effect: "Chance to come to higher level building", unlocked: false, icon: "üè≠" },
                            { id: 4, name: "Superior Buildings", cost: 1800, effect: "Chance to come to higher level building", unlocked: false, icon: "üèóÔ∏è" },
                            { id: 5, name: "Master Buildings", cost: 3600, effect: "Chance to come to higher level building", unlocked: false, icon: "üèõÔ∏è" }
                        ]
                    },
                    reroll: {
                        title: "Reroll Cards",
                        description: "Adds flexibility to building selection with reroll functionality.",
                        upgrades: [
                            { id: 1, name: "Basic Reroll", cost: 100, effect: "Total reroll count 2", unlocked: false, icon: "üîÑ" },
                            { id: 2, name: "Extra Reroll", cost: 300, effect: "Total reroll count 3", unlocked: false, icon: "üîÑ" },
                            { id: 3, name: "More Rerolls", cost: 900, effect: "Total reroll count 4", unlocked: false, icon: "üîÑ" },
                            { id: 4, name: "Maximum Rerolls", cost: 1800, effect: "Total reroll count 5", unlocked: false, icon: "üîÑ" }
                        ]
                    },
                    specialCards: {
                        title: "Special Cards",
                        description: "Unlocks powerful transformation and swapping abilities.",
                        upgrades: [
                            { id: 1, name: "Joker Card", cost: 100, effect: "Unlocks JOKER card that transforms existing buildings into selected type", unlocked: false, icon: "üÉè" },
                            { id: 2, name: "Swap Card", cost: 300, effect: "Unlocks Swap Card that swaps selected buildings", unlocked: false, icon: "üîÑ" }
                        ]
                    },
                    cardManagement: {
                        title: "Card Management",
                        description: "Enhances card system flexibility and selection options.",
                        upgrades: [
                            { id: 1, name: "Card Lock I", cost: 100, effect: "Increase card lock count to 2", unlocked: false, icon: "üîí" },
                            { id: 2, name: "Extra Cards I", cost: 300, effect: "Building card count increases from 3 to 4", unlocked: false, icon: "üÉè" },
                            { id: 3, name: "Card Lock II", cost: 900, effect: "Increase card lock count to 3", unlocked: false, icon: "üîí" },
                            { id: 4, name: "Extra Cards II", cost: 1800, effect: "Building card count increases from 4 to 5", unlocked: false, icon: "üÉè" },
                            { id: 5, name: "Card Lock III", cost: 3600, effect: "Increase card lock count to 4", unlocked: false, icon: "üîí" }
                        ]
                    }
                }
            },
            garrison: {
                title: "Garrison",
                subCategories: {
                    basicGarrison: {
                        title: "Basic Garrison",
                        description: "Adds turrets to the left and right sides of walls.",
                        upgrades: [
                            { id: 1, name: "Basic Garrison", cost: 100, effect: "Adds 1 turret to the right and left sides of wall", unlocked: false, icon: "üî´" },
                            { id: 2, name: "Enhanced Garrison", cost: 300, effect: "Adds 1 turret to each side", unlocked: false, icon: "üî´" },
                            { id: 3, name: "Advanced Garrison", cost: 900, effect: "Adds 1 turret to each side", unlocked: false, icon: "üî´" },
                            { id: 4, name: "Master Garrison", cost: 1800, effect: "Adds 1 turret to each side", unlocked: false, icon: "üî´" }
                        ]
                    },
                    turretDamage: {
                        title: "Turret Damage",
                        description: "Increases the damage output of wall-mounted turrets.",
                        upgrades: [
                            { id: 1, name: "Enhanced Turret Damage", cost: 100, effect: "+5% wall turret damage", unlocked: false, icon: "üí•" },
                            { id: 2, name: "Upgraded Turret Damage", cost: 300, effect: "+10% wall turret damage", unlocked: false, icon: "üí•" },
                            { id: 3, name: "Devastating Turret Damage", cost: 900, effect: "+15% wall turret damage", unlocked: false, icon: "üí•" }
                        ]
                    },
                    fireRate: {
                        title: "Fire Rate",
                        description: "Increases the firing speed of wall-mounted turrets.",
                        upgrades: [
                            { id: 1, name: "Fast Turret", cost: 100, effect: "+10% wall turret fire rate", unlocked: false, icon: "‚ö°" },
                            { id: 2, name: "Swift Turret", cost: 300, effect: "+20% wall turret fire rate", unlocked: false, icon: "‚ö°" },
                            { id: 3, name: "Frenzied Turret", cost: 900, effect: "+30% wall turret fire rate", unlocked: false, icon: "‚ö°" }
                        ]
                    },
                    range: {
                        title: "Range",
                        description: "Extends the firing range of wall-mounted turrets.",
                        upgrades: [
                            { id: 1, name: "Extended Range", cost: 100, effect: "+5% wall turret range", unlocked: false, icon: "üéØ" },
                            { id: 2, name: "Enhanced Range", cost: 300, effect: "+10% wall turret range", unlocked: false, icon: "üéØ" },
                            { id: 3, name: "Maximum Range", cost: 900, effect: "+15% wall turret range", unlocked: false, icon: "üéØ" }
                        ]
                    }
                }
            },
            economy: {
                title: "Economy",
                subCategories: {
                    startingResources: {
                        title: "Starting Resources",
                        description: "Increases the amount of resources available at the beginning of each run.",
                        upgrades: [
                            { id: 1, name: "Starting Resources I", cost: 100, effect: "Start with +50% more resources", unlocked: false, icon: "üí∞" },
                            { id: 2, name: "Starting Resources II", cost: 300, effect: "Start with +75% more resources", unlocked: false, icon: "üíé" },
                            { id: 3, name: "Starting Resources III", cost: 900, effect: "Start with +100% more resources", unlocked: false, icon: "üëë" },
                            { id: 4, name: "Economic Foundation", cost: 1800, effect: "Start with +200% more resources", unlocked: false, icon: "üíé" }
                        ]
                    },
                    tradeMarketReroll: {
                        title: "Trade Market Reroll",
                        description: "Increases the number of times you can reroll the trade market to find better deals.",
                        upgrades: [
                            { id: 1, name: "Extra Reroll", cost: 100, effect: "+1 trade market reroll", unlocked: false, icon: "üîÑ" },
                            { id: 2, name: "Double Reroll", cost: 300, effect: "+1 trade market reroll", unlocked: false, icon: "üîÑ" },
                            { id: 3, name: "Triple Reroll", cost: 900, effect: "+1 trade market reroll", unlocked: false, icon: "üîÑ" }
                        ]
                    },
                    tradeEfficiency: {
                        title: "Trade Efficiency",
                        description: "Optimizes trade deals to provide better resource exchange rates.",
                        upgrades: [
                            { id: 1, name: "Trade Optimization", cost: 100, effect: "+10% trade efficiency", unlocked: false, icon: "üìà" },
                            { id: 2, name: "Advanced Trading", cost: 300, effect: "+50% trade efficiency", unlocked: false, icon: "üíπ" },
                            { id: 3, name: "Master Trader", cost: 900, effect: "+100% trade efficiency", unlocked: false, icon: "üèÜ" }
                        ]
                    }
                }
            },
            arsenalMastery: {
                title: "Arsenal Mastery",
                subCategories: {
                    machineGunMastery: {
                        title: "Machine Gun Mastery",
                        description: "Enhances machine gun effectiveness through specialized upgrades.",
                        upgrades: [
                            { id: 1, name: "Machine Gun Unlock", cost: 100, effect: "Unlocks Machine Gun weapon", unlocked: false, icon: "üî´" },
                            { id: 2, name: "Rapid Fire", cost: 300, effect: "+25% Machine Gun fire rate", unlocked: false, icon: "‚ö°" },
                            { id: 3, name: "High Caliber", cost: 900, effect: "+30% Machine Gun damage", unlocked: false, icon: "üí•" },
                            { id: 4, name: "Extended Barrel", cost: 1800, effect: "+20% Machine Gun range", unlocked: false, icon: "üéØ" }
                        ]
                    },
                    rocketLauncherMastery: {
                        title: "Rocket Launcher Mastery",
                        description: "Improves rocket launcher performance and destructive capability.",
                        upgrades: [
                            { id: 1, name: "Rocket Arsenal", cost: 100, effect: "Unlocks Rocket Launcher weapon", unlocked: false, icon: "üöÄ" },
                            { id: 2, name: "Fast Reload", cost: 300, effect: "+25% Rocket Launcher fire rate", unlocked: false, icon: "üîÑ" },
                            { id: 3, name: "Explosive Warheads", cost: 900, effect: "+40% Rocket Launcher damage", unlocked: false, icon: "üí£" },
                            { id: 4, name: "Long Range", cost: 1800, effect: "+25% Rocket Launcher range", unlocked: false, icon: "üéØ" }
                        ]
                    },
                    mortarMastery: {
                        title: "Mortar Mastery",
                        description: "Enhances mortar artillery support and area denial capabilities.",
                        upgrades: [
                            { id: 1, name: "Artillery Support", cost: 100, effect: "Unlocks Mortar weapon", unlocked: false, icon: "üí•" },
                            { id: 2, name: "Quick Loading", cost: 300, effect: "+20% Mortar fire rate", unlocked: false, icon: "‚ö°" },
                            { id: 3, name: "Heavy Shells", cost: 900, effect: "+50% Mortar damage", unlocked: false, icon: "üí£" },
                            { id: 4, name: "Extended Range", cost: 1800, effect: "+30% Mortar range", unlocked: false, icon: "üéØ" }
                        ]
                    },
                    turretMastery: {
                        title: "Turret Mastery",
                        description: "Maximizes turret precision and defensive effectiveness.",
                        upgrades: [
                            { id: 1, name: "Precision Weapons", cost: 100, effect: "Unlocks Turret", unlocked: false, icon: "üóº" },
                            { id: 2, name: "Steady Aim", cost: 300, effect: "+15% Turret fire rate", unlocked: false, icon: "üéØ" },
                            { id: 3, name: "Armor Piercing", cost: 900, effect: "+60% Turret damage", unlocked: false, icon: "üí•" },
                            { id: 4, name: "Scope Enhancement", cost: 1800, effect: "+40% Turret range", unlocked: false, icon: "üîç" }
                        ]
                    }
                }
            },
            zombieWeakness: {
                title: "Zombie Weakness",
                subCategories: {
                    speedReduction: {
                        title: "Speed Reduction",
                        description: "Slows zombie movement to provide tactical advantages.",
                        upgrades: [
                            { id: 1, name: "Slow Plague", cost: 100, effect: "Zombies move 10% slower", unlocked: false, icon: "üêå" },
                            { id: 2, name: "Heavy Limbs", cost: 300, effect: "Zombies move 15% slower", unlocked: false, icon: "‚öñÔ∏è" },
                            { id: 3, name: "Paralysis", cost: 900, effect: "Zombies move 20% slower", unlocked: false, icon: "üßä" }
                        ]
                    },
                    healthReduction: {
                        title: "Health Reduction",
                        description: "Reduces zombie durability and survivability.",
                        upgrades: [
                            { id: 1, name: "Viral Decay", cost: 100, effect: "Zombies have 15% less HP", unlocked: false, icon: "ü¶†" },
                            { id: 2, name: "Cellular Breakdown", cost: 300, effect: "Zombies have 25% less HP", unlocked: false, icon: "üíÄ" },
                            { id: 3, name: "Complete Deterioration", cost: 900, effect: "Zombies have 35% less HP", unlocked: false, icon: "‚ò†Ô∏è" }
                        ]
                    },
                    damageReduction: {
                        title: "Damage Reduction",
                        description: "Weakens zombie offensive capabilities.",
                        upgrades: [
                            { id: 1, name: "Weakened Claws", cost: 100, effect: "Zombies deal 15% less damage", unlocked: false, icon: "ü©π" },
                            { id: 2, name: "Muscle Atrophy", cost: 300, effect: "Zombies deal 25% less damage", unlocked: false, icon: "üí™" },
                            { id: 3, name: "Complete Weakness", cost: 900, effect: "Zombies deal 35% less damage", unlocked: false, icon: "ü§ï" }
                        ]
                    }
                }
            },
            landmineEnhancement: {
                title: "Landmine Enhancement",
                subCategories: {
                    damageEnhancement: {
                        title: "Damage Enhancement",
                        description: "Increases the destructive power of landmine explosions.",
                        upgrades: [
                            { id: 1, name: "Improved Explosives", cost: 100, effect: "+25% landmine damage", unlocked: false, icon: "üí•" },
                            { id: 2, name: "High Yield", cost: 300, effect: "+50% landmine damage", unlocked: false, icon: "üí£" },
                            { id: 3, name: "Devastation", cost: 900, effect: "+75% landmine damage", unlocked: false, icon: "üî•" }
                        ]
                    },
                    areaOfEffect: {
                        title: "Area of Effect",
                        description: "Expands the blast radius of landmine explosions.",
                        upgrades: [
                            { id: 1, name: "Wider Blast", cost: 100, effect: "+20% landmine AoE", unlocked: false, icon: "üí®" },
                            { id: 2, name: "Extended Range", cost: 300, effect: "+35% landmine AoE", unlocked: false, icon: "üåä" },
                            { id: 3, name: "Massive Explosion", cost: 900, effect: "+50% landmine AoE", unlocked: false, icon: "üåã" }
                        ]
                    }
                }
            },
            criticalStrike: {
                title: "Critical Strike",
                subCategories: {
                    criticalChance: {
                        title: "Critical Chance",
                        description: "Increases the probability of landing critical hits.",
                        upgrades: [
                            { id: 1, name: "Lucky Strikes", cost: 100, effect: "+1% critical hit chance for all units", unlocked: false, icon: "üçÄ" },
                            { id: 2, name: "Precision Training", cost: 300, effect: "+2% critical hit chance for all units", unlocked: false, icon: "üéØ" },
                            { id: 3, name: "Master Marksman", cost: 900, effect: "+3% critical hit chance for all units", unlocked: false, icon: "üèπ" },
                            { id: 4, name: "Lethal Force", cost: 1800, effect: "+5% critical hit chance for all units", unlocked: false, icon: "üíÄ" }
                        ]
                    },
                    criticalDamage: {
                        title: "Critical Damage",
                        description: "Amplifies the damage dealt by critical hits.",
                        upgrades: [
                            { id: 1, name: "Enhanced Lethality", cost: 100, effect: "+25% critical damage", unlocked: false, icon: "‚ö°" },
                            { id: 2, name: "Devastating Strikes", cost: 300, effect: "+50% critical damage", unlocked: false, icon: "üí•" },
                            { id: 3, name: "Overwhelming Force", cost: 900, effect: "+75% critical damage", unlocked: false, icon: "üî•" },
                            { id: 4, name: "Ultimate Destruction", cost: 1800, effect: "+100% critical damage", unlocked: false, icon: "üíÄ" }
                        ]
                    }
                }
            }
        };

        // Initialize the interface
        function init() {
            // Initialize all categories as expanded
            Object.keys(upgradeData).forEach(categoryKey => {
                expandedCategories.add(categoryKey);
                // Initialize all sub-categories as expanded
                Object.keys(upgradeData[categoryKey].subCategories).forEach(subCategoryKey => {
                    expandedSubCategories.add(`${categoryKey}_${subCategoryKey}`);
                });
            });
            
            updateRPDisplay();
            renderUpgradeTrees();
            initializeView();
            setupEventListeners();
        }

        // Setup event listeners
        function setupEventListeners() {
            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeModal();
                } else if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    zoomIn();
                } else if (e.key === '-' || e.key === '_') {
                    e.preventDefault();
                    zoomOut();
                } else if (e.key === '0' || e.key === 'Home') {
                    e.preventDefault();
                    resetZoom();
                }
            });

            // Zoom and Pan Event Listeners
            setupZoomAndPanListeners();

            // Layout Toggle Event Listeners
            setupLayoutToggle();
        }

        // Setup zoom and pan functionality
        function setupZoomAndPanListeners() {
            const container = document.getElementById('allTreesContainer');
            const wrapper = document.getElementById('treesContentWrapper');
            
            // Zoom Controls
            document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
            document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
            document.getElementById('resetZoomBtn').addEventListener('click', resetZoom);
            
            // Mouse wheel zoom
            container.addEventListener('wheel', function(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -zoomStep : zoomStep;
                zoom(delta, e.clientX, e.clientY);
            });
            
            // Mouse panning
            container.addEventListener('mousedown', startPanning);
            document.addEventListener('mousemove', updatePanning);
            document.addEventListener('mouseup', stopPanning);
            
            // Touch events for mobile
            container.addEventListener('touchstart', handleTouchStart, { passive: false });
            container.addEventListener('touchmove', handleTouchMove, { passive: false });
            container.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            // Prevent context menu on right click
            container.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });
        }

        // Zoom Functions
        function zoomIn() {
            zoom(zoomStep);
        }

        function zoomOut() {
            zoom(-zoomStep);
        }

        function resetZoom() {
            currentZoom = 1;
            currentPanX = 0;
            currentPanY = 0;
            updateTransform();
        }

        function zoom(delta, clientX, clientY) {
            const newZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom + delta));
            
            if (newZoom !== currentZoom) {
                // If mouse position is provided, zoom towards that point
                if (clientX !== undefined && clientY !== undefined) {
                    const container = document.getElementById('allTreesContainer');
                    const rect = container.getBoundingClientRect();
                    const mouseX = clientX - rect.left;
                    const mouseY = clientY - rect.top;
                    
                    // Calculate the zoom center relative to the wrapper
                    const zoomCenterX = (mouseX - currentPanX) / currentZoom;
                    const zoomCenterY = (mouseY - currentPanY) / currentZoom;
                    
                    // Update zoom
                    currentZoom = newZoom;
                    
                    // Adjust pan to keep the zoom center in place
                    currentPanX = mouseX - zoomCenterX * currentZoom;
                    currentPanY = mouseY - zoomCenterY * currentZoom;
                } else {
                    currentZoom = newZoom;
                }
                
                updateTransform();
            }
        }

        // Panning Functions
        function startPanning(e) {
            if (e.button !== 0) return; // Only left mouse button
            isPanning = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            document.getElementById('allTreesContainer').classList.add('panning');
            e.preventDefault();
        }

        function updatePanning(e) {
            if (!isPanning) return;
            
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            
            currentPanX += deltaX;
            currentPanY += deltaY;
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            updateTransform();
        }

        function stopPanning() {
            isPanning = false;
            document.getElementById('allTreesContainer').classList.remove('panning');
        }

        // Touch Events for Mobile
        let touchStartX = 0;
        let touchStartY = 0;
        let initialDistance = 0;
        let initialZoom = 1;

        function handleTouchStart(e) {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                // Single touch - start panning
                isPanning = true;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                lastMouseX = touchStartX;
                lastMouseY = touchStartY;
            } else if (e.touches.length === 2) {
                // Two touches - start zooming
                isPanning = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                initialDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                initialZoom = currentZoom;
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 1 && isPanning) {
                // Single touch - panning
                const deltaX = e.touches[0].clientX - lastMouseX;
                const deltaY = e.touches[0].clientY - lastMouseY;
                
                currentPanX += deltaX;
                currentPanY += deltaY;
                
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
                
                updateTransform();
            } else if (e.touches.length === 2) {
                // Two touches - zooming
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                const zoomRatio = currentDistance / initialDistance;
                const newZoom = Math.max(minZoom, Math.min(maxZoom, initialZoom * zoomRatio));
                
                if (newZoom !== currentZoom) {
                    currentZoom = newZoom;
                    updateTransform();
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            isPanning = false;
        }

        // Update the transform of the wrapper
        function updateTransform() {
            const wrapper = document.getElementById('treesContentWrapper');
            
            if (currentLayout === 'radial') {
                const baseTransform = 'translate(-50%, -50%)';
                const zoomTransform = `translate(${currentPanX}px, ${currentPanY}px) scale(${currentZoom})`;
                wrapper.style.transform = `${baseTransform} ${zoomTransform}`;
            } else {
                // For horizontal layout, use simpler transform
                wrapper.style.transform = `translate(${currentPanX}px, ${currentPanY}px) scale(${currentZoom})`;
            }
            
            // Update zoom indicator
            document.getElementById('zoomIndicator').textContent = Math.round(currentZoom * 100) + '%';
        }

        // Initialize view to center on hub
        function initializeView() {
            if (currentLayout === 'radial') {
                currentZoom = 0.6; // Start zoomed out to see more of the tree
                currentPanX = 0;
                currentPanY = 0;
            } else {
                currentZoom = 1;
                currentPanX = 0;
                currentPanY = 0;
            }
            updateTransform();
        }

        // Setup layout toggle functionality
        function setupLayoutToggle() {
            document.getElementById('radialToggle').addEventListener('click', () => switchLayout('radial'));
            document.getElementById('horizontalToggle').addEventListener('click', () => switchLayout('horizontal'));
        }

        // Switch between layouts
        function switchLayout(layout) {
            if (currentLayout === layout) return;
            
            currentLayout = layout;
            
            // Update toggle buttons
            document.querySelectorAll('.toggle-option').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(layout + 'Toggle').classList.add('active');
            
            // Re-render with new layout
            if (layout === 'radial') {
                renderRadialTrees();
            } else {
                renderHorizontalTrees();
            }
            
            // Reset view
            initializeView();
        }

        // Main render function - delegates to layout-specific functions
        function renderUpgradeTrees() {
            if (currentLayout === 'radial') {
                renderRadialTrees();
            } else {
                renderHorizontalTrees();
            }
        }

        // Render radial skill tree
        function renderRadialTrees() {
            const treesContentWrapper = document.getElementById('treesContentWrapper');
            treesContentWrapper.innerHTML = '';
            treesContentWrapper.className = 'trees-content-wrapper'; // Remove horizontal class
            
            // Create central hub
            const centralHub = document.createElement('div');
            centralHub.className = 'central-hub';
            centralHub.innerHTML = `
                <div class="central-hub-icon">‚ö°</div>
                <div>META<br>UPGRADES</div>
            `;
            treesContentWrapper.appendChild(centralHub);
            
            // Get category keys and calculate positions
            const categoryKeys = Object.keys(upgradeData);
            const centerX = 1000; // Center of the 2000px container
            const centerY = 1000;
            const mainRadius = 300; // Distance from center to main categories
            
            // Calculate angular space per category for collision avoidance
            const totalCategories = categoryKeys.length;
            const angularSpacePerCategory = (2 * Math.PI) / totalCategories;
            
                         // Render main categories in a circle
             categoryKeys.forEach((categoryKey, categoryIndex) => {
                 const categoryData = upgradeData[categoryKey];
                 // Start at top (90 degrees offset) and distribute evenly
                 const angle = (categoryIndex / categoryKeys.length) * 2 * Math.PI - Math.PI / 2;
                 
                 // Calculate main category position
                 const mainCategoryX = centerX + Math.cos(angle) * mainRadius;
                 const mainCategoryY = centerY + Math.sin(angle) * mainRadius;
                
                // Create connection from center to main category
                const centerConnection = document.createElement('div');
                centerConnection.className = 'radial-connection radial-connection-animate';
                centerConnection.dataset.category = categoryKey;
                centerConnection.style.left = centerX + 'px';
                centerConnection.style.top = centerY + 'px';
                centerConnection.style.width = mainRadius + 'px';
                centerConnection.style.setProperty('--rotation', `${angle}rad`);
                centerConnection.style.transform = `rotate(${angle}rad)`;
                
                // Clean animation classes
                centerConnection.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                
                // If this category is preparing to open, make connections invisible initially
                if (window.preparingToOpen === categoryKey) {
                    centerConnection.classList.add('prepare-opening');
                }
                
                treesContentWrapper.appendChild(centerConnection);
                
                // Create main category node
                const mainCategoryNode = document.createElement('div');
                mainCategoryNode.className = 'main-category-node';
                mainCategoryNode.style.left = (mainCategoryX - 40) + 'px';
                mainCategoryNode.style.top = (mainCategoryY - 40) + 'px';
                
                // Get first sub-category for icon
                const firstSubKey = Object.keys(categoryData.subCategories)[0];
                const icon = getIconForCategory(categoryKey);
                
                mainCategoryNode.innerHTML = `
                    <div class="main-category-icon">${icon}</div>
                    <div class="main-category-title">${categoryData.title.toUpperCase()}</div>
                `;
                
                // Add toggle functionality
                const isExpanded = expandedCategories.has(categoryKey);
                mainCategoryNode.classList.add(isExpanded ? 'expanded' : 'collapsed');
                
                // Add new category styling
                if (categoryData.isNew) {
                    mainCategoryNode.classList.add('new-category');
                }
                
                mainCategoryNode.addEventListener('click', () => toggleCategory(categoryKey));
                
                treesContentWrapper.appendChild(mainCategoryNode);
                
                // Only render child nodes if category is expanded
                if (!isExpanded) {
                    return; // Skip rendering child nodes for collapsed categories
                }
                
                // Check if this category has multiple sub-categories
                const subCategoryKeys = Object.keys(categoryData.subCategories);
                const subCategoryDistance = 120; // Distance from main category to sub-category nodes
                const upgradeRadius = 100; // Distance between upgrade levels (increased for more space)
                
                // Only show sub-category nodes for categories that truly have distinct sub-categories
                const showSubCategoryNodes = (categoryKey === 'economy' || categoryKey === 'combat' || categoryKey === 'support' || categoryKey === 'laboratory' || categoryKey === 'walls' || categoryKey === 'farm' || categoryKey === 'deck' || categoryKey === 'garrison' || categoryKey === 'arsenal' || categoryKey === 'zombieWeakness' || categoryKey === 'landmine' || categoryKey === 'critical') && subCategoryKeys.length > 1;
                
                if (showSubCategoryNodes) {
                    // Multiple sub-categories: render each as a separate branch
                    // Calculate maximum safe arc span to prevent collisions
                    const maxUpgrades = Math.max(...subCategoryKeys.map(key => categoryData.subCategories[key].upgrades.length));
                    const maxExtension = subCategoryDistance + (upgradeRadius * maxUpgrades); // How far the longest branch extends
                    
                    // Calculate safe arc span based on angular space and extension distance
                    // Use trigonometry: at distance maxExtension, the arc length should not exceed neighboring category space
                    // Increased safety margin and base spacing to prevent collisions and allow for future expansion
                    const safeArcLength = angularSpacePerCategory * maxExtension * 1.4; // 140% of available space for better spacing
                    const safeArcSpan = Math.min(safeArcLength / maxExtension, angularSpacePerCategory * 1.2); // Increased from 0.8 to 1.2
                    
                    subCategoryKeys.forEach((subCategoryKey, subIndex) => {
                        const subCategoryData = categoryData.subCategories[subCategoryKey];
                        
                        // Calculate branch angle using the mathematically safe arc span
                        let branchAngle;
                        if (subCategoryKeys.length === 2) {
                            // For 2 sub-categories, place them at calculated safe angles with increased spacing
                            const angleOffset = safeArcSpan / 3; // Increased from /4 to /3 for more spacing
                            branchAngle = angle + (subIndex === 0 ? -angleOffset : angleOffset);
                        } else {
                            // For 3+ sub-categories, distribute them within the safe arc span
                            const angleStep = safeArcSpan / (subCategoryKeys.length - 1);
                            branchAngle = angle + (subIndex * angleStep) - (safeArcSpan / 2);
                        }
                        
                        // Calculate sub-category node position
                        const subCategoryX = mainCategoryX + Math.cos(branchAngle) * subCategoryDistance;
                        const subCategoryY = mainCategoryY + Math.sin(branchAngle) * subCategoryDistance;
                        
                        // Create sub-category node
                        const subCategoryNode = document.createElement('div');
                        subCategoryNode.className = 'sub-category-node skill-node-animate';
                        subCategoryNode.dataset.category = categoryKey;
                        subCategoryNode.dataset.subCategory = subCategoryKey;
                        subCategoryNode.style.left = (subCategoryX - 30) + 'px';
                        subCategoryNode.style.top = (subCategoryY - 30) + 'px';
                        
                        // Clean animation classes
                        subCategoryNode.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                        
                        // If this category is preparing to open, make nodes invisible initially
                        if (window.preparingToOpen === categoryKey) {
                            subCategoryNode.classList.add('prepare-opening');
                        }
                        
                        // If this sub-category is preparing to open, make nodes invisible initially
                        const subCategoryId = `${categoryKey}_${subCategoryKey}`;
                        if (window.preparingToOpenSub === subCategoryId) {
                            subCategoryNode.classList.add('prepare-opening');
                        }
                        
                        // Add visual state based on expansion
                        const isSubCategoryExpanded = expandedSubCategories.has(subCategoryId);
                        subCategoryNode.classList.add(isSubCategoryExpanded ? 'expanded' : 'collapsed');
                        
                        // Add new sub-category styling
                        if (subCategoryData.isNew) {
                            subCategoryNode.classList.add('new-subcategory');
                        }
                        
                        // Sub-category node content
                        let subCategoryIcon = '';
                        if (subCategoryKey === 'starting') subCategoryIcon = 'üí∞';
                        else if (subCategoryKey === 'training') subCategoryIcon = 'üéñÔ∏è';
                        else if (subCategoryKey === 'weapons') subCategoryIcon = 'üî´';
                        else if (subCategoryKey === 'airstrike') subCategoryIcon = '‚úàÔ∏è';
                        else if (subCategoryKey === 'expeditions') subCategoryIcon = 'üó∫Ô∏è';
                        else if (subCategoryKey === 'specialists') subCategoryIcon = 'üë§';
                        else if (subCategoryKey === 'phoenix') subCategoryIcon = '‚ù§Ô∏è';
                        else if (subCategoryKey === 'speed') subCategoryIcon = '‚ö°';
                        else if (subCategoryKey === 'efficiency') subCategoryIcon = 'üî¨';
                        else if (subCategoryKey === 'offense') subCategoryIcon = '‚ö°';
                        else if (subCategoryKey === 'durability') subCategoryIcon = 'üõ°Ô∏è';
                        else if (subCategoryKey === 'regeneration') subCategoryIcon = 'üîß';
                        else if (subCategoryKey === 'grid') subCategoryIcon = 'üèûÔ∏è';
                        else if (subCategoryKey === 'yield') subCategoryIcon = 'üåæ';
                        else if (subCategoryKey === 'buildings') subCategoryIcon = 'üè†';
                        else if (subCategoryKey === 'reroll') subCategoryIcon = 'üîÑ';
                        else if (subCategoryKey === 'joker') subCategoryIcon = 'üÉè';
                        else if (subCategoryKey === 'management') subCategoryIcon = 'üîí';
                        else if (subCategoryKey === 'deployment') subCategoryIcon = 'üî´';
                        else if (subCategoryKey === 'damage') subCategoryIcon = 'üí•';
                        else if (subCategoryKey === 'fireRate') subCategoryIcon = '‚ö°';
                        else if (subCategoryKey === 'range') subCategoryIcon = 'üéØ';
                        else if (subCategoryKey === 'machineGun') subCategoryIcon = 'üî´';
                        else if (subCategoryKey === 'rocketLauncher') subCategoryIcon = 'üöÄ';
                        else if (subCategoryKey === 'mortar') subCategoryIcon = 'üí•';
                        else if (subCategoryKey === 'turret') subCategoryIcon = 'üóº';
                        else if (subCategoryKey === 'health') subCategoryIcon = 'üíÄ';
                        else if (subCategoryKey === 'aoe') subCategoryIcon = 'üí®';
                        else if (subCategoryKey === 'chance') subCategoryIcon = 'üçÄ';
                        else if (subCategoryKey === 'costReduction') subCategoryIcon = 'üí∞';
                        else subCategoryIcon = '‚ö°';
                        
                        subCategoryNode.innerHTML = `
                            <div class="node-icon">${subCategoryIcon}</div>
                            <div class="node-level">${subCategoryData.title}</div>
                            ${subCategoryData.isNew ? '<div class="new-badge">NEW</div>' : ''}
                        `;
                        
                        // Add click event to toggle sub-category
                        subCategoryNode.addEventListener('click', () => toggleSubCategory(categoryKey, subCategoryKey));
                        
                        treesContentWrapper.appendChild(subCategoryNode);
                        
                        // Create connection line from main category to sub-category
                        const mainToSubConnection = document.createElement('div');
                        mainToSubConnection.className = 'radial-connection radial-connection-animate';
                        mainToSubConnection.dataset.category = categoryKey;
                        mainToSubConnection.style.left = mainCategoryX + 'px';
                        mainToSubConnection.style.top = mainCategoryY + 'px';
                        mainToSubConnection.style.width = subCategoryDistance + 'px';
                        mainToSubConnection.style.setProperty('--rotation', `${branchAngle}rad`);
                        mainToSubConnection.style.transform = `rotate(${branchAngle}rad)`;
                        
                        // Clean animation classes
                        mainToSubConnection.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                        
                        // If this category is preparing to open, make connections invisible initially
                        if (window.preparingToOpen === categoryKey) {
                            mainToSubConnection.classList.add('prepare-opening');
                        }
                        
                        treesContentWrapper.appendChild(mainToSubConnection);
                        
                        // Only render upgrades if sub-category is expanded
                        if (isSubCategoryExpanded) {
                            // Render upgrades for this sub-category branch
                            subCategoryData.upgrades.forEach((upgrade, upgradeIndex) => {
                            const upgradeDistance = upgradeRadius * (upgradeIndex + 1);
                            const upgradeX = subCategoryX + Math.cos(branchAngle) * upgradeDistance;
                            const upgradeY = subCategoryY + Math.sin(branchAngle) * upgradeDistance;
                            
                            // Create connection line from sub-category to upgrades
                            if (upgradeIndex === 0) {
                                const subToUpgradeConnection = document.createElement('div');
                                subToUpgradeConnection.className = 'radial-connection radial-connection-animate';
                                subToUpgradeConnection.dataset.category = categoryKey;
                                subToUpgradeConnection.dataset.subCategory = subCategoryKey;
                                subToUpgradeConnection.style.left = subCategoryX + 'px';
                                subToUpgradeConnection.style.top = subCategoryY + 'px';
                                subToUpgradeConnection.style.width = (upgradeRadius * subCategoryData.upgrades.length) + 'px';
                                subToUpgradeConnection.style.setProperty('--rotation', `${branchAngle}rad`);
                                subToUpgradeConnection.style.transform = `rotate(${branchAngle}rad)`;
                                
                                // Clean animation classes
                                subToUpgradeConnection.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                                
                                // If this category is preparing to open, make connections invisible initially
                                if (window.preparingToOpen === categoryKey) {
                                    subToUpgradeConnection.classList.add('prepare-opening');
                                }
                                
                                // If this sub-category is preparing to open, make connections invisible initially
                                const subCategoryId = `${categoryKey}_${subCategoryKey}`;
                                if (window.preparingToOpenSub === subCategoryId) {
                                    subToUpgradeConnection.classList.add('prepare-opening');
                                }
                                
                                treesContentWrapper.appendChild(subToUpgradeConnection);
                            }
                            
                            // Create upgrade node
                            const upgradeNode = document.createElement('div');
                            upgradeNode.className = 'upgrade-node skill-node-animate';
                            upgradeNode.dataset.upgradeId = upgrade.id;
                            upgradeNode.dataset.category = categoryKey;
                            upgradeNode.dataset.subCategory = subCategoryKey;
                            upgradeNode.style.left = (upgradeX - 25) + 'px';
                            upgradeNode.style.top = (upgradeY - 25) + 'px';
                            
                            // Clean animation classes
                            upgradeNode.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                            
                            // If this category is preparing to open, make nodes invisible initially
                            if (window.preparingToOpen === categoryKey) {
                                upgradeNode.classList.add('prepare-opening');
                            }
                            
                            // If this sub-category is preparing to open, make nodes invisible initially
                            const subCategoryId = `${categoryKey}_${subCategoryKey}`;
                            if (window.preparingToOpenSub === subCategoryId) {
                                upgradeNode.classList.add('prepare-opening');
                            }
                            
                            // Determine node state based on prerequisite progression within sub-category
                            if (upgrade.unlocked) {
                                upgradeNode.classList.add('unlocked');
                            } else if (upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked) {
                                upgradeNode.classList.add('available');
                            } else {
                                upgradeNode.classList.add('locked');
                            }
                            
                            // Add selection state
                            if (selectedUpgrade && selectedUpgrade.id === upgrade.id && 
                                selectedUpgrade.category === categoryKey && 
                                selectedUpgrade.subCategory === subCategoryKey) {
                                upgradeNode.classList.add('selected');
                            }
                            
                            // Add new upgrade styling
                            if (upgrade.isNew) {
                                upgradeNode.classList.add('new-upgrade');
                            }
                            
                            // Node content
                            upgradeNode.innerHTML = `
                                <div class="node-icon">${upgrade.icon}</div>
                                <div class="node-level">Lv.${upgrade.id}</div>
                                ${!upgrade.unlocked ? `<div class="node-cost">${upgrade.cost} RP</div>` : ''}
                                ${upgradeNode.classList.contains('locked') ? '<div class="lock-icon">üîí</div>' : ''}
                                ${upgrade.isNew ? '<div class="new-badge">NEW</div>' : ''}
                            `;
                            
                            // Add click event
                            if (!upgrade.unlocked && (upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked)) {
                                upgradeNode.addEventListener('click', (event) => selectUpgrade(upgrade, categoryKey, subCategoryKey, event));
                            }
                            
                            // Add hover tooltip
                            upgradeNode.addEventListener('mouseenter', (e) => showTooltip(e, upgrade));
                            upgradeNode.addEventListener('mouseleave', hideTooltip);
                            
                            treesContentWrapper.appendChild(upgradeNode);
                        });
                        }
                    });
                } else {
                    // Handle categories without sub-category nodes
                    if (subCategoryKeys.length === 1) {
                        // Single sub-category: render as a single line directly from main category
                        const subCategoryKey = subCategoryKeys[0];
                        const subCategoryData = categoryData.subCategories[subCategoryKey];
                        
                        subCategoryData.upgrades.forEach((upgrade, upgradeIndex) => {
                            const upgradeDistance = upgradeRadius * (upgradeIndex + 1);
                            const upgradeX = mainCategoryX + Math.cos(angle) * upgradeDistance;
                            const upgradeY = mainCategoryY + Math.sin(angle) * upgradeDistance;
                            
                            // Create connection line from main category to upgrades
                            if (upgradeIndex === 0) {
                                const upgradeConnection = document.createElement('div');
                                upgradeConnection.className = 'radial-connection radial-connection-animate';
                                upgradeConnection.dataset.category = categoryKey;
                                upgradeConnection.style.left = mainCategoryX + 'px';
                                upgradeConnection.style.top = mainCategoryY + 'px';
                                upgradeConnection.style.width = (upgradeRadius * subCategoryData.upgrades.length) + 'px';
                                upgradeConnection.style.setProperty('--rotation', `${angle}rad`);
                                upgradeConnection.style.transform = `rotate(${angle}rad)`;
                                
                                // Clean animation classes
                                upgradeConnection.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                                
                                // If this category is preparing to open, make connections invisible initially
                                if (window.preparingToOpen === categoryKey) {
                                    upgradeConnection.classList.add('prepare-opening');
                                }
                                
                                treesContentWrapper.appendChild(upgradeConnection);
                            }
                            
                            // Create upgrade node
                            const upgradeNode = document.createElement('div');
                            upgradeNode.className = 'upgrade-node skill-node-animate';
                            upgradeNode.dataset.upgradeId = upgrade.id;
                            upgradeNode.dataset.category = categoryKey;
                            upgradeNode.dataset.subCategory = subCategoryKey;
                            upgradeNode.style.left = (upgradeX - 25) + 'px';
                            upgradeNode.style.top = (upgradeY - 25) + 'px';
                            
                            // Clean animation classes
                            upgradeNode.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                            
                            // If this category is preparing to open, make nodes invisible initially
                            if (window.preparingToOpen === categoryKey) {
                                upgradeNode.classList.add('prepare-opening');
                            }
                            
                            // Determine node state based on prerequisite progression
                            if (upgrade.unlocked) {
                                upgradeNode.classList.add('unlocked');
                            } else if (upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked) {
                                upgradeNode.classList.add('available');
                            } else {
                                upgradeNode.classList.add('locked');
                            }
                            
                            // Add selection state
                            if (selectedUpgrade && selectedUpgrade.id === upgrade.id && 
                                selectedUpgrade.category === categoryKey && 
                                selectedUpgrade.subCategory === subCategoryKey) {
                                upgradeNode.classList.add('selected');
                            }
                            
                            // Add new upgrade styling
                            if (upgrade.isNew) {
                                upgradeNode.classList.add('new-upgrade');
                            }
                            
                            // Node content
                            upgradeNode.innerHTML = `
                                <div class="node-icon">${upgrade.icon}</div>
                                <div class="node-level">Lv.${upgrade.id}</div>
                                ${!upgrade.unlocked ? `<div class="node-cost">${upgrade.cost} RP</div>` : ''}
                                ${upgradeNode.classList.contains('locked') ? '<div class="lock-icon">üîí</div>' : ''}
                                ${upgrade.isNew ? '<div class="new-badge">NEW</div>' : ''}
                            `;
                            
                            // Add click event
                            if (!upgrade.unlocked && (upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked)) {
                                upgradeNode.addEventListener('click', (event) => selectUpgrade(upgrade, categoryKey, subCategoryKey, event));
                            }
                            
                            // Add hover tooltip
                            upgradeNode.addEventListener('mouseenter', (e) => showTooltip(e, upgrade));
                            upgradeNode.addEventListener('mouseleave', hideTooltip);
                            
                            treesContentWrapper.appendChild(upgradeNode);
                        });
                    } else {
                        // Multiple sub-categories but no sub-category nodes: render each as a separate branch
                        // Calculate maximum safe arc span to prevent collisions
                        const maxUpgrades = Math.max(...subCategoryKeys.map(key => categoryData.subCategories[key].upgrades.length));
                        const maxExtension = upgradeRadius * maxUpgrades; // How far the longest branch extends
                        
                        // Calculate safe arc span based on angular space and extension distance
                        // Increased safety margin and base spacing to prevent collisions and allow for future expansion
                        const safeArcLength = angularSpacePerCategory * maxExtension * 1.4; // 140% of available space for better spacing
                        const safeArcSpan = Math.min(safeArcLength / maxExtension, angularSpacePerCategory * 1.2); // Increased from 0.8 to 1.2
                        
                        subCategoryKeys.forEach((subCategoryKey, subIndex) => {
                            const subCategoryData = categoryData.subCategories[subCategoryKey];
                            
                            // Calculate branch angle using the mathematically safe arc span
                            let branchAngle;
                            if (subCategoryKeys.length === 2) {
                                // For 2 sub-categories, place them at calculated safe angles with increased spacing
                                const angleOffset = safeArcSpan / 3; // Increased from /4 to /3 for more spacing
                                branchAngle = angle + (subIndex === 0 ? -angleOffset : angleOffset);
                            } else {
                                // For 3+ sub-categories, distribute them within the safe arc span
                                const angleStep = safeArcSpan / (subCategoryKeys.length - 1);
                                branchAngle = angle + (subIndex * angleStep) - (safeArcSpan / 2);
                            }
                            
                            // Render upgrades for this sub-category branch directly from main category
                            subCategoryData.upgrades.forEach((upgrade, upgradeIndex) => {
                                const upgradeDistance = upgradeRadius * (upgradeIndex + 1);
                                const upgradeX = mainCategoryX + Math.cos(branchAngle) * upgradeDistance;
                                const upgradeY = mainCategoryY + Math.sin(branchAngle) * upgradeDistance;
                                
                                // Create connection line from main category to upgrades
                                if (upgradeIndex === 0) {
                                    const upgradeConnection = document.createElement('div');
                                    upgradeConnection.className = 'radial-connection radial-connection-animate';
                                    upgradeConnection.dataset.category = categoryKey;
                                    upgradeConnection.style.left = mainCategoryX + 'px';
                                    upgradeConnection.style.top = mainCategoryY + 'px';
                                    upgradeConnection.style.width = (upgradeRadius * subCategoryData.upgrades.length) + 'px';
                                    upgradeConnection.style.setProperty('--rotation', `${branchAngle}rad`);
                                    upgradeConnection.style.transform = `rotate(${branchAngle}rad)`;
                                    
                                    // Clean animation classes
                                    upgradeConnection.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                                    
                                    // If this category is preparing to open, make connections invisible initially
                                    if (window.preparingToOpen === categoryKey) {
                                        upgradeConnection.classList.add('prepare-opening');
                                    }
                                    
                                    treesContentWrapper.appendChild(upgradeConnection);
                                }
                                
                                // Create upgrade node
                                const upgradeNode = document.createElement('div');
                                upgradeNode.className = 'upgrade-node skill-node-animate';
                                upgradeNode.dataset.upgradeId = upgrade.id;
                                upgradeNode.dataset.category = categoryKey;
                                upgradeNode.dataset.subCategory = subCategoryKey;
                                upgradeNode.style.left = (upgradeX - 25) + 'px';
                                upgradeNode.style.top = (upgradeY - 25) + 'px';
                                
                                // Clean animation classes
                                upgradeNode.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                                
                                // If this category is preparing to open, make nodes invisible initially
                                if (window.preparingToOpen === categoryKey) {
                                    upgradeNode.classList.add('prepare-opening');
                                }
                                
                                // Determine node state based on prerequisite progression
                                if (upgrade.unlocked) {
                                    upgradeNode.classList.add('unlocked');
                                } else if (upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked) {
                                    upgradeNode.classList.add('available');
                                } else {
                                    upgradeNode.classList.add('locked');
                                }
                                
                                // Add selection state
                                if (selectedUpgrade && selectedUpgrade.id === upgrade.id && 
                                    selectedUpgrade.category === categoryKey && 
                                    selectedUpgrade.subCategory === subCategoryKey) {
                                    upgradeNode.classList.add('selected');
                                }
                                
                                // Node content
                                upgradeNode.innerHTML = `
                                    <div class="node-icon">${upgrade.icon}</div>
                                    <div class="node-level">Lv.${upgrade.id}</div>
                                    ${!upgrade.unlocked ? `<div class="node-cost">${upgrade.cost} RP</div>` : ''}
                                    ${upgradeNode.classList.contains('locked') ? '<div class="lock-icon">üîí</div>' : ''}
                                `;
                                
                                // Add click event
                                if (!upgrade.unlocked && (upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked)) {
                                    upgradeNode.addEventListener('click', (event) => selectUpgrade(upgrade, categoryKey, subCategoryKey, event));
                                }
                                
                                // Add hover tooltip
                                upgradeNode.addEventListener('mouseenter', (e) => showTooltip(e, upgrade));
                                upgradeNode.addEventListener('mouseleave', hideTooltip);
                                
                                treesContentWrapper.appendChild(upgradeNode);
                            });
                        });
                    }
                }
            });
         }

        // Render horizontal skill tree
        function renderHorizontalTrees() {
            const treesContentWrapper = document.getElementById('treesContentWrapper');
            treesContentWrapper.innerHTML = '';
            treesContentWrapper.className = 'trees-content-wrapper horizontal'; // Add horizontal class
            
            // Render all main categories
            Object.keys(upgradeData).forEach(categoryKey => {
                const categoryData = upgradeData[categoryKey];
                
                // Create main category container
                const mainCategoryContainer = document.createElement('div');
                mainCategoryContainer.className = 'main-category-container';
                mainCategoryContainer.dataset.category = categoryKey;
                
                // Main category header
                const mainCategoryHeader = document.createElement('div');
                mainCategoryHeader.className = 'main-category-header';
                mainCategoryHeader.textContent = categoryData.title;
                
                // Add toggle functionality
                const isExpanded = expandedCategories.has(categoryKey);
                mainCategoryHeader.classList.add(isExpanded ? 'expanded' : 'collapsed');
                
                // Add new category styling
                if (categoryData.isNew) {
                    mainCategoryHeader.classList.add('new-category');
                }
                
                mainCategoryHeader.addEventListener('click', () => toggleCategory(categoryKey));
                
                mainCategoryContainer.appendChild(mainCategoryHeader);
                
                // Only render sub-categories if category is expanded
                if (isExpanded) {
                    // Sub-categories container
                    const subCategoriesContainer = document.createElement('div');
                    subCategoriesContainer.className = 'sub-categories-container';
                
                // Render all sub-categories
                Object.keys(categoryData.subCategories).forEach(subCategoryKey => {
                    const subCategoryData = categoryData.subCategories[subCategoryKey];
                    
                    // Create sub-tree container
                    const subTreeContainer = document.createElement('div');
                    subTreeContainer.className = 'sub-tree-container';
                    subTreeContainer.dataset.category = categoryKey;
                    subTreeContainer.dataset.subCategory = subCategoryKey;
                    
                    // Only show sub-category nodes for categories that truly have distinct sub-categories
                    const showSubCategoryNodes = (categoryKey === 'economy' || categoryKey === 'combat' || categoryKey === 'support' || categoryKey === 'laboratory' || categoryKey === 'walls' || categoryKey === 'farm' || categoryKey === 'deck' || categoryKey === 'garrison' || categoryKey === 'arsenal' || categoryKey === 'zombieWeakness' || categoryKey === 'landmine' || categoryKey === 'critical');
                    
                    if (showSubCategoryNodes) {
                        // Sub-category node (styled like other nodes)
                        const subCategoryNode = document.createElement('div');
                        subCategoryNode.className = 'sub-category-node-horizontal skill-node-animate';
                        subCategoryNode.dataset.category = categoryKey;
                        subCategoryNode.dataset.subCategory = subCategoryKey;
                        
                        // Clean animation classes
                        subCategoryNode.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                        
                        // If this category is preparing to open, make nodes invisible initially
                        if (window.preparingToOpen === categoryKey) {
                            subCategoryNode.classList.add('prepare-opening');
                        }
                        
                        // If this sub-category is preparing to open, make nodes invisible initially
                        const subCategoryId = `${categoryKey}_${subCategoryKey}`;
                        if (window.preparingToOpenSub === subCategoryId) {
                            subCategoryNode.classList.add('prepare-opening');
                        }
                        
                        // Add visual state based on expansion
                        const isSubCategoryExpanded = expandedSubCategories.has(subCategoryId);
                        subCategoryNode.classList.add(isSubCategoryExpanded ? 'expanded' : 'collapsed');
                        
                        // Add new sub-category styling
                        if (subCategoryData.isNew) {
                            subCategoryNode.classList.add('new-subcategory');
                        }
                        
                        // Sub-category node content
                        let subCategoryIcon = '';
                        if (subCategoryKey === 'starting') subCategoryIcon = 'üí∞';
                        else if (subCategoryKey === 'training') subCategoryIcon = 'üéñÔ∏è';
                        else if (subCategoryKey === 'weapons') subCategoryIcon = 'üî´';
                        else if (subCategoryKey === 'airstrike') subCategoryIcon = '‚úàÔ∏è';
                        else if (subCategoryKey === 'expeditions') subCategoryIcon = 'üó∫Ô∏è';
                        else if (subCategoryKey === 'specialists') subCategoryIcon = 'üë§';
                        else if (subCategoryKey === 'phoenix') subCategoryIcon = '‚ù§Ô∏è';
                        else if (subCategoryKey === 'speed') subCategoryIcon = '‚ö°';
                        else if (subCategoryKey === 'efficiency') subCategoryIcon = 'üî¨';
                        else if (subCategoryKey === 'offense') subCategoryIcon = '‚ö°';
                        else if (subCategoryKey === 'durability') subCategoryIcon = 'üõ°Ô∏è';
                        else if (subCategoryKey === 'regeneration') subCategoryIcon = 'üîß';
                        else if (subCategoryKey === 'grid') subCategoryIcon = 'üèûÔ∏è';
                        else if (subCategoryKey === 'yield') subCategoryIcon = 'üåæ';
                        else if (subCategoryKey === 'buildings') subCategoryIcon = 'üè†';
                        else if (subCategoryKey === 'reroll') subCategoryIcon = 'üîÑ';
                        else if (subCategoryKey === 'joker') subCategoryIcon = 'üÉè';
                        else if (subCategoryKey === 'management') subCategoryIcon = 'üîí';
                        else if (subCategoryKey === 'deployment') subCategoryIcon = 'üî´';
                        else if (subCategoryKey === 'damage') subCategoryIcon = 'üí•';
                        else if (subCategoryKey === 'fireRate') subCategoryIcon = '‚ö°';
                        else if (subCategoryKey === 'range') subCategoryIcon = 'üéØ';
                        else if (subCategoryKey === 'machineGun') subCategoryIcon = 'üî´';
                        else if (subCategoryKey === 'rocketLauncher') subCategoryIcon = 'üöÄ';
                        else if (subCategoryKey === 'mortar') subCategoryIcon = 'üí•';
                        else if (subCategoryKey === 'turret') subCategoryIcon = 'üóº';
                        else if (subCategoryKey === 'health') subCategoryIcon = 'üíÄ';
                        else if (subCategoryKey === 'aoe') subCategoryIcon = 'üí®';
                        else if (subCategoryKey === 'chance') subCategoryIcon = 'üçÄ';
                        else if (subCategoryKey === 'costReduction') subCategoryIcon = 'üí∞';
                        else subCategoryIcon = '‚ö°';
                        
                        subCategoryNode.innerHTML = `
                            <div class="node-icon">${subCategoryIcon}</div>
                            <div class="node-level">${subCategoryData.title}</div>
                            ${subCategoryData.isNew ? '<div class="new-badge">NEW</div>' : ''}
                        `;
                        
                        // Add click event to toggle sub-category
                        subCategoryNode.addEventListener('click', () => toggleSubCategory(categoryKey, subCategoryKey));
                        
                        subTreeContainer.appendChild(subCategoryNode);
                    } else {
                        // Create a simple header for categories without sub-category nodes
                        const subTreeHeader = document.createElement('div');
                        subTreeHeader.className = 'sub-tree-header';
                        subTreeHeader.textContent = subCategoryData.title;
                        subTreeContainer.appendChild(subTreeHeader);
                    }
                    
                    // Only render upgrades if sub-category is expanded (for categories with sub-category nodes)
                    const shouldRenderUpgrades = !showSubCategoryNodes || (showSubCategoryNodes && isSubCategoryExpanded);
                    
                    if (shouldRenderUpgrades) {
                        // Upgrade path
                        const upgradePath = document.createElement('div');
                        upgradePath.className = 'upgrade-path';
                        
                        subCategoryData.upgrades.forEach((upgrade, index) => {
                        // Create connection line (except for first upgrade)
                        if (index > 0) {
                            const connectionLine = document.createElement('div');
                            connectionLine.className = 'connection-line connection-animate';
                            connectionLine.dataset.category = categoryKey;
                            connectionLine.dataset.subCategory = subCategoryKey;
                            
                            // Clean animation classes
                            connectionLine.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                            
                            // If this category is preparing to open, make connections invisible initially
                            if (window.preparingToOpen === categoryKey) {
                                connectionLine.classList.add('prepare-opening');
                            }
                            
                            // If this sub-category is preparing to open, make connections invisible initially
                            const subCategoryId = `${categoryKey}_${subCategoryKey}`;
                            if (window.preparingToOpenSub === subCategoryId) {
                                connectionLine.classList.add('prepare-opening');
                            }
                            
                            // Calculate positioning based on screen size
                            const isMobile = window.innerWidth <= 768;
                            const nodeSize = isMobile ? 50 : 60;
                            const gapSize = isMobile ? 40 : 50;
                            const lineHeight = gapSize;
                            
                            connectionLine.style.top = `${(index - 1) * (nodeSize + gapSize) + nodeSize}px`;
                            connectionLine.style.height = `${lineHeight}px`;
                            
                            // Determine line state
                            const prevUpgrade = subCategoryData.upgrades[index - 1];
                            if (prevUpgrade.unlocked && upgrade.unlocked) {
                                connectionLine.classList.add('unlocked');
                            } else if (prevUpgrade.unlocked && !upgrade.unlocked) {
                                connectionLine.classList.add('available');
                            } else {
                                connectionLine.classList.add('locked');
                            }
                            
                            upgradePath.appendChild(connectionLine);
                        }
                        
                        // Create upgrade node
                        const upgradeNode = document.createElement('div');
                        upgradeNode.className = 'upgrade-node skill-node-animate';
                        upgradeNode.dataset.upgradeId = upgrade.id;
                        upgradeNode.dataset.category = categoryKey;
                        upgradeNode.dataset.subCategory = subCategoryKey;
                        
                        // Clean animation classes
                        upgradeNode.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                        
                        // If this category is preparing to open, make nodes invisible initially
                        if (window.preparingToOpen === categoryKey) {
                            upgradeNode.classList.add('prepare-opening');
                        }
                        
                        // If this sub-category is preparing to open, make nodes invisible initially
                        const subCategoryId = `${categoryKey}_${subCategoryKey}`;
                        if (window.preparingToOpenSub === subCategoryId) {
                            upgradeNode.classList.add('prepare-opening');
                        }
                        
                        // Determine node state
                        if (upgrade.unlocked) {
                            upgradeNode.classList.add('unlocked');
                        } else if (index === 0 || subCategoryData.upgrades[index - 1].unlocked) {
                            upgradeNode.classList.add('available');
                        } else {
                            upgradeNode.classList.add('locked');
                        }
                        
                        // Add selection state
                        if (selectedUpgrade && selectedUpgrade.id === upgrade.id && 
                            selectedUpgrade.category === categoryKey && 
                            selectedUpgrade.subCategory === subCategoryKey) {
                            upgradeNode.classList.add('selected');
                        }
                        
                        // Add new upgrade styling
                        if (upgrade.isNew) {
                            upgradeNode.classList.add('new-upgrade');
                        }
                        
                        // Node content
                        upgradeNode.innerHTML = `
                            <div class="node-icon">${upgrade.icon}</div>
                            <div class="node-level">Lv.${upgrade.id}</div>
                            ${!upgrade.unlocked ? `<div class="node-cost">${upgrade.cost} RP</div>` : ''}
                            ${upgradeNode.classList.contains('locked') ? '<div class="lock-icon">üîí</div>' : ''}
                            ${upgrade.isNew ? '<div class="new-badge">NEW</div>' : ''}
                        `;
                        
                        // Add click event
                        if (!upgrade.unlocked && (index === 0 || subCategoryData.upgrades[index - 1].unlocked)) {
                            upgradeNode.addEventListener('click', (event) => selectUpgrade(upgrade, categoryKey, subCategoryKey, event));
                        }
                        
                        // Add hover tooltip
                        upgradeNode.addEventListener('mouseenter', (e) => showTooltip(e, upgrade));
                        upgradeNode.addEventListener('mouseleave', hideTooltip);
                        
                        upgradePath.appendChild(upgradeNode);
                    });
                    
                        subTreeContainer.appendChild(upgradePath);
                    }
                    
                    subCategoriesContainer.appendChild(subTreeContainer);
                });
                
                    mainCategoryContainer.appendChild(subCategoriesContainer);
                }
                
                treesContentWrapper.appendChild(mainCategoryContainer);
            });
        }

        // Get icon for category
        function getIconForCategory(categoryKey) {
            const icons = {
                economy: 'üí∞',
                combat: '‚öîÔ∏è',
                laboratory: 'üß™',
                walls: 'üß±',
                support: 'ü§ù',
                farm: 'üåæ',
                deck: 'üÉè',
                garrison: 'üè∞',
                arsenal: 'üî´',
                zombieWeakness: 'üßü',
                landmine: 'üí£',
                critical: 'üéØ'
            };
            return icons[categoryKey] || '‚≠ê';
        }
        
        // Toggle category expansion with animation
        function toggleCategory(categoryKey) {
            if (expandedCategories.has(categoryKey)) {
                // Closing animation
                animateNodesOut(categoryKey, () => {
                    expandedCategories.delete(categoryKey);
                    renderUpgradeTrees();
                });
            } else {
                // Opening animation
                expandedCategories.add(categoryKey);
                // Mark category as preparing to open
                window.preparingToOpen = categoryKey;
                renderUpgradeTrees();
                // Animate in after a brief delay to ensure DOM is ready
                setTimeout(() => {
                    window.preparingToOpen = null;
                    animateNodesIn(categoryKey);
                }, 50);
            }
        }
        
        // Toggle sub-category expansion with animation
        function toggleSubCategory(categoryKey, subCategoryKey) {
            const subCategoryId = `${categoryKey}_${subCategoryKey}`;
            
            if (expandedSubCategories.has(subCategoryId)) {
                // Closing animation
                animateSubCategoryOut(categoryKey, subCategoryKey, () => {
                    expandedSubCategories.delete(subCategoryId);
                    renderUpgradeTrees();
                });
            } else {
                // Opening animation
                expandedSubCategories.add(subCategoryId);
                // Mark sub-category as preparing to open
                window.preparingToOpenSub = subCategoryId;
                renderUpgradeTrees();
                // Animate in after a brief delay to ensure DOM is ready
                setTimeout(() => {
                    window.preparingToOpenSub = null;
                    animateSubCategoryIn(categoryKey, subCategoryKey);
                }, 50);
            }
        }
        
        // Animate nodes appearing one by one
        function animateNodesIn(categoryKey) {
            const categoryNodes = document.querySelectorAll(`[data-category="${categoryKey}"].skill-node-animate, [data-category="${categoryKey}"].connection-animate, [data-category="${categoryKey}"].radial-connection-animate`);
            
            categoryNodes.forEach((node, index) => {
                // Staggered delay for ASMR effect
                setTimeout(() => {
                    // Remove prepare-opening state and prepare for animation
                    node.classList.remove('prepare-opening', 'animate-out');
                    node.classList.add('animate-in');
                    
                    // Short delay to allow the invisible state to register, then show
                    setTimeout(() => {
                        node.classList.add('show');
                    }, 20);
                    
                }, index * 120); // 120ms delay between each node
            });
        }
        
        // Animate nodes disappearing one by one
        function animateNodesOut(categoryKey, callback) {
            const categoryNodes = document.querySelectorAll(`[data-category="${categoryKey}"].skill-node-animate, [data-category="${categoryKey}"].connection-animate, [data-category="${categoryKey}"].radial-connection-animate`);
            
            if (categoryNodes.length === 0) {
                callback();
                return;
            }
            
            // Reverse order for closing (last to first)
            const nodesArray = Array.from(categoryNodes).reverse();
            
            nodesArray.forEach((node, index) => {
                const staggerDelay = index * 80; // 80ms delay between each node
                
                // Start the scale-down animation
                setTimeout(() => {
                    node.classList.remove('animate-in', 'show');
                    node.classList.add('animate-out');
                    
                    // Completely hide this individual node after its animation completes
                    setTimeout(() => {
                        node.classList.add('completely-hidden');
                    }, 400); // Animation duration
                    
                }, staggerDelay);
                
                // Call callback after the last animation completes
                if (index === nodesArray.length - 1) {
                    setTimeout(callback, staggerDelay + 400); // Wait for last animation to complete
                }
            });
        }
        
        // Animate sub-category nodes appearing one by one
        function animateSubCategoryIn(categoryKey, subCategoryKey) {
            const subCategoryNodes = document.querySelectorAll(`[data-category="${categoryKey}"][data-sub-category="${subCategoryKey}"].skill-node-animate, [data-category="${categoryKey}"][data-sub-category="${subCategoryKey}"].connection-animate, [data-category="${categoryKey}"][data-sub-category="${subCategoryKey}"].radial-connection-animate`);
            
            subCategoryNodes.forEach((node, index) => {
                // Staggered delay for ASMR effect
                setTimeout(() => {
                    // Remove prepare-opening state and prepare for animation
                    node.classList.remove('prepare-opening', 'animate-out');
                    node.classList.add('animate-in');
                    
                    // Short delay to allow the invisible state to register, then show
                    setTimeout(() => {
                        node.classList.add('show');
                    }, 20);
                    
                }, index * 120); // 120ms delay between each node
            });
        }
        
        // Animate sub-category nodes disappearing one by one
        function animateSubCategoryOut(categoryKey, subCategoryKey, callback) {
            const subCategoryNodes = document.querySelectorAll(`[data-category="${categoryKey}"][data-sub-category="${subCategoryKey}"].skill-node-animate, [data-category="${categoryKey}"][data-sub-category="${subCategoryKey}"].connection-animate, [data-category="${categoryKey}"][data-sub-category="${subCategoryKey}"].radial-connection-animate`);
            
            if (subCategoryNodes.length === 0) {
                callback();
                return;
            }
            
            // Reverse order for closing (last to first)
            const nodesArray = Array.from(subCategoryNodes).reverse();
            
            nodesArray.forEach((node, index) => {
                const staggerDelay = index * 80; // 80ms delay between each node
                
                // Start the scale-down animation
                setTimeout(() => {
                    node.classList.remove('animate-in', 'show');
                    node.classList.add('animate-out');
                    
                    // Completely hide this individual node after its animation completes
                    setTimeout(() => {
                        node.classList.add('completely-hidden');
                    }, 400); // Animation duration
                    
                }, staggerDelay);
                
                // Call callback after the last animation completes
                if (index === nodesArray.length - 1) {
                    setTimeout(callback, staggerDelay + 400); // Wait for last animation to complete
                }
            });
        }

        // Select an upgrade
        function selectUpgrade(upgrade, category, subCategory, event) {
            selectedUpgrade = upgrade;
            selectedUpgrade.category = category;
            selectedUpgrade.subCategory = subCategory;
            
            // Update visual selection
            document.querySelectorAll('.upgrade-node').forEach(node => {
                node.classList.remove('selected');
            });
            document.querySelector(`[data-upgrade-id="${upgrade.id}"][data-category="${category}"][data-sub-category="${subCategory}"]`).classList.add('selected');
            
            // Show upgrade details
            showUpgradeDetails(upgrade);
            
            // Show unlock interface
            showUnlockInterface(upgrade, category, subCategory, event);
        }

        // Show upgrade details
        function showUpgradeDetails(upgrade) {
            // Remove existing details panel
            const existingPanel = document.querySelector('.upgrade-details');
            if (existingPanel) {
                existingPanel.remove();
            }
            
            const detailsPanel = document.createElement('div');
            detailsPanel.className = 'upgrade-details';
            detailsPanel.innerHTML = `
                <div class="upgrade-name">${upgrade.name}</div>
                <div class="upgrade-effect">${upgrade.effect}</div>
            `;
            
            document.querySelector('.meta-upgrade-modal').appendChild(detailsPanel);
        }

        // Show unlock interface
        function showUnlockInterface(upgrade, category, subCategory, event) {
            const interface = document.getElementById('unlockInterface');
            const icon = document.getElementById('unlockInterfaceIcon');
            const title = document.getElementById('unlockInterfaceTitle');
            const effect = document.getElementById('unlockInterfaceEffect');
            const costAmount = document.getElementById('unlockInterfaceCostAmount');
            const confirmButton = document.getElementById('unlockInterfaceConfirm');
            
            // Get category data for description
            const categoryData = upgradeData[category];
            const subCategoryData = categoryData.subCategories[subCategory];
            
            // Update interface content
            icon.textContent = upgrade.icon;
            title.textContent = upgrade.name;
            effect.textContent = upgrade.effect;
            costAmount.textContent = `${upgrade.cost} RP`;
            
            // Update button state
            if (currentRP >= upgrade.cost) {
                confirmButton.disabled = false;
                confirmButton.textContent = 'UNLOCK';
            } else {
                confirmButton.disabled = true;
                confirmButton.textContent = 'INSUFFICIENT RP';
            }
            
            // Position interface above the clicked skill
            const rect = event.target.getBoundingClientRect();
            const modalRect = document.querySelector('.meta-upgrade-modal').getBoundingClientRect();
            
            // Calculate position (above the skill node)
            const left = rect.left - modalRect.left + (rect.width / 2) - 150; // Center the interface
            const top = rect.top - modalRect.top - 200; // Position above the skill
            
            // Ensure interface stays within modal bounds
            const interfaceWidth = 300;
            const interfaceHeight = 150;
            const modalWidth = modalRect.width;
            const modalHeight = modalRect.height;
            
            let finalLeft = Math.max(10, Math.min(left, modalWidth - interfaceWidth - 10));
            let finalTop = Math.max(10, Math.min(top, modalHeight - interfaceHeight - 10));
            
            // If interface would go off the top, position it below the skill instead
            if (top < 10) {
                finalTop = rect.bottom - modalRect.top + 20;
            }
            
            interface.style.left = finalLeft + 'px';
            interface.style.top = finalTop + 'px';
            
            // Show interface
            interface.style.display = 'block';
        }

        // Close unlock interface
        function closeUnlockInterface() {
            const interface = document.getElementById('unlockInterface');
            interface.style.display = 'none';
            
            // Clear selection
            selectedUpgrade = null;
            
            // Remove details panel
            const detailsPanel = document.querySelector('.upgrade-details');
            if (detailsPanel) {
                detailsPanel.remove();
            }
        }

        // Confirm unlock
        function confirmUnlock() {
            if (!selectedUpgrade || currentRP < selectedUpgrade.cost) {
                return;
            }
            
            // Deduct RP
            currentRP -= selectedUpgrade.cost;
            updateRPDisplay();
            
            // Mark upgrade as unlocked
            selectedUpgrade.unlocked = true;
            
            // Play unlock animation
            const nodeElement = document.querySelector(`[data-upgrade-id="${selectedUpgrade.id}"][data-category="${selectedUpgrade.category}"][data-sub-category="${selectedUpgrade.subCategory}"]`);
            nodeElement.classList.add('unlock-animation');
            
            // Close interface
            closeUnlockInterface();
            
            setTimeout(() => {
                nodeElement.classList.remove('unlock-animation');
                // Re-render all trees to update visuals
                renderUpgradeTrees();
            }, 600);
        }

        // Update RP display
        function updateRPDisplay() {
            document.getElementById('rpAmount').textContent = currentRP;
        }

        // Show tooltip
        function showTooltip(event, upgrade) {
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            
            // Find the category and sub-category this upgrade belongs to
            const upgradeNode = event.target.closest('.upgrade-node');
            const upgradeCategory = upgradeNode.dataset.category;
            const upgradeSubCategory = upgradeNode.dataset.subCategory;
            const categoryData = upgradeData[upgradeCategory];
            const subCategoryData = categoryData.subCategories[upgradeSubCategory];
            
            // Determine status
            let status = '';
            let statusClass = '';
            if (upgrade.unlocked) {
                status = 'UNLOCKED';
                statusClass = 'unlocked';
            } else {
                const upgradeIndex = subCategoryData.upgrades.findIndex(u => u.id === upgrade.id);
                const canUnlock = upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked;
                
                if (canUnlock) {
                    status = `COST: ${upgrade.cost} RP`;
                    statusClass = 'available';
                } else {
                    status = 'LOCKED';
                    statusClass = 'locked';
                }
            }
            
            // Special formatting for building upgrades
            let effectDisplay = upgrade.effect;
            if (upgradeCategory === 'buildings' && upgradeSubCategory === 'levels') {
                effectDisplay = formatBuildingEffect(upgrade.id, upgrade.effect);
            }
            
            tooltip.innerHTML = `
                <div class="tooltip-icon">${upgrade.icon}</div>
                <div class="tooltip-title">${upgrade.name} ${upgrade.isNew ? '<span style="color: #32CD32; font-weight: bold; font-size: 12px;">NEW!</span>' : ''}</div>
                <div class="tooltip-effect">${effectDisplay}</div>
                <div class="tooltip-description">Level ${upgrade.id} upgrade for ${categoryData.title} - ${subCategoryData.title}</div>
                <div class="tooltip-status ${statusClass}">${status}</div>
            `;
            
            document.querySelector('.meta-upgrade-modal').appendChild(tooltip);
            
            // Position tooltip relative to modal
            const rect = event.target.getBoundingClientRect();
            const modalRect = document.querySelector('.meta-upgrade-modal').getBoundingClientRect();
            
            // Position to the right of the node, but check if it would overflow
            let leftPos = rect.right - modalRect.left + 15;
            if (leftPos + 250 > modalRect.width) {
                // Position to the left instead
                leftPos = rect.left - modalRect.left - 265;
            }
            
            tooltip.style.left = leftPos + 'px';
            tooltip.style.top = (rect.top - modalRect.top - 20) + 'px';
        }
        
        // Format building upgrade effects for better readability
        function formatBuildingEffect(upgradeId, originalEffect) {
            const probabilityData = {
                0: { L1: 80, L2: 19, L3: 1, L4: 0, L5: 0 },    // Default
                1: { L1: 50, L2: 30, L3: 15, L4: 5, L5: 0 },   // Enhanced
                2: { L1: 25, L2: 35, L3: 25, L4: 12, L5: 3 },  // Improved
                3: { L1: 10, L2: 25, L3: 35, L4: 25, L5: 5 },  // Advanced
                4: { L1: 5, L2: 15, L3: 30, L4: 35, L5: 15 },  // Superior
                5: { L1: 2, L2: 8, L3: 20, L4: 40, L5: 30 }    // Master
            };
            
            const beforeData = probabilityData[upgradeId - 1];
            const afterData = probabilityData[upgradeId];
            
            if (beforeData && afterData) {
                let tableRows = '';
                
                for (let level = 1; level <= 5; level++) {
                    const levelKey = `L${level}`;
                    const beforeValue = beforeData[levelKey];
                    const afterValue = afterData[levelKey];
                    
                    let changeIcon = '';
                    let changeClass = '';
                    
                    if (beforeValue === 0 && afterValue > 0) {
                        changeIcon = '‚ú® NEW';
                        changeClass = 'change-new';
                    } else if (afterValue > beforeValue) {
                        changeIcon = '‚¨ÜÔ∏è +' + (afterValue - beforeValue) + '%';
                        changeClass = 'change-up';
                    } else if (afterValue < beforeValue) {
                        changeIcon = '‚¨áÔ∏è -' + (beforeValue - afterValue) + '%';
                        changeClass = 'change-down';
                    } else {
                        changeIcon = '‚û°Ô∏è Same';
                        changeClass = '';
                    }
                    
                    tableRows += `
                        <tr>
                            <td class="level-cell">${levelKey}</td>
                            <td class="before-cell">${beforeValue}%</td>
                            <td class="after-cell">${afterValue}%</td>
                            <td class="change-cell ${changeClass}">${changeIcon}</td>
                        </tr>
                    `;
                }
                
                return `
                    <table class="building-comparison-table">
                        <thead>
                            <tr>
                                <th>Level</th>
                                <th>Before</th>
                                <th>After</th>
                                <th>Change</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                `;
            }
            
            return originalEffect;
        }



        // Hide tooltip
        function hideTooltip() {
            const tooltip = document.querySelector('.tooltip');
            if (tooltip) {
                tooltip.remove();
            }
        }

        // Close modal
        function closeModal() {
            document.body.style.overflow = 'auto';
            window.location.href = 'game.html'; // Return to game
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html> 
</html> 
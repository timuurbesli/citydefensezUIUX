<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Defense Z - Meta Upgrade System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        /* Background Game View */
        .game-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('../assets/images/bg-cdz.jpg') center/cover no-repeat;
            filter: blur(2px);
            z-index: 1;
        }

        /* Modal Overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Main Modal Container */
        .meta-upgrade-modal {
            width: 100%;
            height: 100%;
            background: #2C2C2C;
            border: none;
            border-radius: 0;
            box-shadow: 0 0 30px rgba(255, 140, 0, 0.3);
            display: flex;
            flex-direction: column;
            position: relative;
            animation: slideIn 0.4s ease-out;
            padding: 20px;
        }

        @keyframes slideIn {
            from { transform: scale(0.8) translateY(-50px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        /* Close Button */
        .close-button {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #FF8C00;
            font-size: 28px;
            cursor: pointer;
            z-index: 10;
            transition: color 0.2s;
        }

        .close-button:hover {
            color: #FFA500;
            transform: scale(1.1);
        }

        /* Top Section with RP Display Only */
        .top-section {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            padding: 0 20px;
        }

        /* Research Points Display */
        .rp-display {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            background: rgba(65, 105, 225, 0.15);
            border: 1px solid rgba(65, 105, 225, 0.3);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .rp-display:hover {
            background: rgba(65, 105, 225, 0.2);
            border-color: rgba(65, 105, 225, 0.5);
        }

        .rp-icon {
            font-size: 24px;
            color: #4169E1;
            filter: drop-shadow(0 0 8px rgba(65, 105, 225, 0.6));
        }

        .rp-content {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .rp-amount {
            font-size: 24px;
            font-weight: bold;
            color: #4169E1;
            text-shadow: 0 0 10px rgba(65, 105, 225, 0.5);
            line-height: 1;
        }

        .rp-label {
            font-size: 12px;
            color: #888;
            font-weight: normal;
            line-height: 1;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* All Trees Container */
        .all-trees-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }

        .all-trees-container:active {
            cursor: grabbing;
        }

        .all-trees-container.panning {
            cursor: grabbing;
        }

        /* Trees Content Wrapper */
        .trees-content-wrapper {
            position: absolute;
            width: 2000px;
            height: 2000px;
            transition: transform 0.1s ease-out;
            transform-origin: center center;
            user-select: none;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        /* Horizontal Layout Styles */
        .trees-content-wrapper.horizontal {
            position: relative;
            width: auto;
            height: auto;
            left: auto;
            top: auto;
            transform: none;
            display: flex;
            gap: 30px;
            padding: 20px;
            transform-origin: 0 0;
        }

        .horizontal .main-category-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 250px;
            flex-shrink: 0;
            margin-right: 40px;
            transition: all 0.3s ease;
        }

        .horizontal .main-category-header {
            font-size: 20px;
            font-weight: bold;
            color: #FFA500;
            margin-bottom: 20px;
            text-align: center;
            border-bottom: 3px solid #FFA500;
            padding-bottom: 8px;
            width: 100%;
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .horizontal .sub-categories-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .horizontal .sub-tree-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 180px;
            flex-shrink: 0;
            transition: all 0.3s ease;
        }

        .horizontal .sub-tree-header {
            font-size: 14px;
            font-weight: bold;
            color: #FF8C00;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid #FF8C00;
            padding-bottom: 5px;
            width: 100%;
            white-space: nowrap;
        }

        .horizontal .upgrade-path {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 50px;
            position: relative;
        }

        .horizontal .upgrade-node {
            position: relative;
            width: 60px;
            height: 60px;
        }

        .horizontal .connection-line {
            position: absolute;
            width: 4px;
            background: #666;
            left: 50%;
            transform: translateX(-50%);
            transition: background 0.3s;
            z-index: 1;
            border-radius: 2px;
        }

        /* Hide radial elements in horizontal mode */
        .horizontal .central-hub,
        .horizontal .radial-branch,
        .horizontal .main-category-node,
        .horizontal .sub-category-node,
        .horizontal .radial-connection {
            display: none;
        }

        /* Central Hub */
        .central-hub {
            position: absolute;
            width: 120px;
            height: 120px;
            background: linear-gradient(135deg, #FF8C00, #FFA500);
            border: 4px solid #FFB347;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 30px rgba(255, 140, 0, 0.6);
            z-index: 20;
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-align: center;
        }

        .central-hub-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        /* Layout Toggle */
        .layout-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #FF8C00;
            border-radius: 8px;
            overflow: hidden;
            z-index: 10;
        }

        .toggle-option {
            padding: 10px 15px;
            background: transparent;
            border: none;
            color: #FF8C00;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .toggle-option:hover {
            background: rgba(255, 140, 0, 0.2);
        }

        .toggle-option.active {
            background: #FF8C00;
            color: white;
        }

        .toggle-icon {
            font-size: 14px;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }

        .zoom-button {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #FF8C00;
            border-radius: 8px;
            color: #FF8C00;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .zoom-button:hover {
            background: rgba(255, 140, 0, 0.2);
            transform: scale(1.1);
        }

        .zoom-indicator {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #FF8C00;
            border-radius: 4px;
            color: #FF8C00;
            font-size: 12px;
            padding: 5px 8px;
            text-align: center;
            margin-top: 5px;
        }

        /* Radial Branch Container */
        .radial-branch {
            position: absolute;
            transform-origin: center center;
        }

        /* Main Category Node */
        .main-category-node {
            position: absolute;
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #FF8C00, #FFA500);
            border: 3px solid #FFB347;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.4);
            z-index: 15;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .main-category-node:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(255, 140, 0, 0.6);
        }
        
        .main-category-node.collapsed {
            background: linear-gradient(135deg, #666, #888);
            border-color: #999;
            box-shadow: 0 0 10px rgba(150, 150, 150, 0.3);
        }
        
        .main-category-node.expanded {
            background: linear-gradient(135deg, #FF8C00, #FFA500);
            border-color: #FFB347;
            box-shadow: 0 0 25px rgba(255, 140, 0, 0.6);
        }
        
        /* Sub-Category Node (intermediate nodes) */
        .sub-category-node {
            position: absolute;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border: 3px solid #66BB6A;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.4);
            z-index: 12;
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .sub-category-node:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
        }
        
        .sub-category-node.collapsed {
            background: linear-gradient(135deg, #666, #888);
            border-color: #999;
            box-shadow: 0 0 10px rgba(150, 150, 150, 0.3);
        }
        
        .sub-category-node.expanded {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border-color: #66BB6A;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
        }
        
        /* Horizontal Sub-Category Node */
        .sub-category-node-horizontal {
            width: 120px;
            height: 50px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border: 2px solid #66BB6A;
            border-radius: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.4);
            margin: 10px 0;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            gap: 8px;
        }

        .sub-category-node-horizontal:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
        }
        
        .sub-category-node-horizontal.collapsed {
            background: linear-gradient(135deg, #666, #888);
            border-color: #999;
            box-shadow: 0 0 10px rgba(150, 150, 150, 0.3);
        }
        
        .sub-category-node-horizontal.expanded {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border-color: #66BB6A;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
        }
        
        /* Horizontal layout toggle styles */
        .horizontal .main-category-header {
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 10px 15px;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        
        .horizontal .main-category-header.collapsed {
            background: linear-gradient(135deg, #666, #888);
            color: #ccc;
            border: 2px solid #999;
        }
        
        .horizontal .main-category-header.expanded {
            background: linear-gradient(135deg, #FF8C00, #FFA500);
            color: white;
            border: 2px solid #FFB347;
            box-shadow: 0 0 15px rgba(255, 140, 0, 0.4);
        }
        
        .horizontal .main-category-header:hover {
            transform: scale(1.05);
        }
        
        /* Animation styles for skill nodes */
        .skill-node-animate {
            opacity: 1;
            transform: scale(1) translateY(0);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .skill-node-animate.animate-in {
            opacity: 0;
            transform: scale(0) translateY(-20px);
        }
        
        .skill-node-animate.animate-in.show {
            opacity: 1;
            transform: scale(1) translateY(0);
        }
        
        .skill-node-animate.prepare-opening {
            opacity: 0 !important;
            transform: scale(0) !important;
            pointer-events: none;
        }
        
        .skill-node-animate.animate-out {
            opacity: 0;
            transform: scale(0.1) translateY(20px);
        }
        
        .skill-node-animate.completely-hidden {
            opacity: 0 !important;
            transform: scale(0) !important;
            pointer-events: none;
        }
        
        /* Connection line animations */
        .connection-animate {
            opacity: 1;
            transform: scaleX(1);
            transform-origin: left center;
            transition: all 0.3s ease-out;
        }
        
        .connection-animate.animate-in {
            opacity: 0;
            transform: scaleX(0);
        }
        
        .connection-animate.animate-in.show {
            opacity: 1;
            transform: scaleX(1);
        }
        
        .connection-animate.prepare-opening {
            opacity: 0 !important;
            transform: scaleX(0) !important;
            pointer-events: none;
        }
        
        .connection-animate.animate-out {
            opacity: 0;
            transform: scaleX(0);
        }
        
        .connection-animate.completely-hidden {
            opacity: 0 !important;
            transform: scaleX(0) !important;
            pointer-events: none;
        }
        
        /* Radial connection animations */
        .radial-connection-animate {
            opacity: 1;
            transform-origin: left center;
            transition: all 0.3s ease-out;
            transform: scaleX(1) rotate(var(--rotation, 0deg));
        }
        
        .radial-connection-animate.animate-in {
            opacity: 0;
            transform: scaleX(0) rotate(var(--rotation, 0deg));
        }
        
        .radial-connection-animate.animate-in.show {
            opacity: 1;
            transform: scaleX(1) rotate(var(--rotation, 0deg));
        }
        
        .radial-connection-animate.prepare-opening {
            opacity: 0 !important;
            transform: scaleX(0) rotate(var(--rotation, 0deg)) !important;
            pointer-events: none;
        }
        
        .radial-connection-animate.animate-out {
            opacity: 0;
            transform: scaleX(0) rotate(var(--rotation, 0deg));
        }
        
        .radial-connection-animate.completely-hidden {
            opacity: 0 !important;
            transform: scaleX(0) rotate(var(--rotation, 0deg)) !important;
            pointer-events: none;
        }

        .main-category-icon {
            font-size: 18px;
            margin-bottom: 3px;
        }

        .main-category-title {
            font-size: 9px;
            line-height: 1;
        }

        /* Sub-Category Node */
        .sub-category-node {
            position: absolute;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #4169E1, #6495ED);
            border: 2px solid #87CEEB;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(65, 105, 225, 0.4);
            z-index: 12;
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .sub-category-node:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(65, 105, 225, 0.6);
        }

        /* Radial Connection Lines */
        .radial-connection {
            position: absolute;
            background: linear-gradient(to right, #FF8C00, #666);
            height: 3px;
            transform-origin: left center;
            z-index: 5;
            border-radius: 2px;
        }

        .radial-connection.main-to-sub {
            background: linear-gradient(to right, #FF8C00, #4169E1);
        }

        .radial-connection.sub-to-upgrade {
            background: linear-gradient(to right, #4169E1, #666);
            height: 2px;
        }

        /* Upgrade Path */
        .upgrade-path {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 50px;
            position: relative;
        }

        /* Connection Lines */
        .connection-line {
            position: absolute;
            width: 4px;
            background: #666;
            left: 50%;
            transform: translateX(-50%);
            transition: background 0.3s;
            z-index: 1;
            border-radius: 2px;
        }

        .connection-line.unlocked {
            background: linear-gradient(to bottom, #FF8C00, #FFA500);
            box-shadow: 0 0 8px rgba(255, 140, 0, 0.4);
        }

        .connection-line.available {
            background: linear-gradient(to bottom, #FF8C00, #666);
            animation: pulse 2s infinite;
        }

        .connection-line.locked {
            background: #444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Upgrade Nodes */
        .upgrade-node {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #666;
            background: #404040;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: absolute;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .upgrade-node:hover {
            transform: scale(1.1);
        }

        .upgrade-node.unlocked {
            background: #FF8C00;
            border-color: #FFA500;
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.4);
        }

        .upgrade-node.available {
            background: #F5F5F5;
            border-color: white;
            color: #333;
            animation: availablePulse 2s infinite;
        }

        .upgrade-node.selected {
            border-color: #FFA500;
            box-shadow: 0 0 25px rgba(255, 165, 0, 0.6);
        }

        .upgrade-node.locked {
            background: #404040;
            border-color: #666;
            opacity: 0.6;
        }

        @keyframes availablePulse {
            0%, 100% { border-color: white; }
            50% { border-color: #FF8C00; }
        }

        .upgrade-node .node-icon {
            font-size: 14px;
            margin-bottom: 1px;
        }

        .upgrade-node .node-level {
            font-size: 7px;
            font-weight: bold;
        }

        .upgrade-node .node-cost {
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #4169E1;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 4px;
            border-radius: 3px;
            white-space: nowrap;
        }

        .upgrade-node .lock-icon {
            position: absolute;
            top: -6px;
            right: -6px;
            background: #666;
            border-radius: 50%;
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7px;
        }

        /* Upgrade Details Panel */
        .upgrade-details {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 15px 25px;
            border-radius: 8px;
            border: 1px solid #FF8C00;
            min-width: 300px;
            text-align: center;
            z-index: 101;
        }

        .upgrade-name {
            font-size: 16px;
            font-weight: bold;
            color: #FF8C00;
            margin-bottom: 8px;
        }

        .upgrade-effect {
            font-size: 14px;
            color: #CCC;
            margin-bottom: 10px;
        }

        /* Unlock Button */
        .unlock-button {
            position: absolute;
            bottom: 20px;
            right: 30px;
            padding: 12px 25px;
            font-size: 14px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .unlock-button.can-afford {
            background: #32CD32;
            color: white;
        }

        .unlock-button.can-afford:hover {
            background: #228B22;
            transform: scale(1.05);
        }

        .unlock-button.cannot-afford {
            background: #DC143C;
            color: white;
            cursor: not-allowed;
        }

        .unlock-button.no-selection {
            background: #666;
            color: #CCC;
            cursor: not-allowed;
        }

        /* Unlock Animation */
        @keyframes unlockSuccess {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); background: #32CD32; }
            100% { transform: scale(1); }
        }

        .upgrade-node.unlock-animation {
            animation: unlockSuccess 0.6s ease-out;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: #2C2C2C;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #FF8C00;
            font-size: 13px;
            color: white;
            z-index: 1000;
            pointer-events: none;
            width: 250px;
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.3);
        }

        .tooltip-icon {
            text-align: center;
            font-size: 32px;
            margin-bottom: 10px;
        }

        .tooltip-title {
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            color: #FF8C00;
            margin-bottom: 8px;
        }

        .tooltip-effect {
            text-align: center;
            font-size: 14px;
            color: #FFA500;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .tooltip-description {
            text-align: center;
            font-size: 12px;
            color: #CCC;
            margin-bottom: 10px;
            line-height: 1.3;
        }

        .tooltip-status {
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .tooltip-status.unlocked {
            background: #228B22;
            color: white;
        }

        .tooltip-status.locked {
            background: #666;
            color: #CCC;
        }

        .tooltip-status.available {
            background: #FF8C00;
            color: white;
        }

        /* Building Upgrade Comparison Table */
        .building-comparison-table {
            margin: 10px 0;
            border-collapse: collapse;
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: hidden;
        }

        .building-comparison-table th {
            background: linear-gradient(135deg, #FF8C00, #FFA500);
            color: white;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            border-bottom: 2px solid #FFB347;
        }

        .building-comparison-table td {
            padding: 6px 12px;
            font-size: 11px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 140, 0, 0.2);
        }

        .building-comparison-table tr:last-child td {
            border-bottom: none;
        }

        .building-comparison-table .level-cell {
            font-weight: bold;
            color: #FFA500;
            background: rgba(255, 140, 0, 0.1);
            width: 15%;
        }

        .building-comparison-table .before-cell {
            color: #CCC;
            background: rgba(100, 100, 100, 0.2);
            width: 30%;
        }

        .building-comparison-table .after-cell {
            color: #90EE90;
            background: rgba(144, 238, 144, 0.1);
            font-weight: bold;
            width: 30%;
        }

        .building-comparison-table .change-cell {
            width: 25%;
            font-weight: bold;
        }

        .building-comparison-table .change-up {
            color: #90EE90;
        }

        .building-comparison-table .change-down {
            color: #FFB347;
        }

        .building-comparison-table .change-new {
            color: #FFD700;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 5px #FFD700; }
            to { text-shadow: 0 0 15px #FFD700, 0 0 20px #FFD700; }
        }

        /* Responsive Design */
        @media (max-width: 1366px) {
            .meta-upgrade-modal {
                width: 95%;
                height: 90%;
            }
            
            .trees-content-wrapper {
                gap: 15px;
                padding: 15px;
            }
            
            .main-category-container {
                min-width: 200px;
                margin-right: 30px;
            }
            
            .sub-tree-container {
                min-width: 150px;
            }
            
            .upgrade-node {
                width: 50px;
                height: 50px;
            }
            
            .main-category-header {
                font-size: 16px;
            }
            
            .sub-tree-header {
                font-size: 12px;
            }
            
            .zoom-controls {
                top: 10px;
                right: 10px;
            }
            
            .zoom-button {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
        }

        @media (max-width: 768px) {
            .layout-toggle {
                top: 5px;
                left: 5px;
            }
            
            .toggle-option {
                padding: 8px 10px;
                font-size: 10px;
            }
            
            .toggle-icon {
                font-size: 12px;
            }
            
            .zoom-controls {
                top: 5px;
                right: 5px;
            }
            
            .zoom-button {
                width: 30px;
                height: 30px;
                font-size: 14px;
            }
            
            .zoom-indicator {
                font-size: 10px;
                padding: 3px 5px;
            }
            
            .trees-content-wrapper {
                gap: 10px;
                padding: 10px;
            }
            
            .horizontal .main-category-container {
                min-width: 150px;
                margin-right: 20px;
            }
            
            .horizontal .sub-tree-container {
                min-width: 120px;
            }
            
            .horizontal .upgrade-path {
                gap: 40px;
            }
            
            .horizontal .upgrade-node {
                width: 50px;
                height: 50px;
            }
            
            .horizontal .connection-line {
                width: 3px;
            }
        }
    </style>
</head>
<body>
    <!-- Game Background -->
    <div class="game-background"></div>

    <!-- Meta Upgrade Modal -->
    <div class="modal-overlay">
        <div class="meta-upgrade-modal">
            <!-- Close Button -->
            <button class="close-button" onclick="closeModal()">&times;</button>

            <!-- Top Section with RP Display Only -->
            <div class="top-section">
                <div class="rp-display">
                    <div class="rp-icon">
                        <i class="fas fa-flask"></i>
                    </div>
                    <div class="rp-content">
                        <div class="rp-amount" id="rpAmount">300</div>
                        <div class="rp-label">Research Points</div>
                    </div>
                </div>
            </div>

            <!-- Main Content Area -->
            <div class="main-content">
                <!-- All Trees Container -->
                <div class="all-trees-container" id="allTreesContainer">
                    <!-- Layout Toggle -->
                    <div class="layout-toggle">
                        <button class="toggle-option active" id="radialToggle" data-layout="radial">
                            <span class="toggle-icon">üîò</span>
                            <span>Radial</span>
                        </button>
                        <button class="toggle-option" id="horizontalToggle" data-layout="horizontal">
                            <span class="toggle-icon">üìã</span>
                            <span>Horizontal</span>
                        </button>
                    </div>
                    
                    <!-- Zoom Controls -->
                    <div class="zoom-controls">
                        <button class="zoom-button" id="zoomInBtn">+</button>
                        <button class="zoom-button" id="zoomOutBtn">‚àí</button>
                        <button class="zoom-button" id="resetZoomBtn" style="font-size: 14px;">‚åÇ</button>
                        <div class="zoom-indicator" id="zoomIndicator">100%</div>
                    </div>
                    
                    <!-- Trees Content Wrapper -->
                    <div class="trees-content-wrapper" id="treesContentWrapper">
                        <!-- Dynamic content will be populated here -->
                    </div>
                </div>
            </div>

            <!-- Unlock Button -->
            <button class="unlock-button no-selection" id="unlockButton" onclick="unlockUpgrade()">
                SELECT UPGRADE
            </button>
        </div>
    </div>

    <script>
        // Game State
        let currentRP = 300;
        let selectedUpgrade = null;
        let currentCategory = 'buildings';

        // Zoom and Pan State
        let currentZoom = 1;
        let currentPanX = 0;
        let currentPanY = 0;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let minZoom = 0.3;
        let maxZoom = 3;
        let zoomStep = 0.2;

        // Layout State
        let currentLayout = 'radial'; // 'radial' or 'horizontal'
        
        // Category Toggle State
        let expandedCategories = new Set(); // Track which categories are expanded
        let expandedSubCategories = new Set(); // Track which sub-categories are expanded

        // Upgrade Data with Sub-Categories
        const upgradeData = {
            buildings: {
                title: "Buildings",
                subCategories: {
                    levels: {
                        title: "Building Card Levels",
                        description: "Improves building card level probabilities through RNG enhancement. Affects all building types - Factory, Ammunition, Barracks, Laboratory, and House cards.",
                        upgrades: [
                            { id: 1, name: "Enhanced Buildings", cost: 50, effect: "L1: 50%, L2: 30%, L3: 15%, L4: 5%", unlocked: true, icon: "üè†" },
                            { id: 2, name: "Improved Buildings", cost: 100, effect: "L1: 25%, L2: 35%, L3: 25%, L4: 12%, L5: 3%", unlocked: true, icon: "üè¢" },
                            { id: 3, name: "Advanced Buildings", cost: 150, effect: "L1: 10%, L2: 25%, L3: 35%, L4: 25%, L5: 5%", unlocked: false, icon: "üè≠" },
                            { id: 4, name: "Superior Buildings", cost: 200, effect: "L1: 5%, L2: 15%, L3: 30%, L4: 35%, L5: 15%", unlocked: false, icon: "üèóÔ∏è" },
                            { id: 5, name: "Master Buildings", cost: 300, effect: "L1: 2%, L2: 8%, L3: 20%, L4: 40%, L5: 30%", unlocked: false, icon: "üèõÔ∏è" }
                        ]
                    }
                }
            },
            combat: {
                title: "Combat",
                subCategories: {
                    training: {
                        title: "Training",
                        description: "Enhances the default effectiveness and level of all trained soldiers.",
                        upgrades: [
                            { id: 1, name: "Basic Training", cost: 75, effect: "+1 Default Soldier Level", unlocked: true, icon: "ü•â" },
                            { id: 2, name: "Advanced Training", cost: 125, effect: "+1 Default Soldier Level", unlocked: false, icon: "ü•à" },
                            { id: 3, name: "Elite Training", cost: 175, effect: "+1 Default Soldier Level", unlocked: false, icon: "ü•á" },
                            { id: 4, name: "Special Forces", cost: 250, effect: "+1 Default Soldier Level", unlocked: false, icon: "üéñÔ∏è" },
                            { id: 5, name: "Legendary Warriors", cost: 350, effect: "+1 Default Soldier Level", unlocked: false, icon: "‚≠ê" }
                        ]
                    },
                    weapons: {
                        title: "Weapons",
                        description: "Enhances combat effectiveness through improved fire rate, reload speed, and damage.",
                        upgrades: [
                            { id: 1, name: "Rapid Fire", cost: 100, effect: "Soldiers attack faster", unlocked: false, icon: "üî´" },
                            { id: 2, name: "Quick Reload", cost: 175, effect: "-50% reload time", unlocked: false, icon: "üîÑ" },
                            { id: 3, name: "High Damage", cost: 250, effect: "+50% soldier damage", unlocked: false, icon: "üí•" }
                        ]
                    },
                    heavyWeapons: {
                        title: "Heavy Weapons",
                        description: "Unlocks specialized heavy weapons for advanced tactical options.",
                        upgrades: [
                            { id: 1, name: "Machine Gun Arsenal", cost: 150, effect: "Unlocks Machine Gun (Bixi)", unlocked: false, icon: "üî´" },
                            { id: 2, name: "Rocket Arsenal", cost: 200, effect: "Unlocks Rocket Launcher", unlocked: false, icon: "üöÄ" },
                            { id: 3, name: "Artillery Arsenal", cost: 250, effect: "Unlocks Mortar", unlocked: false, icon: "üí•" }
                        ]
                    },
                    defensiveStructures: {
                        title: "Defensive Structures",
                        description: "Unlocks advanced defensive structures for enhanced base protection.",
                        upgrades: [
                            { id: 1, name: "Wall Engineering", cost: 100, effect: "Unlocks Defense Walls", unlocked: false, icon: "üß±" },
                            { id: 2, name: "Tower Engineering", cost: 175, effect: "Unlocks Outpost Towers", unlocked: false, icon: "üóº" }
                        ]
                    },
                    airstrike: {
                        title: "Airstrike",
                        description: "Improves aerial support through cost reduction, new weapons, and increased effectiveness.",
                        upgrades: [
                            { id: 1, name: "Cheap Strikes", cost: 125, effect: "Airstrikes 50% cheaper", unlocked: false, icon: "üí∞" },
                            { id: 2, name: "Triple Bomber", cost: 200, effect: "3-bomb launcher plane", unlocked: false, icon: "üí£" },
                            { id: 3, name: "Wide Bombardment", cost: 300, effect: "+50% airstrike radius", unlocked: false, icon: "üí•" }
                        ]
                    }
                }
            },
            walls: {
                title: "Walls",
                subCategories: {
                    capacity: {
                        title: "Wall Capacity",
                        description: "Increases the maximum number of wall segments that can be built.",
                        upgrades: [
                            { id: 1, name: "Extended Walls", cost: 80, effect: "Wall capacity +20", unlocked: false, icon: "üß±" },
                            { id: 2, name: "Expanded Walls", cost: 160, effect: "Wall capacity +25", unlocked: false, icon: "üèóÔ∏è" },
                            { id: 3, name: "Fortified Walls", cost: 240, effect: "Wall capacity +30", unlocked: false, icon: "‚õ©Ô∏è" },
                            { id: 4, name: "Massive Walls", cost: 320, effect: "Wall capacity +35", unlocked: false, icon: "üè∞" }
                        ]
                    },
                    durability: {
                        title: "Wall Durability",
                        description: "Increases the health and resilience of all wall segments.",
                        upgrades: [
                            { id: 1, name: "Reinforced Walls", cost: 90, effect: "+25% wall HP", unlocked: false, icon: "üõ°Ô∏è" },
                            { id: 2, name: "Hardened Walls", cost: 180, effect: "+50% wall HP", unlocked: false, icon: "üîí" },
                            { id: 3, name: "Armored Walls", cost: 270, effect: "+75% wall HP", unlocked: false, icon: "‚öîÔ∏è" },
                            { id: 4, name: "Impenetrable Walls", cost: 360, effect: "+100% wall HP", unlocked: false, icon: "üõ°Ô∏è" }
                        ]
                    },
                    offense: {
                        title: "Wall Offense",
                        description: "Adds damage and special effects to walls when attacked.",
                        upgrades: [
                            { id: 1, name: "Spiked Walls", cost: 100, effect: "Walls deal damage when attacked", unlocked: false, icon: "üî∫" },
                            { id: 2, name: "Electrified Walls", cost: 200, effect: "Electric damage to attackers", unlocked: false, icon: "‚ö°" },
                            { id: 3, name: "Toxic Walls", cost: 300, effect: "Poison damage over time", unlocked: false, icon: "‚ò†Ô∏è" },
                            { id: 4, name: "Explosive Walls", cost: 400, effect: "Area damage when destroyed", unlocked: false, icon: "üí•" }
                        ]
                    }
                }
            },
            garrison: {
                title: "Garrison",
                subCategories: {
                    deployment: {
                        title: "Bixi Deployment",
                        description: "Adds automated Bixi machine guns to wall positions for permanent defense.",
                        upgrades: [
                            { id: 1, name: "Basic Garrison", cost: 150, effect: "Adds 1 bixi to left wall + 1 bixi to right wall", unlocked: false, icon: "üî´" },
                            { id: 2, name: "Enhanced Garrison", cost: 250, effect: "Adds 2 more bixis (2L + 2R total)", unlocked: false, icon: "üî´" },
                            { id: 3, name: "Advanced Garrison", cost: 350, effect: "Adds 2 more bixis (3L + 3R total)", unlocked: false, icon: "üî´" },
                            { id: 4, name: "Superior Garrison", cost: 450, effect: "Adds 2 more bixis (4L + 4R total)", unlocked: false, icon: "üî´" },
                            { id: 5, name: "Master Garrison", cost: 550, effect: "Adds 2 more bixis (5L + 5R total)", unlocked: false, icon: "üî´" }
                        ]
                    },
                    damage: {
                        title: "Bixi Damage",
                        description: "Increases the damage output of all deployed Bixi machine guns.",
                        upgrades: [
                            { id: 1, name: "Enhanced Ammunition", cost: 200, effect: "+25% bixi damage", unlocked: false, icon: "üí•" },
                            { id: 2, name: "High-Explosive Rounds", cost: 300, effect: "+50% bixi damage", unlocked: false, icon: "üí•" },
                            { id: 3, name: "Armor-Piercing Shells", cost: 400, effect: "+75% bixi damage", unlocked: false, icon: "üí•" },
                            { id: 4, name: "Plasma Rounds", cost: 500, effect: "+100% bixi damage", unlocked: false, icon: "üí•" },
                            { id: 5, name: "Quantum Ammunition", cost: 600, effect: "+150% bixi damage", unlocked: false, icon: "üí•" }
                        ]
                    },
                    fireRate: {
                        title: "Bixi Fire Rate",
                        description: "Increases the firing speed of all deployed Bixi machine guns.",
                        upgrades: [
                            { id: 1, name: "Rapid Fire", cost: 175, effect: "+20% bixi fire rate", unlocked: false, icon: "‚ö°" },
                            { id: 2, name: "Hyper Fire", cost: 275, effect: "+40% bixi fire rate", unlocked: false, icon: "‚ö°" },
                            { id: 3, name: "Lightning Fire", cost: 375, effect: "+60% bixi fire rate", unlocked: false, icon: "‚ö°" },
                            { id: 4, name: "Storm Fire", cost: 475, effect: "+80% bixi fire rate", unlocked: false, icon: "‚ö°" },
                            { id: 5, name: "Blitz Fire", cost: 575, effect: "+100% bixi fire rate", unlocked: false, icon: "‚ö°" }
                        ]
                    },
                    range: {
                        title: "Bixi Range",
                        description: "Increases the effective range of all deployed Bixi machine guns.",
                        upgrades: [
                            { id: 1, name: "Extended Range", cost: 125, effect: "+25% bixi range", unlocked: false, icon: "üéØ" },
                            { id: 2, name: "Long Range", cost: 225, effect: "+50% bixi range", unlocked: false, icon: "üéØ" },
                            { id: 3, name: "Sniper Range", cost: 325, effect: "+75% bixi range", unlocked: false, icon: "üéØ" },
                            { id: 4, name: "Maximum Range", cost: 425, effect: "+100% bixi range", unlocked: false, icon: "üéØ" },
                            { id: 5, name: "Infinite Range", cost: 525, effect: "+150% bixi range", unlocked: false, icon: "üéØ" }
                        ]
                    }
                }
            },
            farm: {
                title: "Farm",
                subCategories: {
                    speed: {
                        title: "Harvest Speed",
                        description: "Reduces the time needed for crop harvests.",
                        upgrades: [
                            { id: 1, name: "Quick Harvest", cost: 60, effect: "Crops grow 1 day faster", unlocked: false, icon: "‚è∞" },
                            { id: 2, name: "Rapid Growth", cost: 120, effect: "Crops grow 1 day faster", unlocked: false, icon: "üí®" },
                            { id: 3, name: "Super Growth", cost: 180, effect: "Crops grow 1 day faster", unlocked: false, icon: "‚ö°" },
                            { id: 4, name: "Instant Harvest", cost: 240, effect: "Crops grow 1 day faster", unlocked: false, icon: "üåü" }
                        ]
                    },
                    grid: {
                        title: "Grid Expansion",
                        description: "Adds more grid spaces to the farm for additional crops.",
                        upgrades: [
                            { id: 1, name: "Small Expansion", cost: 80, effect: "+1 crop grid expansion", unlocked: false, icon: "üöú" },
                            { id: 2, name: "Medium Expansion", cost: 160, effect: "+2 crop grid expansion", unlocked: false, icon: "üèûÔ∏è" },
                            { id: 3, name: "Large Expansion", cost: 240, effect: "+3 crop grid expansion", unlocked: false, icon: "üåæ" },
                            { id: 4, name: "Massive Expansion", cost: 320, effect: "+4 crop grid expansion", unlocked: false, icon: "üåø" }
                        ]
                    },
                    yield: {
                        title: "Harvest Yield",
                        description: "Increases the amount of crops harvested from each plot.",
                        upgrades: [
                            { id: 1, name: "Better Harvest", cost: 70, effect: "+25% crop harvest", unlocked: false, icon: "üåæ" },
                            { id: 2, name: "Rich Harvest", cost: 140, effect: "+50% crop harvest", unlocked: false, icon: "üåª" },
                            { id: 3, name: "Abundant Harvest", cost: 210, effect: "+75% crop harvest", unlocked: false, icon: "üåΩ" },
                            { id: 4, name: "Golden Harvest", cost: 280, effect: "+100% crop harvest", unlocked: false, icon: "üåº" }
                        ]
                    }
                }
            },
            laboratory: {
                title: "Laboratory",
                subCategories: {
                    efficiency: {
                        title: "Research Efficiency",
                        description: "Increases research point generation and resource efficiency.",
                        upgrades: [
                            { id: 1, name: "Efficient Research", cost: 100, effect: "+50% RP generation", unlocked: false, icon: "üî¨" },
                            { id: 2, name: "Optimized Research", cost: 200, effect: "+75% RP generation", unlocked: false, icon: "‚öóÔ∏è" },
                            { id: 3, name: "Advanced Research", cost: 300, effect: "+100% RP generation", unlocked: false, icon: "üß¨" },
                            { id: 4, name: "Quantum Research", cost: 400, effect: "+150% RP generation", unlocked: false, icon: "üîÆ" }
                        ]
                    },
                    speed: {
                        title: "Research Speed",
                        description: "Reduces research completion time and accelerates discoveries.",
                        upgrades: [
                            { id: 1, name: "Rapid Research", cost: 120, effect: "Research 1 day faster", unlocked: false, icon: "‚ö°" },
                            { id: 2, name: "Accelerated Research", cost: 240, effect: "Research 2 days faster", unlocked: false, icon: "üöÄ" },
                            { id: 3, name: "Lightning Research", cost: 360, effect: "Research 3 days faster", unlocked: false, icon: "‚ö°" },
                            { id: 4, name: "Instant Research", cost: 480, effect: "Research 4 days faster", unlocked: false, icon: "üí´" }
                        ]
                    }
                }
            },
            support: {
                title: "Support",
                subCategories: {
                    expeditions: {
                        title: "Expeditions",
                        description: "Improves expedition success rates, rewards, and completion time.",
                        upgrades: [
                            { id: 1, name: "Safe Expeditions", cost: 120, effect: "+20% survival rate", unlocked: false, icon: "üõ°Ô∏è" },
                            { id: 2, name: "Rich Rewards", cost: 180, effect: "+50% expedition rewards", unlocked: false, icon: "üí∞" },
                            { id: 3, name: "Swift Expeditions", cost: 250, effect: "Expeditions 1 day faster", unlocked: false, icon: "üí®" }
                        ]
                    },
                    npc: {
                        title: "NPC Buffs",
                        description: "Amplifies the beneficial effects provided by recruited NPCs.",
                        upgrades: [
                            { id: 1, name: "Enhanced NPCs", cost: 150, effect: "+50% NPC buff effects", unlocked: false, icon: "üë§" },
                            { id: 2, name: "Empowered NPCs", cost: 250, effect: "+75% NPC buff effects", unlocked: false, icon: "‚ú®" },
                            { id: 3, name: "Legendary NPCs", cost: 400, effect: "+100% NPC buff effects", unlocked: false, icon: "‚≠ê" }
                        ]
                    }
                }
            },
            revive: {
                title: "Revive",
                subCategories: {
                    phoenix: {
                        title: "Phoenix",
                        description: "Provides multiple chances to recover from defeat.",
                        upgrades: [
                            { id: 1, name: "Phoenix Rising", cost: 500, effect: "Revive ability (1 use per run)", unlocked: false, icon: "‚ù§Ô∏è" },
                            { id: 2, name: "Double Phoenix", cost: 750, effect: "Revive ability (2 uses per run)", unlocked: false, icon: "üíñ" },
                            { id: 3, name: "Eternal Phoenix", cost: 1000, effect: "Revive ability (3 uses per run)", unlocked: false, icon: "üíù" }
                        ]
                    }
                }
            },

            reroll: {
                title: "Reroll Cards",
                subCategories: {
                    cards: {
                        title: "Cards",
                        description: "Adds flexibility to building selection with reroll functionality.",
                        upgrades: [
                            { id: 1, name: "Basic Reroll", cost: 75, effect: "Unlocks reroll function", unlocked: false, icon: "üîÑ" },
                            { id: 2, name: "Extra Reroll", cost: 125, effect: "+1 reroll count", unlocked: false, icon: "üîÑ" },
                            { id: 3, name: "More Rerolls", cost: 175, effect: "+1 reroll count", unlocked: false, icon: "üîÑ" },
                            { id: 4, name: "Maximum Rerolls", cost: 250, effect: "+1 reroll count", unlocked: false, icon: "üîÑ" }
                        ]
                    }
                }
            }
        };

        // Initialize the interface
        function init() {
            // Initialize all categories as expanded
            Object.keys(upgradeData).forEach(categoryKey => {
                expandedCategories.add(categoryKey);
                // Initialize all sub-categories as expanded
                Object.keys(upgradeData[categoryKey].subCategories).forEach(subCategoryKey => {
                    expandedSubCategories.add(`${categoryKey}_${subCategoryKey}`);
                });
            });
            
            updateRPDisplay();
            renderUpgradeTrees();
            initializeView();
            setupEventListeners();
        }

        // Setup event listeners
        function setupEventListeners() {
            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeModal();
                } else if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    zoomIn();
                } else if (e.key === '-' || e.key === '_') {
                    e.preventDefault();
                    zoomOut();
                } else if (e.key === '0' || e.key === 'Home') {
                    e.preventDefault();
                    resetZoom();
                }
            });

            // Zoom and Pan Event Listeners
            setupZoomAndPanListeners();

            // Layout Toggle Event Listeners
            setupLayoutToggle();
        }

        // Setup zoom and pan functionality
        function setupZoomAndPanListeners() {
            const container = document.getElementById('allTreesContainer');
            const wrapper = document.getElementById('treesContentWrapper');
            
            // Zoom Controls
            document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
            document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
            document.getElementById('resetZoomBtn').addEventListener('click', resetZoom);
            
            // Mouse wheel zoom
            container.addEventListener('wheel', function(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -zoomStep : zoomStep;
                zoom(delta, e.clientX, e.clientY);
            });
            
            // Mouse panning
            container.addEventListener('mousedown', startPanning);
            document.addEventListener('mousemove', updatePanning);
            document.addEventListener('mouseup', stopPanning);
            
            // Touch events for mobile
            container.addEventListener('touchstart', handleTouchStart, { passive: false });
            container.addEventListener('touchmove', handleTouchMove, { passive: false });
            container.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            // Prevent context menu on right click
            container.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });
        }

        // Zoom Functions
        function zoomIn() {
            zoom(zoomStep);
        }

        function zoomOut() {
            zoom(-zoomStep);
        }

        function resetZoom() {
            currentZoom = 1;
            currentPanX = 0;
            currentPanY = 0;
            updateTransform();
        }

        function zoom(delta, clientX, clientY) {
            const newZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom + delta));
            
            if (newZoom !== currentZoom) {
                // If mouse position is provided, zoom towards that point
                if (clientX !== undefined && clientY !== undefined) {
                    const container = document.getElementById('allTreesContainer');
                    const rect = container.getBoundingClientRect();
                    const mouseX = clientX - rect.left;
                    const mouseY = clientY - rect.top;
                    
                    // Calculate the zoom center relative to the wrapper
                    const zoomCenterX = (mouseX - currentPanX) / currentZoom;
                    const zoomCenterY = (mouseY - currentPanY) / currentZoom;
                    
                    // Update zoom
                    currentZoom = newZoom;
                    
                    // Adjust pan to keep the zoom center in place
                    currentPanX = mouseX - zoomCenterX * currentZoom;
                    currentPanY = mouseY - zoomCenterY * currentZoom;
                } else {
                    currentZoom = newZoom;
                }
                
                updateTransform();
            }
        }

        // Panning Functions
        function startPanning(e) {
            if (e.button !== 0) return; // Only left mouse button
            isPanning = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            document.getElementById('allTreesContainer').classList.add('panning');
            e.preventDefault();
        }

        function updatePanning(e) {
            if (!isPanning) return;
            
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            
            currentPanX += deltaX;
            currentPanY += deltaY;
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            updateTransform();
        }

        function stopPanning() {
            isPanning = false;
            document.getElementById('allTreesContainer').classList.remove('panning');
        }

        // Touch Events for Mobile
        let touchStartX = 0;
        let touchStartY = 0;
        let initialDistance = 0;
        let initialZoom = 1;

        function handleTouchStart(e) {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                // Single touch - start panning
                isPanning = true;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                lastMouseX = touchStartX;
                lastMouseY = touchStartY;
            } else if (e.touches.length === 2) {
                // Two touches - start zooming
                isPanning = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                initialDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                initialZoom = currentZoom;
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 1 && isPanning) {
                // Single touch - panning
                const deltaX = e.touches[0].clientX - lastMouseX;
                const deltaY = e.touches[0].clientY - lastMouseY;
                
                currentPanX += deltaX;
                currentPanY += deltaY;
                
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
                
                updateTransform();
            } else if (e.touches.length === 2) {
                // Two touches - zooming
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                const zoomRatio = currentDistance / initialDistance;
                const newZoom = Math.max(minZoom, Math.min(maxZoom, initialZoom * zoomRatio));
                
                if (newZoom !== currentZoom) {
                    currentZoom = newZoom;
                    updateTransform();
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            isPanning = false;
        }

        // Update the transform of the wrapper
        function updateTransform() {
            const wrapper = document.getElementById('treesContentWrapper');
            
            if (currentLayout === 'radial') {
                const baseTransform = 'translate(-50%, -50%)';
                const zoomTransform = `translate(${currentPanX}px, ${currentPanY}px) scale(${currentZoom})`;
                wrapper.style.transform = `${baseTransform} ${zoomTransform}`;
            } else {
                // For horizontal layout, use simpler transform
                wrapper.style.transform = `translate(${currentPanX}px, ${currentPanY}px) scale(${currentZoom})`;
            }
            
            // Update zoom indicator
            document.getElementById('zoomIndicator').textContent = Math.round(currentZoom * 100) + '%';
        }

        // Initialize view to center on hub
        function initializeView() {
            if (currentLayout === 'radial') {
                currentZoom = 0.6; // Start zoomed out to see more of the tree
                currentPanX = 0;
                currentPanY = 0;
            } else {
                currentZoom = 1;
                currentPanX = 0;
                currentPanY = 0;
            }
            updateTransform();
        }

        // Setup layout toggle functionality
        function setupLayoutToggle() {
            document.getElementById('radialToggle').addEventListener('click', () => switchLayout('radial'));
            document.getElementById('horizontalToggle').addEventListener('click', () => switchLayout('horizontal'));
        }

        // Switch between layouts
        function switchLayout(layout) {
            if (currentLayout === layout) return;
            
            currentLayout = layout;
            
            // Update toggle buttons
            document.querySelectorAll('.toggle-option').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(layout + 'Toggle').classList.add('active');
            
            // Re-render with new layout
            if (layout === 'radial') {
                renderRadialTrees();
            } else {
                renderHorizontalTrees();
            }
            
            // Reset view
            initializeView();
        }

        // Main render function - delegates to layout-specific functions
        function renderUpgradeTrees() {
            if (currentLayout === 'radial') {
                renderRadialTrees();
            } else {
                renderHorizontalTrees();
            }
        }

        // Render radial skill tree
        function renderRadialTrees() {
            const treesContentWrapper = document.getElementById('treesContentWrapper');
            treesContentWrapper.innerHTML = '';
            treesContentWrapper.className = 'trees-content-wrapper'; // Remove horizontal class
            
            // Create central hub
            const centralHub = document.createElement('div');
            centralHub.className = 'central-hub';
            centralHub.innerHTML = `
                <div class="central-hub-icon">‚ö°</div>
                <div>META<br>UPGRADES</div>
            `;
            treesContentWrapper.appendChild(centralHub);
            
            // Get category keys and calculate positions
            const categoryKeys = Object.keys(upgradeData);
            const centerX = 1000; // Center of the 2000px container
            const centerY = 1000;
            const mainRadius = 300; // Distance from center to main categories
            
            // Calculate angular space per category for collision avoidance
            const totalCategories = categoryKeys.length;
            const angularSpacePerCategory = (2 * Math.PI) / totalCategories;
            
                         // Render main categories in a circle
             categoryKeys.forEach((categoryKey, categoryIndex) => {
                 const categoryData = upgradeData[categoryKey];
                 // Start at top (90 degrees offset) and distribute evenly
                 const angle = (categoryIndex / categoryKeys.length) * 2 * Math.PI - Math.PI / 2;
                 
                 // Calculate main category position
                 const mainCategoryX = centerX + Math.cos(angle) * mainRadius;
                 const mainCategoryY = centerY + Math.sin(angle) * mainRadius;
                
                // Create connection from center to main category
                const centerConnection = document.createElement('div');
                centerConnection.className = 'radial-connection radial-connection-animate';
                centerConnection.dataset.category = categoryKey;
                centerConnection.style.left = centerX + 'px';
                centerConnection.style.top = centerY + 'px';
                centerConnection.style.width = mainRadius + 'px';
                centerConnection.style.setProperty('--rotation', `${angle}rad`);
                centerConnection.style.transform = `rotate(${angle}rad)`;
                
                // Clean animation classes
                centerConnection.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                
                // If this category is preparing to open, make connections invisible initially
                if (window.preparingToOpen === categoryKey) {
                    centerConnection.classList.add('prepare-opening');
                }
                
                treesContentWrapper.appendChild(centerConnection);
                
                // Create main category node
                const mainCategoryNode = document.createElement('div');
                mainCategoryNode.className = 'main-category-node';
                mainCategoryNode.style.left = (mainCategoryX - 40) + 'px';
                mainCategoryNode.style.top = (mainCategoryY - 40) + 'px';
                
                // Get first sub-category for icon
                const firstSubKey = Object.keys(categoryData.subCategories)[0];
                const icon = getIconForCategory(categoryKey);
                
                mainCategoryNode.innerHTML = `
                    <div class="main-category-icon">${icon}</div>
                    <div class="main-category-title">${categoryData.title.toUpperCase()}</div>
                `;
                
                // Add toggle functionality
                const isExpanded = expandedCategories.has(categoryKey);
                mainCategoryNode.classList.add(isExpanded ? 'expanded' : 'collapsed');
                mainCategoryNode.addEventListener('click', () => toggleCategory(categoryKey));
                
                treesContentWrapper.appendChild(mainCategoryNode);
                
                // Only render child nodes if category is expanded
                if (!isExpanded) {
                    return; // Skip rendering child nodes for collapsed categories
                }
                
                // Check if this category has multiple sub-categories
                const subCategoryKeys = Object.keys(categoryData.subCategories);
                const subCategoryDistance = 120; // Distance from main category to sub-category nodes
                const upgradeRadius = 100; // Distance between upgrade levels (increased for more space)
                
                // Only show sub-category nodes for categories that truly have distinct sub-categories
                const showSubCategoryNodes = (categoryKey === 'combat' || categoryKey === 'support') && subCategoryKeys.length > 1;
                
                if (showSubCategoryNodes) {
                    // Multiple sub-categories: render each as a separate branch
                    // Calculate maximum safe arc span to prevent collisions
                    const maxUpgrades = Math.max(...subCategoryKeys.map(key => categoryData.subCategories[key].upgrades.length));
                    const maxExtension = subCategoryDistance + (upgradeRadius * maxUpgrades); // How far the longest branch extends
                    
                    // Calculate safe arc span based on angular space and extension distance
                    // Use trigonometry: at distance maxExtension, the arc length should not exceed neighboring category space
                    // Increased safety margin and base spacing to prevent collisions and allow for future expansion
                    const safeArcLength = angularSpacePerCategory * maxExtension * 1.4; // 140% of available space for better spacing
                    const safeArcSpan = Math.min(safeArcLength / maxExtension, angularSpacePerCategory * 1.2); // Increased from 0.8 to 1.2
                    
                    subCategoryKeys.forEach((subCategoryKey, subIndex) => {
                        const subCategoryData = categoryData.subCategories[subCategoryKey];
                        
                        // Calculate branch angle using the mathematically safe arc span
                        let branchAngle;
                        if (subCategoryKeys.length === 2) {
                            // For 2 sub-categories, place them at calculated safe angles with increased spacing
                            const angleOffset = safeArcSpan / 3; // Increased from /4 to /3 for more spacing
                            branchAngle = angle + (subIndex === 0 ? -angleOffset : angleOffset);
                        } else {
                            // For 3+ sub-categories, distribute them within the safe arc span
                            const angleStep = safeArcSpan / (subCategoryKeys.length - 1);
                            branchAngle = angle + (subIndex * angleStep) - (safeArcSpan / 2);
                        }
                        
                        // Calculate sub-category node position
                        const subCategoryX = mainCategoryX + Math.cos(branchAngle) * subCategoryDistance;
                        const subCategoryY = mainCategoryY + Math.sin(branchAngle) * subCategoryDistance;
                        
                        // Create sub-category node
                        const subCategoryNode = document.createElement('div');
                        subCategoryNode.className = 'sub-category-node skill-node-animate';
                        subCategoryNode.dataset.category = categoryKey;
                        subCategoryNode.dataset.subCategory = subCategoryKey;
                        subCategoryNode.style.left = (subCategoryX - 30) + 'px';
                        subCategoryNode.style.top = (subCategoryY - 30) + 'px';
                        
                        // Clean animation classes
                        subCategoryNode.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                        
                        // If this category is preparing to open, make nodes invisible initially
                        if (window.preparingToOpen === categoryKey) {
                            subCategoryNode.classList.add('prepare-opening');
                        }
                        
                        // If this sub-category is preparing to open, make nodes invisible initially
                        const subCategoryId = `${categoryKey}_${subCategoryKey}`;
                        if (window.preparingToOpenSub === subCategoryId) {
                            subCategoryNode.classList.add('prepare-opening');
                        }
                        
                        // Add visual state based on expansion
                        const isSubCategoryExpanded = expandedSubCategories.has(subCategoryId);
                        subCategoryNode.classList.add(isSubCategoryExpanded ? 'expanded' : 'collapsed');
                        
                        // Sub-category node content
                        let subCategoryIcon = '';
                        if (subCategoryKey === 'training') subCategoryIcon = 'üéñÔ∏è';
                        else if (subCategoryKey === 'weapons') subCategoryIcon = 'üî´';
                        else if (subCategoryKey === 'airstrike') subCategoryIcon = '‚úàÔ∏è';
                        else if (subCategoryKey === 'expeditions') subCategoryIcon = 'üó∫Ô∏è';
                        else if (subCategoryKey === 'npc') subCategoryIcon = 'üë§';
                        else if (subCategoryKey === 'heavyWeapons') subCategoryIcon = 'üî´';
                        else if (subCategoryKey === 'defensiveStructures') subCategoryIcon = 'üèóÔ∏è';
                        else subCategoryIcon = '‚ö°';
                        
                        subCategoryNode.innerHTML = `
                            <div class="node-icon">${subCategoryIcon}</div>
                            <div class="node-level">${subCategoryData.title}</div>
                        `;
                        
                        // Add click event to toggle sub-category
                        subCategoryNode.addEventListener('click', () => toggleSubCategory(categoryKey, subCategoryKey));
                        
                        treesContentWrapper.appendChild(subCategoryNode);
                        
                        // Create connection line from main category to sub-category
                        const mainToSubConnection = document.createElement('div');
                        mainToSubConnection.className = 'radial-connection radial-connection-animate';
                        mainToSubConnection.dataset.category = categoryKey;
                        mainToSubConnection.style.left = mainCategoryX + 'px';
                        mainToSubConnection.style.top = mainCategoryY + 'px';
                        mainToSubConnection.style.width = subCategoryDistance + 'px';
                        mainToSubConnection.style.setProperty('--rotation', `${branchAngle}rad`);
                        mainToSubConnection.style.transform = `rotate(${branchAngle}rad)`;
                        
                        // Clean animation classes
                        mainToSubConnection.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                        
                        // If this category is preparing to open, make connections invisible initially
                        if (window.preparingToOpen === categoryKey) {
                            mainToSubConnection.classList.add('prepare-opening');
                        }
                        
                        treesContentWrapper.appendChild(mainToSubConnection);
                        
                        // Only render upgrades if sub-category is expanded
                        if (isSubCategoryExpanded) {
                            // Render upgrades for this sub-category branch
                            subCategoryData.upgrades.forEach((upgrade, upgradeIndex) => {
                            const upgradeDistance = upgradeRadius * (upgradeIndex + 1);
                            const upgradeX = subCategoryX + Math.cos(branchAngle) * upgradeDistance;
                            const upgradeY = subCategoryY + Math.sin(branchAngle) * upgradeDistance;
                            
                            // Create connection line from sub-category to upgrades
                            if (upgradeIndex === 0) {
                                const subToUpgradeConnection = document.createElement('div');
                                subToUpgradeConnection.className = 'radial-connection radial-connection-animate';
                                subToUpgradeConnection.dataset.category = categoryKey;
                                subToUpgradeConnection.dataset.subCategory = subCategoryKey;
                                subToUpgradeConnection.style.left = subCategoryX + 'px';
                                subToUpgradeConnection.style.top = subCategoryY + 'px';
                                subToUpgradeConnection.style.width = (upgradeRadius * subCategoryData.upgrades.length) + 'px';
                                subToUpgradeConnection.style.setProperty('--rotation', `${branchAngle}rad`);
                                subToUpgradeConnection.style.transform = `rotate(${branchAngle}rad)`;
                                
                                // Clean animation classes
                                subToUpgradeConnection.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                                
                                // If this category is preparing to open, make connections invisible initially
                                if (window.preparingToOpen === categoryKey) {
                                    subToUpgradeConnection.classList.add('prepare-opening');
                                }
                                
                                // If this sub-category is preparing to open, make connections invisible initially
                                const subCategoryId = `${categoryKey}_${subCategoryKey}`;
                                if (window.preparingToOpenSub === subCategoryId) {
                                    subToUpgradeConnection.classList.add('prepare-opening');
                                }
                                
                                treesContentWrapper.appendChild(subToUpgradeConnection);
                            }
                            
                            // Create upgrade node
                            const upgradeNode = document.createElement('div');
                            upgradeNode.className = 'upgrade-node skill-node-animate';
                            upgradeNode.dataset.upgradeId = upgrade.id;
                            upgradeNode.dataset.category = categoryKey;
                            upgradeNode.dataset.subCategory = subCategoryKey;
                            upgradeNode.style.left = (upgradeX - 25) + 'px';
                            upgradeNode.style.top = (upgradeY - 25) + 'px';
                            
                            // Clean animation classes
                            upgradeNode.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                            
                            // If this category is preparing to open, make nodes invisible initially
                            if (window.preparingToOpen === categoryKey) {
                                upgradeNode.classList.add('prepare-opening');
                            }
                            
                            // If this sub-category is preparing to open, make nodes invisible initially
                            const subCategoryId = `${categoryKey}_${subCategoryKey}`;
                            if (window.preparingToOpenSub === subCategoryId) {
                                upgradeNode.classList.add('prepare-opening');
                            }
                            
                            // Determine node state based on prerequisite progression within sub-category
                            if (upgrade.unlocked) {
                                upgradeNode.classList.add('unlocked');
                            } else if (upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked) {
                                upgradeNode.classList.add('available');
                            } else {
                                upgradeNode.classList.add('locked');
                            }
                            
                            // Add selection state
                            if (selectedUpgrade && selectedUpgrade.id === upgrade.id && 
                                selectedUpgrade.category === categoryKey && 
                                selectedUpgrade.subCategory === subCategoryKey) {
                                upgradeNode.classList.add('selected');
                            }
                            
                            // Node content
                            upgradeNode.innerHTML = `
                                <div class="node-icon">${upgrade.icon}</div>
                                <div class="node-level">Lv.${upgrade.id}</div>
                                ${!upgrade.unlocked ? `<div class="node-cost">${upgrade.cost} RP</div>` : ''}
                                ${upgradeNode.classList.contains('locked') ? '<div class="lock-icon">üîí</div>' : ''}
                            `;
                            
                            // Add click event
                            if (!upgrade.unlocked && (upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked)) {
                                upgradeNode.addEventListener('click', () => selectUpgrade(upgrade, categoryKey, subCategoryKey));
                            }
                            
                            // Add hover tooltip
                            upgradeNode.addEventListener('mouseenter', (e) => showTooltip(e, upgrade));
                            upgradeNode.addEventListener('mouseleave', hideTooltip);
                            
                            treesContentWrapper.appendChild(upgradeNode);
                        });
                        }
                    });
                } else {
                    // Handle categories without sub-category nodes
                    if (subCategoryKeys.length === 1) {
                        // Single sub-category: render as a single line directly from main category
                        const subCategoryKey = subCategoryKeys[0];
                        const subCategoryData = categoryData.subCategories[subCategoryKey];
                        
                        subCategoryData.upgrades.forEach((upgrade, upgradeIndex) => {
                            const upgradeDistance = upgradeRadius * (upgradeIndex + 1);
                            const upgradeX = mainCategoryX + Math.cos(angle) * upgradeDistance;
                            const upgradeY = mainCategoryY + Math.sin(angle) * upgradeDistance;
                            
                            // Create connection line from main category to upgrades
                            if (upgradeIndex === 0) {
                                const upgradeConnection = document.createElement('div');
                                upgradeConnection.className = 'radial-connection radial-connection-animate';
                                upgradeConnection.dataset.category = categoryKey;
                                upgradeConnection.style.left = mainCategoryX + 'px';
                                upgradeConnection.style.top = mainCategoryY + 'px';
                                upgradeConnection.style.width = (upgradeRadius * subCategoryData.upgrades.length) + 'px';
                                upgradeConnection.style.setProperty('--rotation', `${angle}rad`);
                                upgradeConnection.style.transform = `rotate(${angle}rad)`;
                                
                                // Clean animation classes
                                upgradeConnection.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                                
                                // If this category is preparing to open, make connections invisible initially
                                if (window.preparingToOpen === categoryKey) {
                                    upgradeConnection.classList.add('prepare-opening');
                                }
                                
                                treesContentWrapper.appendChild(upgradeConnection);
                            }
                            
                            // Create upgrade node
                            const upgradeNode = document.createElement('div');
                            upgradeNode.className = 'upgrade-node skill-node-animate';
                            upgradeNode.dataset.upgradeId = upgrade.id;
                            upgradeNode.dataset.category = categoryKey;
                            upgradeNode.dataset.subCategory = subCategoryKey;
                            upgradeNode.style.left = (upgradeX - 25) + 'px';
                            upgradeNode.style.top = (upgradeY - 25) + 'px';
                            
                            // Clean animation classes
                            upgradeNode.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                            
                            // If this category is preparing to open, make nodes invisible initially
                            if (window.preparingToOpen === categoryKey) {
                                upgradeNode.classList.add('prepare-opening');
                            }
                            
                            // Determine node state based on prerequisite progression
                            if (upgrade.unlocked) {
                                upgradeNode.classList.add('unlocked');
                            } else if (upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked) {
                                upgradeNode.classList.add('available');
                            } else {
                                upgradeNode.classList.add('locked');
                            }
                            
                            // Add selection state
                            if (selectedUpgrade && selectedUpgrade.id === upgrade.id && 
                                selectedUpgrade.category === categoryKey && 
                                selectedUpgrade.subCategory === subCategoryKey) {
                                upgradeNode.classList.add('selected');
                            }
                            
                            // Node content
                            upgradeNode.innerHTML = `
                                <div class="node-icon">${upgrade.icon}</div>
                                <div class="node-level">Lv.${upgrade.id}</div>
                                ${!upgrade.unlocked ? `<div class="node-cost">${upgrade.cost} RP</div>` : ''}
                                ${upgradeNode.classList.contains('locked') ? '<div class="lock-icon">üîí</div>' : ''}
                            `;
                            
                            // Add click event
                            if (!upgrade.unlocked && (upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked)) {
                                upgradeNode.addEventListener('click', () => selectUpgrade(upgrade, categoryKey, subCategoryKey));
                            }
                            
                            // Add hover tooltip
                            upgradeNode.addEventListener('mouseenter', (e) => showTooltip(e, upgrade));
                            upgradeNode.addEventListener('mouseleave', hideTooltip);
                            
                            treesContentWrapper.appendChild(upgradeNode);
                        });
                    } else {
                        // Multiple sub-categories but no sub-category nodes: render each as a separate branch
                        // Calculate maximum safe arc span to prevent collisions
                        const maxUpgrades = Math.max(...subCategoryKeys.map(key => categoryData.subCategories[key].upgrades.length));
                        const maxExtension = upgradeRadius * maxUpgrades; // How far the longest branch extends
                        
                        // Calculate safe arc span based on angular space and extension distance
                        // Increased safety margin and base spacing to prevent collisions and allow for future expansion
                        const safeArcLength = angularSpacePerCategory * maxExtension * 1.4; // 140% of available space for better spacing
                        const safeArcSpan = Math.min(safeArcLength / maxExtension, angularSpacePerCategory * 1.2); // Increased from 0.8 to 1.2
                        
                        subCategoryKeys.forEach((subCategoryKey, subIndex) => {
                            const subCategoryData = categoryData.subCategories[subCategoryKey];
                            
                            // Calculate branch angle using the mathematically safe arc span
                            let branchAngle;
                            if (subCategoryKeys.length === 2) {
                                // For 2 sub-categories, place them at calculated safe angles with increased spacing
                                const angleOffset = safeArcSpan / 3; // Increased from /4 to /3 for more spacing
                                branchAngle = angle + (subIndex === 0 ? -angleOffset : angleOffset);
                            } else {
                                // For 3+ sub-categories, distribute them within the safe arc span
                                const angleStep = safeArcSpan / (subCategoryKeys.length - 1);
                                branchAngle = angle + (subIndex * angleStep) - (safeArcSpan / 2);
                            }
                            
                            // Render upgrades for this sub-category branch directly from main category
                            subCategoryData.upgrades.forEach((upgrade, upgradeIndex) => {
                                const upgradeDistance = upgradeRadius * (upgradeIndex + 1);
                                const upgradeX = mainCategoryX + Math.cos(branchAngle) * upgradeDistance;
                                const upgradeY = mainCategoryY + Math.sin(branchAngle) * upgradeDistance;
                                
                                // Create connection line from main category to upgrades
                                if (upgradeIndex === 0) {
                                    const upgradeConnection = document.createElement('div');
                                    upgradeConnection.className = 'radial-connection radial-connection-animate';
                                    upgradeConnection.dataset.category = categoryKey;
                                    upgradeConnection.style.left = mainCategoryX + 'px';
                                    upgradeConnection.style.top = mainCategoryY + 'px';
                                    upgradeConnection.style.width = (upgradeRadius * subCategoryData.upgrades.length) + 'px';
                                    upgradeConnection.style.setProperty('--rotation', `${branchAngle}rad`);
                                    upgradeConnection.style.transform = `rotate(${branchAngle}rad)`;
                                    
                                    // Clean animation classes
                                    upgradeConnection.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                                    
                                    // If this category is preparing to open, make connections invisible initially
                                    if (window.preparingToOpen === categoryKey) {
                                        upgradeConnection.classList.add('prepare-opening');
                                    }
                                    
                                    treesContentWrapper.appendChild(upgradeConnection);
                                }
                                
                                // Create upgrade node
                                const upgradeNode = document.createElement('div');
                                upgradeNode.className = 'upgrade-node skill-node-animate';
                                upgradeNode.dataset.upgradeId = upgrade.id;
                                upgradeNode.dataset.category = categoryKey;
                                upgradeNode.dataset.subCategory = subCategoryKey;
                                upgradeNode.style.left = (upgradeX - 25) + 'px';
                                upgradeNode.style.top = (upgradeY - 25) + 'px';
                                
                                // Clean animation classes
                                upgradeNode.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                                
                                // If this category is preparing to open, make nodes invisible initially
                                if (window.preparingToOpen === categoryKey) {
                                    upgradeNode.classList.add('prepare-opening');
                                }
                                
                                // Determine node state based on prerequisite progression
                                if (upgrade.unlocked) {
                                    upgradeNode.classList.add('unlocked');
                                } else if (upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked) {
                                    upgradeNode.classList.add('available');
                                } else {
                                    upgradeNode.classList.add('locked');
                                }
                                
                                // Add selection state
                                if (selectedUpgrade && selectedUpgrade.id === upgrade.id && 
                                    selectedUpgrade.category === categoryKey && 
                                    selectedUpgrade.subCategory === subCategoryKey) {
                                    upgradeNode.classList.add('selected');
                                }
                                
                                // Node content
                                upgradeNode.innerHTML = `
                                    <div class="node-icon">${upgrade.icon}</div>
                                    <div class="node-level">Lv.${upgrade.id}</div>
                                    ${!upgrade.unlocked ? `<div class="node-cost">${upgrade.cost} RP</div>` : ''}
                                    ${upgradeNode.classList.contains('locked') ? '<div class="lock-icon">üîí</div>' : ''}
                                `;
                                
                                // Add click event
                                if (!upgrade.unlocked && (upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked)) {
                                    upgradeNode.addEventListener('click', () => selectUpgrade(upgrade, categoryKey, subCategoryKey));
                                }
                                
                                // Add hover tooltip
                                upgradeNode.addEventListener('mouseenter', (e) => showTooltip(e, upgrade));
                                upgradeNode.addEventListener('mouseleave', hideTooltip);
                                
                                treesContentWrapper.appendChild(upgradeNode);
                            });
                        });
                    }
                }
            });
         }

        // Render horizontal skill tree
        function renderHorizontalTrees() {
            const treesContentWrapper = document.getElementById('treesContentWrapper');
            treesContentWrapper.innerHTML = '';
            treesContentWrapper.className = 'trees-content-wrapper horizontal'; // Add horizontal class
            
            // Render all main categories
            Object.keys(upgradeData).forEach(categoryKey => {
                const categoryData = upgradeData[categoryKey];
                
                // Create main category container
                const mainCategoryContainer = document.createElement('div');
                mainCategoryContainer.className = 'main-category-container';
                mainCategoryContainer.dataset.category = categoryKey;
                
                // Main category header
                const mainCategoryHeader = document.createElement('div');
                mainCategoryHeader.className = 'main-category-header';
                mainCategoryHeader.textContent = categoryData.title;
                
                // Add toggle functionality
                const isExpanded = expandedCategories.has(categoryKey);
                mainCategoryHeader.classList.add(isExpanded ? 'expanded' : 'collapsed');
                mainCategoryHeader.addEventListener('click', () => toggleCategory(categoryKey));
                
                mainCategoryContainer.appendChild(mainCategoryHeader);
                
                // Only render sub-categories if category is expanded
                if (isExpanded) {
                    // Sub-categories container
                    const subCategoriesContainer = document.createElement('div');
                    subCategoriesContainer.className = 'sub-categories-container';
                
                // Render all sub-categories
                Object.keys(categoryData.subCategories).forEach(subCategoryKey => {
                    const subCategoryData = categoryData.subCategories[subCategoryKey];
                    
                    // Create sub-tree container
                    const subTreeContainer = document.createElement('div');
                    subTreeContainer.className = 'sub-tree-container';
                    subTreeContainer.dataset.category = categoryKey;
                    subTreeContainer.dataset.subCategory = subCategoryKey;
                    
                    // Only show sub-category nodes for categories that truly have distinct sub-categories
                    const showSubCategoryNodes = (categoryKey === 'combat' || categoryKey === 'support');
                    
                    if (showSubCategoryNodes) {
                        // Sub-category node (styled like other nodes)
                        const subCategoryNode = document.createElement('div');
                        subCategoryNode.className = 'sub-category-node-horizontal skill-node-animate';
                        subCategoryNode.dataset.category = categoryKey;
                        subCategoryNode.dataset.subCategory = subCategoryKey;
                        
                        // Clean animation classes
                        subCategoryNode.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                        
                        // If this category is preparing to open, make nodes invisible initially
                        if (window.preparingToOpen === categoryKey) {
                            subCategoryNode.classList.add('prepare-opening');
                        }
                        
                        // If this sub-category is preparing to open, make nodes invisible initially
                        const subCategoryId = `${categoryKey}_${subCategoryKey}`;
                        if (window.preparingToOpenSub === subCategoryId) {
                            subCategoryNode.classList.add('prepare-opening');
                        }
                        
                        // Add visual state based on expansion
                        const isSubCategoryExpanded = expandedSubCategories.has(subCategoryId);
                        subCategoryNode.classList.add(isSubCategoryExpanded ? 'expanded' : 'collapsed');
                        
                        // Sub-category node content
                        let subCategoryIcon = '';
                        if (subCategoryKey === 'training') subCategoryIcon = 'üéñÔ∏è';
                        else if (subCategoryKey === 'weapons') subCategoryIcon = 'üî´';
                        else if (subCategoryKey === 'airstrike') subCategoryIcon = '‚úàÔ∏è';
                        else if (subCategoryKey === 'expeditions') subCategoryIcon = 'üó∫Ô∏è';
                        else if (subCategoryKey === 'npc') subCategoryIcon = 'üë§';
                        else if (subCategoryKey === 'heavyWeapons') subCategoryIcon = 'üî´';
                        else if (subCategoryKey === 'defensiveStructures') subCategoryIcon = 'üèóÔ∏è';
                        else subCategoryIcon = '‚ö°';
                        
                        subCategoryNode.innerHTML = `
                            <div class="node-icon">${subCategoryIcon}</div>
                            <div class="node-level">${subCategoryData.title}</div>
                        `;
                        
                        // Add click event to toggle sub-category
                        subCategoryNode.addEventListener('click', () => toggleSubCategory(categoryKey, subCategoryKey));
                        
                        subTreeContainer.appendChild(subCategoryNode);
                    } else {
                        // Create a simple header for categories without sub-category nodes
                        const subTreeHeader = document.createElement('div');
                        subTreeHeader.className = 'sub-tree-header';
                        subTreeHeader.textContent = subCategoryData.title;
                        subTreeContainer.appendChild(subTreeHeader);
                    }
                    
                    // Only render upgrades if sub-category is expanded (for categories with sub-category nodes)
                    const shouldRenderUpgrades = !showSubCategoryNodes || (showSubCategoryNodes && isSubCategoryExpanded);
                    
                    if (shouldRenderUpgrades) {
                        // Upgrade path
                        const upgradePath = document.createElement('div');
                        upgradePath.className = 'upgrade-path';
                        
                        subCategoryData.upgrades.forEach((upgrade, index) => {
                        // Create connection line (except for first upgrade)
                        if (index > 0) {
                            const connectionLine = document.createElement('div');
                            connectionLine.className = 'connection-line connection-animate';
                            connectionLine.dataset.category = categoryKey;
                            connectionLine.dataset.subCategory = subCategoryKey;
                            
                            // Clean animation classes
                            connectionLine.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                            
                            // If this category is preparing to open, make connections invisible initially
                            if (window.preparingToOpen === categoryKey) {
                                connectionLine.classList.add('prepare-opening');
                            }
                            
                            // If this sub-category is preparing to open, make connections invisible initially
                            const subCategoryId = `${categoryKey}_${subCategoryKey}`;
                            if (window.preparingToOpenSub === subCategoryId) {
                                connectionLine.classList.add('prepare-opening');
                            }
                            
                            // Calculate positioning based on screen size
                            const isMobile = window.innerWidth <= 768;
                            const nodeSize = isMobile ? 50 : 60;
                            const gapSize = isMobile ? 40 : 50;
                            const lineHeight = gapSize;
                            
                            connectionLine.style.top = `${(index - 1) * (nodeSize + gapSize) + nodeSize}px`;
                            connectionLine.style.height = `${lineHeight}px`;
                            
                            // Determine line state
                            const prevUpgrade = subCategoryData.upgrades[index - 1];
                            if (prevUpgrade.unlocked && upgrade.unlocked) {
                                connectionLine.classList.add('unlocked');
                            } else if (prevUpgrade.unlocked && !upgrade.unlocked) {
                                connectionLine.classList.add('available');
                            } else {
                                connectionLine.classList.add('locked');
                            }
                            
                            upgradePath.appendChild(connectionLine);
                        }
                        
                        // Create upgrade node
                        const upgradeNode = document.createElement('div');
                        upgradeNode.className = 'upgrade-node skill-node-animate';
                        upgradeNode.dataset.upgradeId = upgrade.id;
                        upgradeNode.dataset.category = categoryKey;
                        upgradeNode.dataset.subCategory = subCategoryKey;
                        
                        // Clean animation classes
                        upgradeNode.classList.remove('animate-in', 'animate-out', 'show', 'completely-hidden', 'prepare-opening');
                        
                        // If this category is preparing to open, make nodes invisible initially
                        if (window.preparingToOpen === categoryKey) {
                            upgradeNode.classList.add('prepare-opening');
                        }
                        
                        // If this sub-category is preparing to open, make nodes invisible initially
                        const subCategoryId = `${categoryKey}_${subCategoryKey}`;
                        if (window.preparingToOpenSub === subCategoryId) {
                            upgradeNode.classList.add('prepare-opening');
                        }
                        
                        // Determine node state
                        if (upgrade.unlocked) {
                            upgradeNode.classList.add('unlocked');
                        } else if (index === 0 || subCategoryData.upgrades[index - 1].unlocked) {
                            upgradeNode.classList.add('available');
                        } else {
                            upgradeNode.classList.add('locked');
                        }
                        
                        // Add selection state
                        if (selectedUpgrade && selectedUpgrade.id === upgrade.id && 
                            selectedUpgrade.category === categoryKey && 
                            selectedUpgrade.subCategory === subCategoryKey) {
                            upgradeNode.classList.add('selected');
                        }
                        
                        // Node content
                        upgradeNode.innerHTML = `
                            <div class="node-icon">${upgrade.icon}</div>
                            <div class="node-level">Lv.${upgrade.id}</div>
                            ${!upgrade.unlocked ? `<div class="node-cost">${upgrade.cost} RP</div>` : ''}
                            ${upgradeNode.classList.contains('locked') ? '<div class="lock-icon">üîí</div>' : ''}
                        `;
                        
                        // Add click event
                        if (!upgrade.unlocked && (index === 0 || subCategoryData.upgrades[index - 1].unlocked)) {
                            upgradeNode.addEventListener('click', () => selectUpgrade(upgrade, categoryKey, subCategoryKey));
                        }
                        
                        // Add hover tooltip
                        upgradeNode.addEventListener('mouseenter', (e) => showTooltip(e, upgrade));
                        upgradeNode.addEventListener('mouseleave', hideTooltip);
                        
                        upgradePath.appendChild(upgradeNode);
                    });
                    
                        subTreeContainer.appendChild(upgradePath);
                    }
                    
                    subCategoriesContainer.appendChild(subTreeContainer);
                });
                
                    mainCategoryContainer.appendChild(subCategoriesContainer);
                }
                
                treesContentWrapper.appendChild(mainCategoryContainer);
            });
        }

        // Get icon for category
        function getIconForCategory(categoryKey) {
            const icons = {
                buildings: 'üèóÔ∏è',
                combat: '‚öîÔ∏è',
                walls: 'üß±',
                garrison: 'üè∞',
                farm: 'üåæ',
                laboratory: 'üß™',
                support: 'ü§ù',
                revive: '‚ù§Ô∏è',
                reroll: 'üîÑ'
            };
            return icons[categoryKey] || '‚≠ê';
        }
        
        // Toggle category expansion with animation
        function toggleCategory(categoryKey) {
            if (expandedCategories.has(categoryKey)) {
                // Closing animation
                animateNodesOut(categoryKey, () => {
                    expandedCategories.delete(categoryKey);
                    renderUpgradeTrees();
                });
            } else {
                // Opening animation
                expandedCategories.add(categoryKey);
                // Mark category as preparing to open
                window.preparingToOpen = categoryKey;
                renderUpgradeTrees();
                // Animate in after a brief delay to ensure DOM is ready
                setTimeout(() => {
                    window.preparingToOpen = null;
                    animateNodesIn(categoryKey);
                }, 50);
            }
        }
        
        // Toggle sub-category expansion with animation
        function toggleSubCategory(categoryKey, subCategoryKey) {
            const subCategoryId = `${categoryKey}_${subCategoryKey}`;
            
            if (expandedSubCategories.has(subCategoryId)) {
                // Closing animation
                animateSubCategoryOut(categoryKey, subCategoryKey, () => {
                    expandedSubCategories.delete(subCategoryId);
                    renderUpgradeTrees();
                });
            } else {
                // Opening animation
                expandedSubCategories.add(subCategoryId);
                // Mark sub-category as preparing to open
                window.preparingToOpenSub = subCategoryId;
                renderUpgradeTrees();
                // Animate in after a brief delay to ensure DOM is ready
                setTimeout(() => {
                    window.preparingToOpenSub = null;
                    animateSubCategoryIn(categoryKey, subCategoryKey);
                }, 50);
            }
        }
        
        // Animate nodes appearing one by one
        function animateNodesIn(categoryKey) {
            const categoryNodes = document.querySelectorAll(`[data-category="${categoryKey}"].skill-node-animate, [data-category="${categoryKey}"].connection-animate, [data-category="${categoryKey}"].radial-connection-animate`);
            
            categoryNodes.forEach((node, index) => {
                // Staggered delay for ASMR effect
                setTimeout(() => {
                    // Remove prepare-opening state and prepare for animation
                    node.classList.remove('prepare-opening', 'animate-out');
                    node.classList.add('animate-in');
                    
                    // Short delay to allow the invisible state to register, then show
                    setTimeout(() => {
                        node.classList.add('show');
                    }, 20);
                    
                }, index * 120); // 120ms delay between each node
            });
        }
        
        // Animate nodes disappearing one by one
        function animateNodesOut(categoryKey, callback) {
            const categoryNodes = document.querySelectorAll(`[data-category="${categoryKey}"].skill-node-animate, [data-category="${categoryKey}"].connection-animate, [data-category="${categoryKey}"].radial-connection-animate`);
            
            if (categoryNodes.length === 0) {
                callback();
                return;
            }
            
            // Reverse order for closing (last to first)
            const nodesArray = Array.from(categoryNodes).reverse();
            
            nodesArray.forEach((node, index) => {
                const staggerDelay = index * 80; // 80ms delay between each node
                
                // Start the scale-down animation
                setTimeout(() => {
                    node.classList.remove('animate-in', 'show');
                    node.classList.add('animate-out');
                    
                    // Completely hide this individual node after its animation completes
                    setTimeout(() => {
                        node.classList.add('completely-hidden');
                    }, 400); // Animation duration
                    
                }, staggerDelay);
                
                // Call callback after the last animation completes
                if (index === nodesArray.length - 1) {
                    setTimeout(callback, staggerDelay + 400); // Wait for last animation to complete
                }
            });
        }
        
        // Animate sub-category nodes appearing one by one
        function animateSubCategoryIn(categoryKey, subCategoryKey) {
            const subCategoryNodes = document.querySelectorAll(`[data-category="${categoryKey}"][data-sub-category="${subCategoryKey}"].skill-node-animate, [data-category="${categoryKey}"][data-sub-category="${subCategoryKey}"].connection-animate, [data-category="${categoryKey}"][data-sub-category="${subCategoryKey}"].radial-connection-animate`);
            
            subCategoryNodes.forEach((node, index) => {
                // Staggered delay for ASMR effect
                setTimeout(() => {
                    // Remove prepare-opening state and prepare for animation
                    node.classList.remove('prepare-opening', 'animate-out');
                    node.classList.add('animate-in');
                    
                    // Short delay to allow the invisible state to register, then show
                    setTimeout(() => {
                        node.classList.add('show');
                    }, 20);
                    
                }, index * 120); // 120ms delay between each node
            });
        }
        
        // Animate sub-category nodes disappearing one by one
        function animateSubCategoryOut(categoryKey, subCategoryKey, callback) {
            const subCategoryNodes = document.querySelectorAll(`[data-category="${categoryKey}"][data-sub-category="${subCategoryKey}"].skill-node-animate, [data-category="${categoryKey}"][data-sub-category="${subCategoryKey}"].connection-animate, [data-category="${categoryKey}"][data-sub-category="${subCategoryKey}"].radial-connection-animate`);
            
            if (subCategoryNodes.length === 0) {
                callback();
                return;
            }
            
            // Reverse order for closing (last to first)
            const nodesArray = Array.from(subCategoryNodes).reverse();
            
            nodesArray.forEach((node, index) => {
                const staggerDelay = index * 80; // 80ms delay between each node
                
                // Start the scale-down animation
                setTimeout(() => {
                    node.classList.remove('animate-in', 'show');
                    node.classList.add('animate-out');
                    
                    // Completely hide this individual node after its animation completes
                    setTimeout(() => {
                        node.classList.add('completely-hidden');
                    }, 400); // Animation duration
                    
                }, staggerDelay);
                
                // Call callback after the last animation completes
                if (index === nodesArray.length - 1) {
                    setTimeout(callback, staggerDelay + 400); // Wait for last animation to complete
                }
            });
        }

        // Select an upgrade
        function selectUpgrade(upgrade, category, subCategory) {
            selectedUpgrade = upgrade;
            selectedUpgrade.category = category;
            selectedUpgrade.subCategory = subCategory;
            
            // Update visual selection
            document.querySelectorAll('.upgrade-node').forEach(node => {
                node.classList.remove('selected');
            });
            document.querySelector(`[data-upgrade-id="${upgrade.id}"][data-category="${category}"][data-sub-category="${subCategory}"]`).classList.add('selected');
            
            // Show upgrade details
            showUpgradeDetails(upgrade);
            
            // Update unlock button
            updateUnlockButton();
        }

        // Show upgrade details
        function showUpgradeDetails(upgrade) {
            // Remove existing details panel
            const existingPanel = document.querySelector('.upgrade-details');
            if (existingPanel) {
                existingPanel.remove();
            }
            
            const detailsPanel = document.createElement('div');
            detailsPanel.className = 'upgrade-details';
            detailsPanel.innerHTML = `
                <div class="upgrade-name">${upgrade.name}</div>
                <div class="upgrade-effect">${upgrade.effect}</div>
            `;
            
            document.querySelector('.meta-upgrade-modal').appendChild(detailsPanel);
        }

        // Update unlock button
        function updateUnlockButton() {
            const button = document.getElementById('unlockButton');
            
            if (!selectedUpgrade) {
                button.className = 'unlock-button no-selection';
                button.textContent = 'SELECT UPGRADE';
                return;
            }
            
            if (currentRP >= selectedUpgrade.cost) {
                button.className = 'unlock-button can-afford';
                button.textContent = `UNLOCK (${selectedUpgrade.cost} RP)`;
            } else {
                button.className = 'unlock-button cannot-afford';
                button.textContent = `INSUFFICIENT RP (${selectedUpgrade.cost} RP)`;
            }
        }

        // Unlock selected upgrade
        function unlockUpgrade() {
            if (!selectedUpgrade || currentRP < selectedUpgrade.cost) {
                return;
            }
            
            // Deduct RP
            currentRP -= selectedUpgrade.cost;
            updateRPDisplay();
            
            // Mark upgrade as unlocked
            selectedUpgrade.unlocked = true;
            
            // Play unlock animation
            const nodeElement = document.querySelector(`[data-upgrade-id="${selectedUpgrade.id}"][data-category="${selectedUpgrade.category}"][data-sub-category="${selectedUpgrade.subCategory}"]`);
            nodeElement.classList.add('unlock-animation');
            
            setTimeout(() => {
                nodeElement.classList.remove('unlock-animation');
                // Re-render all trees to update visuals
                renderUpgradeTrees();
            }, 600);
            
            // Clear selection
            selectedUpgrade = null;
            
            // Remove details panel
            const detailsPanel = document.querySelector('.upgrade-details');
            if (detailsPanel) {
                detailsPanel.remove();
            }
        }

        // Update RP display
        function updateRPDisplay() {
            document.getElementById('rpAmount').textContent = currentRP;
        }

        // Show tooltip
        function showTooltip(event, upgrade) {
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            
            // Find the category and sub-category this upgrade belongs to
            const upgradeNode = event.target.closest('.upgrade-node');
            const upgradeCategory = upgradeNode.dataset.category;
            const upgradeSubCategory = upgradeNode.dataset.subCategory;
            const categoryData = upgradeData[upgradeCategory];
            const subCategoryData = categoryData.subCategories[upgradeSubCategory];
            
            // Determine status
            let status = '';
            let statusClass = '';
            if (upgrade.unlocked) {
                status = 'UNLOCKED';
                statusClass = 'unlocked';
            } else {
                const upgradeIndex = subCategoryData.upgrades.findIndex(u => u.id === upgrade.id);
                const canUnlock = upgradeIndex === 0 || subCategoryData.upgrades[upgradeIndex - 1].unlocked;
                
                if (canUnlock) {
                    status = `COST: ${upgrade.cost} RP`;
                    statusClass = 'available';
                } else {
                    status = 'LOCKED';
                    statusClass = 'locked';
                }
            }
            
            // Special formatting for building upgrades
            let effectDisplay = upgrade.effect;
            if (upgradeCategory === 'buildings' && upgradeSubCategory === 'levels') {
                effectDisplay = formatBuildingEffect(upgrade.id, upgrade.effect);
            }
            
            tooltip.innerHTML = `
                <div class="tooltip-icon">${upgrade.icon}</div>
                <div class="tooltip-title">${upgrade.name}</div>
                <div class="tooltip-effect">${effectDisplay}</div>
                <div class="tooltip-description">Level ${upgrade.id} upgrade for ${categoryData.title} - ${subCategoryData.title}</div>
                <div class="tooltip-status ${statusClass}">${status}</div>
            `;
            
            document.querySelector('.meta-upgrade-modal').appendChild(tooltip);
            
            // Position tooltip relative to modal
            const rect = event.target.getBoundingClientRect();
            const modalRect = document.querySelector('.meta-upgrade-modal').getBoundingClientRect();
            
            // Position to the right of the node, but check if it would overflow
            let leftPos = rect.right - modalRect.left + 15;
            if (leftPos + 250 > modalRect.width) {
                // Position to the left instead
                leftPos = rect.left - modalRect.left - 265;
            }
            
            tooltip.style.left = leftPos + 'px';
            tooltip.style.top = (rect.top - modalRect.top - 20) + 'px';
        }
        
        // Format building upgrade effects for better readability
        function formatBuildingEffect(upgradeId, originalEffect) {
            const probabilityData = {
                0: { L1: 80, L2: 19, L3: 1, L4: 0, L5: 0 },    // Default
                1: { L1: 50, L2: 30, L3: 15, L4: 5, L5: 0 },   // Enhanced
                2: { L1: 25, L2: 35, L3: 25, L4: 12, L5: 3 },  // Improved
                3: { L1: 10, L2: 25, L3: 35, L4: 25, L5: 5 },  // Advanced
                4: { L1: 5, L2: 15, L3: 30, L4: 35, L5: 15 },  // Superior
                5: { L1: 2, L2: 8, L3: 20, L4: 40, L5: 30 }    // Master
            };
            
            const beforeData = probabilityData[upgradeId - 1];
            const afterData = probabilityData[upgradeId];
            
            if (beforeData && afterData) {
                let tableRows = '';
                
                for (let level = 1; level <= 5; level++) {
                    const levelKey = `L${level}`;
                    const beforeValue = beforeData[levelKey];
                    const afterValue = afterData[levelKey];
                    
                    let changeIcon = '';
                    let changeClass = '';
                    
                    if (beforeValue === 0 && afterValue > 0) {
                        changeIcon = '‚ú® NEW';
                        changeClass = 'change-new';
                    } else if (afterValue > beforeValue) {
                        changeIcon = '‚¨ÜÔ∏è +' + (afterValue - beforeValue) + '%';
                        changeClass = 'change-up';
                    } else if (afterValue < beforeValue) {
                        changeIcon = '‚¨áÔ∏è -' + (beforeValue - afterValue) + '%';
                        changeClass = 'change-down';
                    } else {
                        changeIcon = '‚û°Ô∏è Same';
                        changeClass = '';
                    }
                    
                    tableRows += `
                        <tr>
                            <td class="level-cell">${levelKey}</td>
                            <td class="before-cell">${beforeValue}%</td>
                            <td class="after-cell">${afterValue}%</td>
                            <td class="change-cell ${changeClass}">${changeIcon}</td>
                        </tr>
                    `;
                }
                
                return `
                    <table class="building-comparison-table">
                        <thead>
                            <tr>
                                <th>Level</th>
                                <th>Before</th>
                                <th>After</th>
                                <th>Change</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                `;
            }
            
            return originalEffect;
        }



        // Hide tooltip
        function hideTooltip() {
            const tooltip = document.querySelector('.tooltip');
            if (tooltip) {
                tooltip.remove();
            }
        }

        // Close modal
        function closeModal() {
            document.body.style.overflow = 'auto';
            window.location.href = 'game.html'; // Return to game
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html> 